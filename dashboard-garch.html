<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sistema Quant Pro - G√™nesis Trading</title>
  <style>
    :root{
      --primary-gradient: linear-gradient(135deg, #4f46e5, #7c3aed, #06b6d4);
      --bg: #f8fafc;
      --panel: #ffffff;
      --panel-2: #f1f5f9;
      --text: #1e293b;
      --muted: #64748b;
      --accent: #3b82f6;
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
      --border: #e2e8f0;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --ai-gradient: linear-gradient(135deg, #8b5cf6, #06b6d4);
      --ai-bg: linear-gradient(145deg, #f0f9ff, #e0f2fe);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
    }
    
    header {
      padding: 16px 20px;
      background: var(--primary-gradient);
      color: white;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: var(--shadow-lg);
    }
    
    @media(min-width:768px){header{padding:24px;}}
    
    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .title {
      font-size: 18px;
      font-weight: 800;
      letter-spacing: -.5px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    @media(min-width:768px){.title{font-size:24px;gap:12px;}}
    
    .sub {
      color: rgba(255,255,255,0.9);
      font-size: 12px;
      margin-top: 6px;
      font-weight: 400;
      line-height: 1.4;
    }
    
    @media(min-width:768px){.sub{font-size:14px;}}
    
    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .user-name {
      font-weight: 600;
      font-size: 14px;
    }
    
    .status-badge {
      background: rgba(255,255,255,0.2);
      color: white;
      padding: 4px 8px;
      border-radius: 20px;
      font-size: 10px;
      font-weight: 600;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    @media(min-width:768px){.status-badge{padding:4px 12px;font-size:11px;}}
    
    .logout-btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .logout-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-1px);
    }
    
    main {
      padding: 16px;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    @media(min-width:768px){main{padding:32px 24px;}}
    
    .main-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    @media(min-width:1024px){
      .main-grid{
        grid-template-columns: 1fr 300px;
        gap: 24px;
      }
    }
    
    .content-area {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    @media(min-width:1200px){
      .content-area{
        grid-template-columns: 1.2fr 0.8fr;
        gap: 24px;
      }
    }
    
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    
    @media(min-width:768px){.panel{border-radius:20px;padding:24px;}}
    
    .ai-panel {
      background: var(--ai-bg);
      border: 2px solid #06b6d4;
      position: relative;
      overflow: hidden;
    }
    
    .ai-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--ai-gradient);
    }
    
    h2.section-title {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-title {
      background: var(--ai-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .muted {
      color: var(--muted);
    }
    
    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    
    @media(min-width:480px){.toolbar{gap:12px;}}
    
    .btn {
      background: var(--panel-2);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 12px 16px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: var(--shadow);
    }
    
    .btn:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }
    
    .btn.primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    
    .btn.ai {
      background: var(--ai-gradient);
      color: white;
      border: none;
    }
    
    .btn.success {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .periods {
      display: flex;
      gap: 6px;
      margin: 8px 0 16px;
      flex-wrap: wrap;
    }
    
    @media(min-width:480px){.periods{gap:8px;}}
    
    .tab {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      background: var(--panel-2);
      font-size: 12px;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: var(--shadow);
    }
    
    @media(min-width:480px){.tab{padding:10px 16px;font-size:13px;}}
    
    .tab.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    
    .cards {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    @media(min-width:480px){.cards{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media(min-width:768px){.cards{grid-template-columns:repeat(3,minmax(0,1fr));}}
    @media(min-width:1024px){.cards{grid-template-columns:repeat(4,minmax(0,1fr));}}
    
    .fair-price-cards {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    @media(min-width:480px){.fair-price-cards{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media(min-width:768px){.fair-price-cards{grid-template-columns:repeat(4,minmax(0,1fr));}}
    
    .card {
      background: linear-gradient(145deg, #ffffff, #f8fafc);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--accent), var(--success));
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .card:hover::before {
      opacity: 1;
    }
    
    .card.up-card {
      background: linear-gradient(145deg, #f0fdf4, #dcfce7);
      border-color: #bbf7d0;
    }
    
    .card.down-card {
      background: linear-gradient(145deg, #fef2f2, #fee2e2);
      border-color: #fecaca;
    }
    
    .card.neutral-card {
      background: linear-gradient(145deg, #f1f5f9, #e2e8f0);
      border-color: #cbd5e1;
    }
    
    .label {
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .5px;
      margin-bottom: 8px;
      line-height: 1.3;
    }
    
    .value {
      font-size: 18px;
      font-weight: 900;
      letter-spacing: -.5px;
      line-height: 1.2;
    }
    
    @media(min-width:480px){.value{font-size:20px;}}
    @media(min-width:768px){.value{font-size:22px;}}
    
    .value.up {
      color: var(--success);
    }
    
    .value.down {
      color: var(--error);
    }
    
    .inputs {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 12px;
      margin: 12px 0 16px;
    }
    
    @media(min-width:480px){.inputs{grid-template-columns:repeat(3,minmax(0,1fr));}}
    
    .input {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      box-shadow: var(--shadow);
    }
    
    .input label {
      display: block;
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: .5px;
    }
    
    .input input, .input select {
      width: 100%;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      padding: 10px;
      font-weight: 600;
    }
    
    .hint {
      font-size: 12px;
      color: var(--muted);
      font-weight: 500;
    }
    
    .api-config {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin: 16px 0;
    }
    
    .api-status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }
    
    .api-status.connected {
      background: #dcfce7;
      color: #166534;
    }
    
    .api-status.disconnected {
      background: #fee2e2;
      color: #991b1b;
    }
    
    .api-status.testing {
      background: #fef3c7;
      color: #92400e;
    }
    
    .sep {
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--border), transparent);
      margin: 24px 0;
    }
    
    textarea {
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      resize: vertical;
      box-shadow: var(--shadow);
    }
    
    input[type="file"] {
      color: var(--text);
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      width: 100%;
      box-shadow: var(--shadow);
    }
    
    .debug {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin: 12px 0;
      font-size: 11px;
      color: var(--muted);
      font-family: monospace;
      box-shadow: var(--shadow);
    }
    
    .maxmin-grid {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 12px;
    }
    
    @media(min-width:480px){.maxmin-grid{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media(min-width:768px){.maxmin-grid{grid-template-columns:repeat(3,minmax(0,1fr));gap:16px;}}
    
    footer {
      color: var(--muted);
      text-align: center;
      padding: 32px;
      font-size: 12px;
      font-weight: 600;
      margin-top: 40px;
      border-top: 1px solid var(--border);
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(248, 250, 252, 0.8);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid var(--border);
      border-top: 4px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .welcome-banner {
      background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
      border: 1px solid #7dd3fc;
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 24px;
      text-align: center;
    }
    
    .welcome-banner h3 {
      color: var(--accent);
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    .welcome-banner p {
      color: var(--muted);
      font-size: 14px;
    }
    
    .api-info {
      background: var(--panel-2);
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
      font-size: 11px;
      line-height: 1.4;
    }
    
    .provider-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin: 12px 0;
    }
    
    .provider-card {
      background: var(--panel);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }
    
    .provider-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .provider-card.active {
      border-color: var(--accent);
      background: linear-gradient(145deg, #f0f9ff, #dbeafe);
    }
    
    .provider-card h4 {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 4px;
      color: var(--text);
    }
    
    .provider-card p {
      font-size: 11px;
      color: var(--muted);
    }

    .frp-highlight {
      background: #fff3cd !important;
      border-color: #f59e0b !important;
    }

    .frp-disabled {
      background: #f8f9fa !important;
      opacity: 0.7;
    }
    
    /* AI-specific styles */
    .ai-insights {
      display: grid;
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .insight-card {
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #06b6d4;
      border-radius: 12px;
      padding: 16px;
      transition: all 0.3s;
    }
    
    .insight-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .insight-title {
      font-weight: 700;
      color: #0369a1;
      margin-bottom: 8px;
      font-size: 14px;
    }
    
    .insight-content {
      font-size: 13px;
      line-height: 1.5;
      color: var(--text);
    }
    
    .opportunity-score {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 16px 0;
    }
    
    .score-circle {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--ai-gradient);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      box-shadow: var(--shadow-lg);
      transition: all 0.5s ease;
    }
    
    .score-circle.buy-signal {
      background: linear-gradient(135deg, #10b981, #059669, #047857);
      box-shadow: 0 10px 15px -3px rgba(16, 185, 129, 0.3);
    }
    
    .score-circle.sell-signal {
      background: linear-gradient(135deg, #ef4444, #dc2626, #b91c1c);
      box-shadow: 0 10px 15px -3px rgba(239, 68, 68, 0.3);
    }
    
    .score-circle.neutral-signal {
      background: linear-gradient(135deg, #3b82f6, #2563eb, #1d4ed8);
      box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3);
    }
    
    .score-circle.wait-signal {
      background: linear-gradient(135deg, #f59e0b, #d97706, #b45309);
      box-shadow: 0 10px 15px -3px rgba(245, 158, 11, 0.3);
    }
    
    .score-value {
      font-size: 24px;
      font-weight: 900;
    }
    
    .score-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .scenario-bars {
      display: grid;
      gap: 12px;
    }
    
    .scenario {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .scenario-label {
      flex: 0 0 140px;
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
    }
    
    .probability-bar {
      flex: 1;
      height: 20px;
      background: var(--panel-2);
      border-radius: 10px;
      position: relative;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: var(--ai-gradient);
      border-radius: 10px;
      transition: width 0.5s ease;
    }
    
    .percentage {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 11px;
      font-weight: 600;
      color: var(--text);
    }
    
    .alerts-container {
      display: grid;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .alert-item {
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.4;
      border-left: 4px solid;
      margin-bottom: 4px;
    }
    
    .alert-item strong {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
    }
    
    .alert-item em {
      font-size: 11px;
      opacity: 0.8;
      display: block;
      margin-top: 4px;
    }
    
    .alert-item.warning {
      background: #fef3c7;
      border-color: #f59e0b;
      color: #92400e;
    }
    
    .alert-item.success {
      background: #dcfce7;
      border-color: #10b981;
      color: #166534;
    }
    
    .alert-item.info {
      background: #e0f2fe;
      border-color: #06b6d4;
      color: #0369a1;
    }
    
    .ai-narrative {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #06b6d4;
      border-radius: 12px;
      padding: 16px;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text);
    }
    
    .ai-narrative h4 {
      color: #0369a1;
      margin-bottom: 12px;
      font-size: 14px;
    }
    
    .ai-narrative p {
      margin-bottom: 10px;
    }
    
    .ai-narrative strong {
      color: var(--text);
    }
    
    /* Advanced metrics styles */
    .advanced-metrics {
	display: grid;
	grid-template-columns: repeat(2, 1fr); /* Sempre 2 colunas */
	gap: 12px;
	margin: 16px 0;
	}

	/* Para telas muito pequenas, usar 1 coluna */
	@media(max-width: 480px){
	.advanced-metrics{
    grid-template-columns: repeat(1, 1fr);
	}
	}
    
    .metric-card-advanced {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .metric-value-advanced {
      font-size: 18px;
      font-weight: 900;
      margin-bottom: 4px;
      color: var(--accent);
    }
    
    .metric-label-advanced {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    #apiConfigInputs {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    
    #apiConfigInputs .input input,
    #apiConfigInputs .input select {
      width: 100%;
      font-size: 14px;
      padding: 12px 14px;
    }
    
    @media (max-width: 480px) {
      .cards, .fair-price-cards {
        grid-template-columns: 1fr;
      }
      
      .maxmin-grid {
        grid-template-columns: 1fr;
      }
      
      .inputs {
        grid-template-columns: 1fr;
      }
      
      .toolbar {
        flex-direction: column;
        align-items: stretch;
      }
      
      .btn {
        text-align: center;
      }
      
      .provider-grid {
        grid-template-columns: 1fr;
      }
      
      .main-grid {
        grid-template-columns: 1fr;
      }
      
      .content-area {
        grid-template-columns: 1fr;
      }
      
      .advanced-metrics {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
  </div>
  
  <header>
    <div class="header-content">
      <div>
        <div class="title">Sistema Quant Pro</div>
        <div class="sub">An√°lise Avan√ßada de Contratos Futuros DOL com IA Multidimensional</div>
      </div>
      <div class="user-info">
        <div class="user-name" id="userName">Carregando...</div>
        <div class="status-badge">CONECTADO</div>
        <button class="logout-btn" id="logoutBtn">Sair</button>
      </div>
    </div>
  </header>

  <main>
    <div class="welcome-banner">
      <h3>Sistema IA Avan√ßado Inicializado com Sucesso!</h3>
      <p>Configure sua API ou use dados simulados para an√°lise multidimensional com detec√ß√£o de regime de mercado.</p>
    </div>
    
    <div class="main-grid">
      <div class="content-area">
        <section class="panel" id="proj-panel">
          <h2 class="section-title">Proje√ß√µes para Contratos Futuros</h2>
          <div class="toolbar">
            <button class="btn primary" id="btnFetchAPI">Dados via API</button>
            <button class="btn" id="btnFetch">Dados Simulados</button>
            <button class="btn" id="btnAnalyze">An√°lise Avan√ßada</button>
            <button class="btn ai" id="btnAIAnalysis">An√°lise IA Multidimensional</button>
            <span class="hint" id="dataStatus">aguardando dados‚Ä¶</span>
            <span class="api-status disconnected" id="apiStatus">API: Desconectado</span>
          </div>

          <div class="periods" id="forecastTabs">
            <div class="tab active" data-period="9">1¬™ Proje√ß√£o (9P)</div>
            <div class="tab" data-period="18">2¬™ Proje√ß√£o (18P)</div>
            <div class="tab" data-period="27">3¬™ Proje√ß√£o (27P)</div>
          </div>

          <div class="cards" id="forecastCards">
            <div class="card up-card"><div class="label">Proje√ß√£o +1œÉ</div><div class="value up" id="f_up1">--</div></div>
            <div class="card down-card"><div class="label">Proje√ß√£o -1œÉ</div><div class="value down" id="f_dn1">--</div></div>
            <div class="card up-card"><div class="label">Proje√ß√£o +2œÉ</div><div class="value up" id="f_up2">--</div></div>
            <div class="card down-card"><div class="label">Proje√ß√£o -2œÉ</div><div class="value down" id="f_dn2">--</div></div>
          </div>

          <div class="sep"></div>

          <h2 class="section-title">M√°ximas e M√≠nimas Intraday</h2>
          <div class="inputs">
            <div class="input">
              <label for="frp">FRP - Forward Rate Premium (%)</label>
              <input id="frp" type="number" step="0.01" value="15.50" placeholder="Ex: 15.50 para Selic" />
              <div class="hint">Juros impl√≠citos para converter Spot ‚Üí Futuro</div>
            </div>
            <div class="input">
              <label for="dataType">Tipo de Dados</label>
              <select id="dataType">
                <option value="spot">Spot USD/BRL (API)</option>
                <option value="future">Futuro DOL (Excel)</option>
              </select>
            </div>
            <div class="input">
              <label for="maturityDays">Vencimento (dias)</label>
              <input id="maturityDays" type="number" value="30" min="1" max="365" />
              <div class="hint">Para c√°lculo preciso do FRP</div>
            </div>
          </div>

          <div class="inputs">
            <div class="input">
              <label for="exp9">Fator EXP 9P</label>
              <input id="exp9" type="number" step="0.1" value="2.718" />
            </div>
            <div class="input">
              <label for="exp18">Fator EXP 18P</label>
              <input id="exp18" type="number" step="0.1" value="2.718" />
            </div>
            <div class="input">
              <label for="exp27">Fator EXP 27P</label>
              <input id="exp27" type="number" step="0.1" value="2.718" />
            </div>
          </div>

          <div class="periods" id="intradayTabs">
            <div class="tab active" data-iperiod="9">1¬™ Proje√ß√£o</div>
            <div class="tab" data-iperiod="18">2¬™ Proje√ß√£o </div>
            <div class="tab" data-iperiod="27">3¬™ Proje√ß√£o </div>
          </div>

          <div class="cards">
            <div class="card up-card"><div class="label">M√°xima Intraday</div><div class="value up" id="i_max">--</div></div>
            <div class="card down-card"><div class="label">M√≠nima Intraday</div><div class="value down" id="i_min">--</div></div>
            <div class="card neutral-card"><div class="label">Fechamento Base</div><div class="value" id="i_close">--</div></div>
            <div class="card neutral-card"><div class="label">œÉ Retornos (%)</div><div class="value" id="i_sigma">--</div></div>
          </div>

          <div class="debug" id="debugInfo">
            Debug: aguardando c√°lculos...
          </div>

          <div class="sep"></div>

          <h2 class="section-title">Poss√≠veis M√°ximas e M√≠nimas</h2>
          <div class="cards maxmin-grid">
            <div class="card up-card"><div class="label">M√°xima 1P </div><div class="value up" id="max_9p">--</div></div>
            <div class="card up-card"><div class="label">M√°xima 2P </div><div class="value up" id="max_18p">--</div></div>
            <div class="card up-card"><div class="label">M√°xima 3P </div><div class="value up" id="max_27p">--</div></div>
            <div class="card down-card"><div class="label">M√≠nima 1P </div><div class="value down" id="min_9p">--</div></div>
            <div class="card down-card"><div class="label">M√≠nima 2P </div><div class="value down" id="min_18p">--</div></div>
            <div class="card down-card"><div class="label">M√≠nima 3P </div><div class="value down" id="min_27p">--</div></div>
          </div>

          <div class="sep"></div>

          <h2 class="section-title">Pre√ßo Justo e Just√≠ssimo do D√≥lar</h2>
          
          <div class="fair-price-cards">
            <div class="card up-card"><div class="label">Pre√ßo Justo PPP</div><div class="value" id="fair_ppp">--</div></div>
            <div class="card up-card"><div class="label">Pre√ßo Justo UIP</div><div class="value" id="fair_uip">--</div></div>
            <div class="card neutral-card"><div class="label">Pre√ßo Just√≠ssimo</div><div class="value" id="fair_combined">--</div></div>
            <div class="card down-card"><div class="label">Desvio do Justo (%)</div><div class="value" id="deviation_fair">--</div></div>
          </div>

          <div class="fair-price-cards">
            <div class="card neutral-card"><div class="label">Diferencial Juros</div><div class="value" id="interest_diff">--</div></div>
            <div class="card neutral-card"><div class="label">Diferencial Infla√ß√£o</div><div class="value" id="inflation_diff">--</div></div>
            <div class="card neutral-card"><div class="label">Fator Risco Ajustado</div><div class="value" id="risk_factor">--</div></div>
            <div class="card neutral-card"><div class="label">Tend√™ncia 30D</div><div class="value" id="trend_30d">--</div></div>
          </div>

          <div class="inputs">
            <div class="input">
              <label for="ppp_rate">Taxa PPP Base (R$)</label>
              <input id="ppp_rate" type="number" step="0.01" value="5.20" />
              <div class="hint">Paridade do Poder de Compra hist√≥rica</div>
            </div>
            <div class="input">
              <label for="inflation_br">Infla√ß√£o Brasil (%aa)</label>
              <input id="inflation_br" type="number" step="0.1" value="4.5" />
              <div class="hint">IPCA acumulado 12 meses</div>
            </div>
            <div class="input">
              <label for="inflation_us">Infla√ß√£o EUA (%aa)</label>
              <input id="inflation_us" type="number" step="0.1" value="5.2" />
              <div class="hint">CPI acumulado 12 meses</div>
            </div>
          </div>

          <div class="inputs">
            <div class="input">
              <label for="selic_rate">Taxa Selic (%aa)</label>
              <input id="selic_rate" type="number" step="0.25" value="15.50" />
            </div>
            <div class="input">
              <label for="fed_rate">Taxa Fed (%aa)</label>
              <input id="fed_rate" type="number" step="0.25" value="5.50" />
            </div>
            <div class="input">
              <label for="risk_premium">Pr√™mio de Risco (%)</label>
              <input id="risk_premium" type="number" step="0.1" value="2.5" />
              <div class="hint">Risco pa√≠s + volatilidade</div>
            </div>
          </div>

          <div class="sep"></div>

          <h2 class="section-title">Indicadores Adicionais</h2>
          <div class="cards">
            <div class="card neutral-card"><div class="label">Retorno Linear Atual</div><div class="value" id="ret_current">--</div></div>
            <div class="card neutral-card"><div class="label">Desvio 9P (%)</div><div class="value" id="std9">--</div></div>
            <div class="card neutral-card"><div class="label">Desvio 18P (%)</div><div class="value" id="std18">--</div></div>
            <div class="card neutral-card"><div class="label">Desvio 27P (%)</div><div class="value" id="std27">--</div></div>
            <div class="card neutral-card"><div class="label">Exp(œÉ9) Factor</div><div class="value" id="exp_std9">--</div></div>
            <div class="card neutral-card"><div class="label">Exp(œÉ18) Factor</div><div class="value" id="exp_std18">--</div></div>
            <div class="card neutral-card"><div class="label">Exp(œÉ27) Factor</div><div class="value" id="exp_std27">--</div></div>
          </div>

        </section>

        <section class="panel ai-panel" id="ai-analysis-panel">
          <h2 class="section-title ai-title">An√°lise IA Multidimensional</h2>
          
          <!-- M√©tricas Avan√ßadas -->
          <div class="advanced-metrics">
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="advancedConfidenceDisplay">--</div>
              <div class="metric-label-advanced">Confian√ßa Multi</div>
            </div>
            
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="marketRegimeDisplay">--</div>
              <div class="metric-label-advanced">Regime</div>
            </div>
            
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="confluenceDisplay">--</div>
              <div class="metric-label-advanced">Conflu√™ncia</div>
            </div>
            
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="riskRewardDisplay">--</div>
              <div class="metric-label-advanced">Risk/Reward</div>
            </div>
          </div>
          
          <div class="ai-insights">
            <div class="insight-card">
              <div class="insight-title">Situa√ß√£o Atual</div>
              <div class="insight-content" id="aiCurrentSituation">
                Execute 'An√°lise IA' para insights multidimensionais...
              </div>
            </div>
            
            <div class="opportunity-score">
              <div class="score-circle">
                <span class="score-value" id="opportunityScore">--</span>
                <span class="score-label">Score</span>
              </div>
            </div>
            
            <div class="insight-card">
              <div class="insight-title">Estrat√©gia Operacional</div>
              <div class="insight-content" id="aiMainRecommendation">
                Aguardando an√°lise de regime de mercado...
              </div>
            </div>
          </div>

          <div class="alerts-container" id="aiAlerts" style="display: none;">
            <!-- Alerts will be populated by JS -->
          </div>

          <div class="ai-narrative" id="aiNarrative" style="display: none;">
            <!-- Narrative analysis will be populated by JS -->
          </div>

          <div class="sep"></div>

          <h3 style="font-size: 14px; margin-bottom: 12px;">Cen√°rios Probabil√≠sticos (24h)</h3>
          <div class="scenario-bars" id="aiScenarios">
            <div class="scenario">
              <span class="scenario-label">Alta Forte (>+2%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Alta Moderada (+1%/+2%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Lateral (-1%/+1%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Baixa Moderada (-2%/-1%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Baixa Forte (<-2%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
          </div>
          <div class="sep"></div>		  
		  <div class="panel" id="aiStrategyPanel">
			<h2 class="section-title">‚ö° Estrat√©gia Recomendada</h2>

			<div id="aiOperation" class="insight-card"></div>
			<div id="aiRisk" class="insight-card"></div>
			<div id="aiLevels" class="insight-card"></div>
		</div>
        </section>
      </div>

      <aside class="panel">
        <h2 class="section-title">Configura√ß√£o de APIs</h2>
        
        <!-- API Provider Selection -->
        <div class="api-config">
          <h3 style="font-size: 14px; margin-bottom: 12px;">Provedores de Dados:</h3>
          <div class="provider-grid">
            <div class="provider-card active" data-provider="alpha_vantage">
              <h4>Alpha Vantage</h4>
              <p><strong>RECOMENDADO</strong><br>25 calls/dia gr√°tis<br>USD/BRL dispon√≠vel</p>
            </div>
            <div class="provider-card" data-provider="yahoo_finance">
              <h4>Yahoo Finance</h4>
              <p>Gratuito (com limita√ß√µes)<br>Precisa de proxy CORS</p>
            </div>
            <div class="provider-card" data-provider="polygon">
              <h4>Polygon.io</h4>
              <p>5 calls/min gr√°tis<br>Dados profissionais</p>
            </div>
            <div class="provider-card" data-provider="tradier">
              <h4>Tradier</h4>
              <p>Sandbox gratuito<br>Live data premium</p>
            </div>
          </div>
        </div>

        <!-- API Configuration -->
        <div class="inputs" id="apiConfigInputs">
          <div class="input">
            <label for="apiKey">API Key Alpha Vantage</label>
            <input id="apiKey" type="password" placeholder="Cole sua chave aqui ou digite 'demo'" />
          </div>
          <div class="input">
            <label for="symbol">Par de Moedas</label>
            <input id="symbol" type="text" value="USD/BRL" placeholder="USD/BRL (fixo)" readonly style="background: #f8f9fa;" />
          </div>
          <div class="input">
            <label for="interval">Intervalo</label>
            <select id="interval">
              <option value="daily">Di√°rio (Recomendado)</option>
              <option value="weekly">Semanal</option>
              <option value="monthly">Mensal</option>
            </select>
          </div>
        </div>

        <div class="api-info" style="margin: 12px 0; padding: 12px; background: linear-gradient(135deg, #f0fdf4, #dcfce7); border-radius: 8px;">
          <h4 style="color: #166534; margin-bottom: 8px;">Sistema FRP (Forward Rate Premium)</h4>
          <div style="font-size: 12px; line-height: 1.6; color: #374151;">
            <p><strong>Dados de Excel (DOL Futuro):</strong> J√° incorporam juros, usar "Futuro DOL"</p>
            <p><strong>Dados da API (Spot USD/BRL):</strong> Configurar FRP para converter</p>
            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; padding: 8px; margin-top: 8px; font-size: 11px;">
              üí° <strong>FRP Sugerido:</strong> Use ~13.75% (Selic atual) para convers√£o spot‚Üífuturo
            </div>
          </div>
        </div>

        <div class="api-info" style="margin: 12px 0; padding: 12px; background: linear-gradient(135deg, #f0f9ff, #e0f2fe); border-radius: 8px;">
          <h4 style="color: #0369a1; margin-bottom: 8px;">üîß Solu√ß√£o para Problemas de CORS:</h4>
          <div style="font-size: 12px; line-height: 1.6; color: #374151;">
            <p><strong>Se der erro de "Resposta inv√°lida":</strong></p>
            <ol style="padding-left: 16px; margin: 8px 0;">
              <li>Use <code style="background: #f3f4f6; padding: 2px 4px; border-radius: 3px;">demo</code> como API Key</li>
              <li>Clique "üîç Testar API" (vai funcionar em modo demo)</li>
              <li>Clique "üì° Dados via API" (carregar√° dados real√≠sticos)</li>
            </ol>
            <p><strong>Para API Key real:</strong></p>
            <ol style="padding-left: 16px; margin: 8px 0;">
              <li><strong>Cadastre-se GR√ÅTIS:</strong> <a href="https://www.alphavantage.co/support/#api-key" target="_blank" style="color: #0369a1;">alphavantage.co/support/#api-key</a></li>
              <li><strong>Receba</strong> API key por email</li>
              <li><strong>Cole aqui</strong> e teste</li>
            </ol>
          </div>
          <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; padding: 8px; margin-top: 8px; font-size: 11px;">
            üí° <strong>IMPORTANTE:</strong> Mesmo com erro de CORS, o sistema funciona perfeitamente com dados demo real√≠sticos!
          </div>
        </div>

        <div class="toolbar" style="margin-top: 16px;">
          <button class="btn success" id="btnTestAPI">üîç Testar API</button>
          <button class="btn" id="btnSaveAPIConfig">üíæ Salvar Config</button>
        </div>

        <div class="api-info">
          <strong>Provedor Ativo:</strong> <span id="activeProvider">Alpha Vantage</span><br>
          <strong>Status:</strong> <span id="connectionStatus">Desconectado</span><br>
          <strong>√öltima Atualiza√ß√£o:</strong> <span id="lastUpdate">Nunca</span><br>
          <strong>Dados Dispon√≠veis:</strong> <span id="dataCount">0</span> registros
        </div>

        <div class="sep"></div>

        <!-- Manual Data Input -->
        <h3 style="font-size: 14px; margin-bottom: 8px;">Dados Manuais (Backup)</h3>
        <div class="hint">Cole abaixo fechamentos (um por linha) se quiser testar manualmente:</div>
        <textarea id="manualData" rows="6" style="width:100%;margin-top:8px;" placeholder="5500.00&#10;5510.25&#10;5505.80&#10;..."></textarea>
        <div class="toolbar" style="margin-top:10px">
          <button class="btn" id="btnLoadManual">Carregar Fechamentos</button>
          <button class="btn" id="btnClear">Limpar</button>
        </div>

        <div class="sep"></div>
        
        <!-- Excel Import -->
        <div class="hint">Importar Fechamentos do Excel:</div>
        <div style="font-size:11px;color:var(--muted);margin:4px 0;">
          Aceita formatos: <br>
          ‚Ä¢ Coluna √∫nica com pre√ßos (A1: 5437, A2: 5485.5...)<br>
          ‚Ä¢ Planilha completa (detecta coluna "Fechamento" automaticamente)
        </div>
        <input type="file" id="fileUpload" accept=".xlsx,.xls" />

        <div class="sep"></div>
        <div class="hint">Status:</div>
        <div class="muted" id="log">Pronto para uso - Configure uma API para dados em tempo real</div>
      </aside>
    </div>
  </main>

  <footer>Deivitti Almir - G√™nesis Trading</footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
    class TradingSystemWithAI {
      constructor() {
        this.priceData = [];
        this.linearReturns = [];
        this.currentForecastP = 9;
        this.currentIntradayP = 9;
        this.apiConfig = {
          provider: 'alpha_vantage',
          apiKey: '',
          symbol: 'USDBRL=X',
          interval: '1d'
        };
        this.apiConnected = false;
        this.aiAnalysis = null;
        
        this.initUserSession();
        this.init();
      }
      
      initUserSession() {
        try {
          const userData = sessionStorage.getItem('currentUser');
          if (userData) {
            const user = JSON.parse(userData);
            const userNameElement = document.getElementById('userName');
            if (userNameElement) {
              userNameElement.textContent = user.name || 'Usu√°rio';
            }
            
            if (user.system !== 'garch') {
              console.warn('Usu√°rio n√£o tem acesso ao sistema GARCH');
              if (user.system === 'quant') {
                this.log('‚ö†Ô∏è Redirecionando para Sistema QUANT...');
                setTimeout(() => {
                  window.location.href = 'dashboard-quant.html';
                }, 2000);
              }
            }
            
            console.log('Usu√°rio logado:', user.name, 'Sistema:', user.system);
            this.log(`‚úÖ Bem-vindo, ${user.name}! Sistema GARCH com IA inicializado.`);
            
          } else {
            console.warn('Nenhum usu√°rio logado encontrado');
            this.log('‚ö†Ô∏è Sess√£o n√£o encontrada. Redirecionando...');
            setTimeout(() => {
              window.location.href = 'index.html';
            }, 3000);
          }
        } catch (error) {
          console.error('Erro ao carregar dados do usu√°rio:', error);
          this.log('‚ùå Erro ao carregar sess√£o. Redirecionando...');
          setTimeout(() => {
            window.location.href = 'index.html';
          }, 3000);
        }
      }
      
      checkSessionValidity() {
        try {
          const userData = sessionStorage.getItem('currentUser');
          if (userData) {
            const user = JSON.parse(userData);
            const loginTime = user.loginTime || 0;
            const sessionTimeout = 4 * 60 * 60 * 1000;
            
            if (Date.now() - loginTime > sessionTimeout) {
              alert('Sua sess√£o expirou. Fa√ßa login novamente.');
              sessionStorage.removeItem('currentUser');
              window.location.href = 'index.html';
              return false;
            }
          } else {
            this.log('‚ö†Ô∏è Sess√£o perdida. Redirecionando para login...');
            setTimeout(() => {
              window.location.href = 'index.html';
            }, 2000);
            return false;
          }
          return true;
        } catch (error) {
          console.error('Erro ao verificar sess√£o:', error);
          return false;
        }
      }
      
      init() {
        this.loadAPIConfig();
        this.wireEventListeners();
        this.wireExpInputs();
        this.updateAPIInfo();
        this.updateDataTypeUI();
        this.initializeAI();
        
        setInterval(() => {
          this.checkSessionValidity();
        }, 5 * 60 * 1000);
      }
      
      // ========================================
      // NOVAS FUN√á√ïES DE IA AVAN√áADA
      // ========================================
      
      // 1. SCORE DE CONFIAN√áA MULTIDIMENSIONAL
      calculateAdvancedConfidenceScore() {
        let totalScore = 0;
        let totalWeight = 0;
        
        // Componente GARCH (peso 30)
        const garchScore = this.calculateGARCHConfidenceComponent();
        totalScore += garchScore * 30;
        totalWeight += 30;
        
        // Componente Pre√ßo Justo (peso 25)
        const fairPriceScore = this.calculateFairPriceConfidenceComponent();
        totalScore += fairPriceScore * 25;
        totalWeight += 25;
        
        // Componente Volatilidade (peso 20)
        const volScore = this.calculateVolatilityConfidenceComponent();
        totalScore += volScore * 20;
        totalWeight += 20;
        
        // Componente Momentum (peso 15)
        const momentumScore = this.calculateMomentumConfidenceComponent();
        totalScore += momentumScore * 15;
        totalWeight += 15;
        
        // Componente Conflu√™ncia (peso 10)
        const confluenceScore = this.calculateConfluenceComponent();
        totalScore += confluenceScore * 10;
        totalWeight += 10;
        
        return Math.round(totalScore / totalWeight);
      }
      
      calculateGARCHConfidenceComponent() {
        const periods = [9, 18, 27];
        let consistency = 0;
        let validPeriods = 0;
        
        const currentPrice = this.lastClose();
        if (!isFinite(currentPrice)) return 30;
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          if (!isFinite(stdDev)) return;
          
          validPeriods++;
          const up1sigma = currentPrice * (1 + stdDev);
          const down1sigma = currentPrice * (1 - stdDev);
          
          // Maior pontua√ß√£o quando pre√ßo est√° pr√≥ximo das bandas
          if (currentPrice > up1sigma || currentPrice < down1sigma) {
            consistency += 80;
          } else {
            const distanceFromBands = Math.min(
              Math.abs(currentPrice - up1sigma) / currentPrice,
              Math.abs(currentPrice - down1sigma) / currentPrice
            );
            consistency += Math.max(20, 80 - (distanceFromBands * 1000));
          }
        });
        
        return validPeriods > 0 ? consistency / validPeriods : 30;
      }
      
      calculateFairPriceConfidenceComponent() {
        const fairAnalysis = this.analyzeSystemFairPrice();
        if (!fairAnalysis.valid) return 30;
        
        const deviation = fairAnalysis.deviationAbs;
        
        // Quanto maior o desvio, maior a confian√ßa na dire√ß√£o
        if (deviation > 10) return 95;
        if (deviation > 8) return 85;
        if (deviation > 5) return 70;
        if (deviation > 3) return 50;
        if (deviation > 1) return 35;
        return 20;
      }
      
      calculateVolatilityConfidenceComponent() {
        const vol18 = this.calculateStdDevReturns(18) * 100;
        if (!isFinite(vol18)) return 50;
        
        // Volatilidade ideal entre 1.5% e 2.5%
        if (vol18 >= 1.5 && vol18 <= 2.5) return 90;
        if (vol18 < 1.0) return 60; // Muito baixa
        if (vol18 > 4.0) return 20; // Muito alta
        if (vol18 > 3.0) return 40;
        return 70;
      }
      
      calculateMomentumConfidenceComponent() {
        const mom9 = this.calculateMomentum(9);
        const mom18 = this.calculateMomentum(18);
        const mom27 = this.calculateMomentum(27);
        
        if (!isFinite(mom9) || !isFinite(mom18) || !isFinite(mom27)) return 40;
        
        // Momentum consistente em todas as janelas = alta confian√ßa
        if ((mom9 > 0 && mom18 > 0 && mom27 > 0) || 
            (mom9 < 0 && mom18 < 0 && mom27 < 0)) {
          return 85;
        }
        
        // Diverg√™ncias = menor confian√ßa
        const directions = [mom9 > 0, mom18 > 0, mom27 > 0];
        const consistent = directions.filter(d => d === directions[0]).length;
        
        return Math.max(25, consistent * 30);
      }
      
      calculateMomentum(periods) {
        if (this.priceData.length < periods + 1) return NaN;
        
        const recent = this.priceData.slice(-periods);
        const older = this.priceData.slice(-(periods * 2), -periods);
        
        if (recent.length === 0 || older.length === 0) return NaN;
        
        const recentAvg = recent.reduce((sum, p) => sum + p, 0) / recent.length;
        const olderAvg = older.reduce((sum, p) => sum + p, 0) / older.length;
        
        return ((recentAvg - olderAvg) / olderAvg) * 100;
      }
      
      calculateConfluenceComponent() {
        const garchAnalysis = this.analyzeSystemGARCH();
        const fairAnalysis = this.analyzeSystemFairPrice();
        
        if (!fairAnalysis.valid || !garchAnalysis.p18) return 50;
        
        const currentPrice = this.lastClose();
        const fairPrice = fairAnalysis.fairPriceCombined;
        const garch18 = garchAnalysis.p18;
        
        let confluenceScore = 50;
        
        // Conflu√™ncia: pre√ßo alto + acima GARCH + acima justo
        if (currentPrice > fairPrice && currentPrice > garch18.up1sigma) {
          confluenceScore = 90;
        }
        // Conflu√™ncia: pre√ßo baixo + abaixo GARCH + abaixo justo  
        else if (currentPrice < fairPrice && currentPrice < garch18.down1sigma) {
          confluenceScore = 90;
        }
        // Diverg√™ncia: sinais conflitantes
        else if ((currentPrice > fairPrice && currentPrice < garch18.down1sigma) ||
                 (currentPrice < fairPrice && currentPrice > garch18.up1sigma)) {
          confluenceScore = 25;
        }
        
        return confluenceScore;
      }
      
      // 2. DETEC√á√ÉO DE REGIME DE MERCADO
      detectMarketRegime() {
        const fairAnalysis = this.analyzeSystemFairPrice();
        const volAnalysis = this.analyzeSystemVolatility();
        const garchAnalysis = this.analyzeSystemGARCH();
        
        if (!fairAnalysis.valid || !volAnalysis.p18 || !garchAnalysis.p18) {
          return {
            type: 'UNDEFINED',
            confidence: 'LOW',
            description: 'Dados insuficientes para determinar regime',
            probability: 50
          };
        }
        
        const deviation = fairAnalysis.deviationPercent;
        const vol18 = volAnalysis.p18.volatilityPercent;
        const currentPrice = this.lastClose();
        const garch18 = garchAnalysis.p18;
        
        // Regime de REVERS√ÉO √Ä M√âDIA
        if (Math.abs(deviation) > 6 && vol18 < 3.0) {
          const direction = deviation > 0 ? 'BAIXISTA' : 'ALTISTA';
          const probability = Math.min(85, Math.abs(deviation) * 8 + (3.0 - vol18) * 10);
          
          return {
            type: 'MEAN_REVERSION',
            direction: direction,
            confidence: 'HIGH',
            description: `Revers√£o √† m√©dia ${direction.toLowerCase()} detectada. Desvio ${Math.abs(deviation).toFixed(1)}% com volatilidade controlada (${vol18.toFixed(2)}%).`,
            probability: Math.round(probability),
            expectedDuration: '2-5 preg√µes'
          };
        }
        
        // Regime de ALTA VOLATILIDADE
        if (vol18 > 4.0) {
          return {
            type: 'HIGH_VOLATILITY',
            confidence: 'HIGH',
            description: `Volatilidade extrema (${vol18.toFixed(2)}%). Mercado imprevis√≠vel, evitar trades direcionais.`,
            probability: 75,
            expectedDuration: 'Indefinido - aguardar normaliza√ß√£o'
          };
        }
        
        // Regime de BREAKOUT
        if (garch18 && ((currentPrice > garch18.up2sigma) || (currentPrice < garch18.down2sigma))) {
          const direction = currentPrice > garch18.up2sigma ? 'ALTISTA' : 'BAIXISTA';
          return {
            type: 'BREAKOUT',
            direction: direction,
            confidence: 'MEDIUM',
            description: `Poss√≠vel breakout ${direction.toLowerCase()}. Pre√ßo al√©m de ¬±2œÉ GARCH.`,
            probability: 65,
            expectedDuration: '1-3 preg√µes'
          };
        }
        
        // Regime LATERAL
        return {
          type: 'LATERAL',
          confidence: 'MEDIUM', 
          description: `Mercado em equil√≠brio. Desvio: ${Math.abs(deviation).toFixed(1)}%, Vol: ${vol18.toFixed(2)}%.`,
          probability: 60,
          expectedDuration: 'Aguardar catalisador'
        };
      }
      
      // 3. ALERTAS CONTEXTUALIZADOS E HIERARQUIZADOS
      generateAdvancedAlerts() {
        const alerts = [];
        const regime = this.detectMarketRegime();
        const fairAnalysis = this.analyzeSystemFairPrice();
        const garchAnalysis = this.analyzeSystemGARCH();
        const volAnalysis = this.analyzeSystemVolatility();
        const confluence = this.calculateConfluenceComponent();
        
        // ALERTAS CR√çTICOS (A√ß√£o imediata)
        if (regime.type === 'MEAN_REVERSION' && regime.confidence === 'HIGH' && confluence > 80) {
          alerts.push({
            level: 'CRITICAL',
            type: 'success',
            icon: 'üö®',
            title: 'OPORTUNIDADE DE ALTA PROBABILIDADE',
            message: `${regime.description} Conflu√™ncia t√©cnica: ${confluence}%. A√á√ÉO RECOMENDADA: ${regime.direction === 'BAIXISTA' ? 'VENDA' : 'COMPRA'} direcional.`,
            action: 'Considerar entrada imediata',
            confidence: regime.probability
          });
        }
        
        if (volAnalysis.p18 && volAnalysis.p18.volatilityPercent > 4.5) {
          alerts.push({
            level: 'CRITICAL',
            type: 'warning',
            icon: '‚ö†Ô∏è',
            title: 'VOLATILIDADE EXTREMA',
            message: `Volatilidade em ${volAnalysis.p18.volatilityPercent.toFixed(2)}% - ZONA PERIGOSA. Evitar novas posi√ß√µes at√© normaliza√ß√£o.`,
            action: 'Reduzir exposi√ß√£o imediatamente',
            confidence: 90
          });
        }
        
        // ALERTAS IMPORTANTES (Aten√ß√£o redobrada)
        if (garchAnalysis.p18) {
          const currentPrice = this.lastClose();
          if (currentPrice > garchAnalysis.p18.up2sigma) {
            alerts.push({
              level: 'IMPORTANT',
              type: 'warning',
              icon: 'üìà',
              title: 'SOBRECOMPRA ESTAT√çSTICA',
              message: `Pre√ßo ${((currentPrice/garchAnalysis.p18.up2sigma - 1) * 100).toFixed(1)}% acima de +2œÉ GARCH (${this.fmt(garchAnalysis.p18.up2sigma)}). Press√£o de venda esperada.`,
              action: 'Monitorar revers√£o',
              confidence: 70
            });
          } else if (currentPrice < garchAnalysis.p18.down2sigma) {
            alerts.push({
              level: 'IMPORTANT', 
              type: 'info',
              icon: 'üìâ',
              title: 'SOBREVENDA ESTAT√çSTICA',
              message: `Pre√ßo ${((1 - currentPrice/garchAnalysis.p18.down2sigma) * 100).toFixed(1)}% abaixo de -2œÉ GARCH (${this.fmt(garchAnalysis.p18.down2sigma)}). Press√£o de compra esperada.`,
              action: 'Monitorar recupera√ß√£o',
              confidence: 70
            });
          }
        }
        
        if (fairAnalysis.valid && fairAnalysis.deviationAbs > 8) {
          alerts.push({
            level: 'IMPORTANT',
            type: fairAnalysis.deviationPercent > 0 ? 'warning' : 'info',
            icon: fairAnalysis.deviationPercent > 0 ? 'üí∞' : 'üî•',
            title: fairAnalysis.deviationPercent > 0 ? 'SOBREVALORIZA√á√ÉO SEVERA' : 'SUBVALORIZA√á√ÉO SEVERA',
            message: `Desvio de ${fairAnalysis.deviationAbs.toFixed(1)}% do pre√ßo just√≠ssimo (${this.fmt(fairAnalysis.fairPriceCombined)}). ${fairAnalysis.severityLevel} probabilidade de revers√£o.`,
            action: `Preparar ${fairAnalysis.deviationPercent > 0 ? 'venda' : 'compra'}`,
            confidence: Math.min(85, fairAnalysis.deviationAbs * 8)
          });
        }
        
        // ALERTAS INFORMATIVOS
        if (confluence > 75) {
          alerts.push({
            level: 'INFO',
            type: 'success',
            icon: '‚úÖ',
            title: 'CONFLU√äNCIA T√âCNICA FORTE',
            message: `M√∫ltiplos indicadores apontam mesma dire√ß√£o (${confluence}% conflu√™ncia). Sinal consistente.`,
            action: 'Considerar aumento de posi√ß√£o',
            confidence: confluence
          });
        } else if (confluence < 40) {
          alerts.push({
            level: 'INFO',
            type: 'info',
            icon: 'ü§î',
            title: 'SINAIS CONFLITANTES',
            message: `Indicadores divergindo (${confluence}% conflu√™ncia). Aguardar defini√ß√£o de dire√ß√£o.`,
            action: 'Aguardar confirma√ß√£o',
            confidence: 100 - confluence
          });
        }
        
        // Ordenar por prioridade
        const priority = { 'CRITICAL': 3, 'IMPORTANT': 2, 'INFO': 1 };
        alerts.sort((a, b) => priority[b.level] - priority[a.level] || b.confidence - a.confidence);
        
        return alerts.slice(0, 5); // M√°ximo 5 alertas
      }
      
      // 4. ESTRAT√âGIA OPERACIONAL ESPEC√çFICA
      generateTradingStrategy() {
        const regime = this.detectMarketRegime();
        const fairAnalysis = this.analyzeSystemFairPrice();
        const garchAnalysis = this.analyzeSystemGARCH();
        const intradayAnalysis = this.analyzeSystemIntraday();
        const confidence = this.calculateAdvancedConfidenceScore();
        
        if (!fairAnalysis.valid || !garchAnalysis.p18 || !intradayAnalysis.p18) {
          return {
            recommendation: 'AGUARDAR',
            reason: 'Dados insuficientes para estrat√©gia operacional',
            confidence: 30
          };
        }
        
        const currentPrice = this.lastClose();
        const garch18 = garchAnalysis.p18;
        const intraday18 = intradayAnalysis.p18;
        const vol18 = this.analyzeSystemVolatility().p18?.volatilityPercent || 2.0;
        
        let strategy = {
          recommendation: 'MONITORAR',
          direction: null,
          entryZone: { min: 0, max: 0 },
          target: 0,
          stopLoss: 0,
          positionSize: 'NORMAL',
          timeframe: '1-3 preg√µes',
          confidence: confidence,
          riskReward: 0
        };
        
        // ESTRAT√âGIA PARA REVERS√ÉO √Ä M√âDIA
        if (regime.type === 'MEAN_REVERSION' && confidence > 70) {
          if (regime.direction === 'BAIXISTA') {
            // Entrada de VENDA
            strategy.recommendation = 'VENDA DIRECIONAL';
            strategy.direction = 'SELL';
            strategy.entryZone = { 
              min: Math.max(currentPrice * 0.998, garch18.up1sigma * 0.999),
              max: Math.min(currentPrice * 1.005, garch18.up2sigma)
            };
            strategy.target = Math.max(
              fairAnalysis.fairPriceCombined * 1.02,
              intraday18.minIntraday * 1.01
            );
            strategy.stopLoss = Math.min(
              currentPrice * 1.015,
              garch18.up2sigma * 1.005
            );
            
          } else {
            // Entrada de COMPRA
            strategy.recommendation = 'COMPRA DIRECIONAL';
            strategy.direction = 'BUY';
            strategy.entryZone = {
              min: Math.max(currentPrice * 0.995, garch18.down2sigma),
              max: Math.min(currentPrice * 1.002, garch18.down1sigma * 1.001)
            };
            strategy.target = Math.min(
              fairAnalysis.fairPriceCombined * 0.98,
              intraday18.maxIntraday * 0.99
            );
            strategy.stopLoss = Math.max(
              currentPrice * 0.985,
              garch18.down2sigma * 0.995
            );
          }
          
          strategy.timeframe = '2-5 preg√µes';
        }
        
        // AJUSTE DE TAMANHO DE POSI√á√ÉO BASEADO EM VOLATILIDADE
        if (vol18 > 3.0) {
          strategy.positionSize = 'REDUZIDA (50-70%)';
        } else if (vol18 < 1.5 && confidence > 80) {
          strategy.positionSize = 'AUMENTADA (120-150%)';
        } else if (confidence > 85) {
          strategy.positionSize = 'NORMAL+ (110%)';
        }
        
        // C√ÅLCULO RISK/REWARD
        if (strategy.target > 0 && strategy.stopLoss > 0 && currentPrice > 0) {
          const potentialGain = Math.abs(strategy.target - currentPrice) / currentPrice;
          const potentialLoss = Math.abs(strategy.stopLoss - currentPrice) / currentPrice;
          strategy.riskReward = potentialLoss > 0 ? potentialGain / potentialLoss : 0;
        }
        
        return strategy;
      }
		renderStrategyPanel() {
		const strategy = this.generateTradingStrategy();
		const operationDiv = document.getElementById("aiOperation");
		const riskDiv = document.getElementById("aiRisk");
		const levelsDiv = document.getElementById("aiLevels");

		if (!operationDiv || !riskDiv || !levelsDiv) return;

  // 1. Opera√ß√£o sugerida
  operationDiv.innerHTML = `
    <strong>OPERA√á√ÉO SUGERIDA</strong><br>
    ${strategy.recommendation}<br>
    <em>Entrada: ${strategy.entryZone.min.toFixed(2)} ‚Äì ${strategy.entryZone.max.toFixed(2)}</em><br>
    üéØ Meta: ${strategy.target.toFixed(2)}<br>
    üõë Stop Loss: ${strategy.stopLoss.toFixed(2)}<br>
    ‚è≥ Prazo: ${strategy.timeframe}<br>
    üìä Confian√ßa: ${strategy.confidence}%
  `;

  // 2. Gest√£o de Risco
  riskDiv.innerHTML = `
    <strong>GEST√ÉO DE RISCO</strong><br>
    Cen√°rio adverso: rompimento pode levar a ${ (strategy.stopLoss * 1.01).toFixed(2) }<br>
    Gatilho de sa√≠da: Volatilidade > 3.5% ou perda de conflu√™ncia<br>
    Hedge sugerido: Put protection se exposi√ß√£o > R$ 100k
  `;

  // 3. Suporte e Resist√™ncia
  const garch = this.analyzeSystemGARCH();
  if (garch.p18) {
    levelsDiv.innerHTML = `
      <strong>N√çVEIS DE DECIS√ÉO</strong><br>
      Resist√™ncia forte: ${garch.p18.up1sigma.toFixed(2)}<br>
      Suporte forte: ${garch.p18.down1sigma.toFixed(2)}
    `;
  }
}

      
      // FUN√á√ïES AUXILIARES PARA AS MELHORIAS
      determineSignalTypeFromStrategy(strategy) {
        if (strategy.recommendation.includes('VENDA')) return 'sell';
        if (strategy.recommendation.includes('COMPRA')) return 'buy';
        if (strategy.recommendation.includes('AGUARDAR')) return 'wait';
        return 'neutral';
      }
      
      adjustScenariosForRegime(baseScenarios, regime) {
        let scenarios = { ...baseScenarios };
        
        if (regime.type === 'MEAN_REVERSION') {
          if (regime.direction === 'BAIXISTA') {
            scenarios.strongDown = Math.min(40, scenarios.strongDown + 20);
            scenarios.moderateDown = Math.min(35, scenarios.moderateDown + 15);
            scenarios.strongUp = Math.max(5, scenarios.strongUp - 15);
            scenarios.lateral = Math.max(10, scenarios.lateral - 20);
          } else if (regime.direction === 'ALTISTA') {
            scenarios.strongUp = Math.min(40, scenarios.strongUp + 20);
            scenarios.moderateUp = Math.min(35, scenarios.moderateUp + 15);
            scenarios.strongDown = Math.max(5, scenarios.strongDown - 15);
            scenarios.lateral = Math.max(10, scenarios.lateral - 20);
          }
        } else if (regime.type === 'HIGH_VOLATILITY') {
          scenarios.lateral = Math.max(50, scenarios.lateral + 20);
          scenarios.strongUp = Math.max(5, scenarios.strongUp - 10);
          scenarios.strongDown = Math.max(5, scenarios.strongDown - 10);
        }
        
        return scenarios;
      }
      
      generateEnhancedNarrativeWithRegime(regime, strategy, confidence) {
        const currentPrice = this.lastClose();
        const fairAnalysis = this.analyzeSystemFairPrice();
        
        return `
          <h4>AN√ÅLISE GARCH-IA AVAN√áADA - ${new Date().toLocaleDateString('pt-BR')}</h4>
          
          <p><strong>REGIME IDENTIFICADO: ${regime.type}</strong><br>
          ${regime.description} Probabilidade: ${regime.probability}%</p>
          
          <p><strong>ESTRAT√âGIA OPERACIONAL:</strong><br>
          ${strategy.recommendation} | Confian√ßa Multidimensional: ${confidence}%<br>
          ${strategy.direction ? `Zona de Entrada: ${this.fmt(strategy.entryZone.min)} - ${this.fmt(strategy.entryZone.max)}` : ''}<br>
          ${strategy.target > 0 ? `Meta Prim√°ria: ${this.fmt(strategy.target)} | Stop Loss: ${this.fmt(strategy.stopLoss)}` : ''}<br>
          ${strategy.riskReward > 0 ? `Risk/Reward: 1:${strategy.riskReward.toFixed(1)} | Tamanho: ${strategy.positionSize}` : ''}</p>
          
          <p><strong>CONFLU√äNCIA T√âCNICA:</strong><br>
          Pre√ßoJusto: ${fairAnalysis.valid ? this.fmt(fairAnalysis.fairPriceCombined) : 'N/D'} | 
          Desvio: ${fairAnalysis.valid ? fairAnalysis.deviationPercent.toFixed(1) + '%' : 'N/D'}<br>
          Conflu√™ncia: ${this.calculateConfluenceComponent()}% | 
          Timeframe: ${strategy.timeframe}</p>
          
          <p><strong>GEST√ÉO DE RISCO:</strong><br>
          ${confidence > 80 ? '‚úÖ ALTA confian√ßa - Opera√ß√£o recomendada' : 
            confidence > 60 ? '‚ö†Ô∏è M√âDIA confian√ßa - Aguardar confirma√ß√£o' : 
            '‚ùå BAIXA confian√ßa - Evitar trades direcionais'}</p>
        `;
      }
      
      updateAdvancedMetricsDisplay() {
        if (!this.aiAnalysis) {
          document.getElementById('advancedConfidenceDisplay').textContent = '--';
          document.getElementById('marketRegimeDisplay').textContent = '--';
          document.getElementById('confluenceDisplay').textContent = '--';
          document.getElementById('riskRewardDisplay').textContent = '--';
          return;
        }
        
        // Atualizar displays das m√©tricas avan√ßadas
        const advancedConfidence = this.calculateAdvancedConfidenceScore();
        const regime = this.detectMarketRegime();
        const confluence = this.calculateConfluenceComponent();
        const strategy = this.generateTradingStrategy();
        
        document.getElementById('advancedConfidenceDisplay').textContent = advancedConfidence + '%';
        document.getElementById('marketRegimeDisplay').textContent = regime.type;
        document.getElementById('confluenceDisplay').textContent = confluence + '%';
        document.getElementById('riskRewardDisplay').textContent = strategy.riskReward > 0 ? 
          '1:' + strategy.riskReward.toFixed(1) : '--';
      }
      
      // ========================================
      // FIM DAS NOVAS FUN√á√ïES DE IA AVAN√áADA  
      // ========================================
      
      // Fun√ß√£o para determinar o tipo de sinal baseado na recomenda√ß√£o
      determineSignalType(recommendation) {
        if (!recommendation || typeof recommendation !== 'string') {
          return 'neutral';
        }
        
        const recText = recommendation.toLowerCase();
        
        // Sinais de COMPRA (Verde)
        if (recText.includes('compra') || 
            recText.includes('comprar') ||
            recText.includes('subvalorizada') ||
            recText.includes('aten√ß√£o para compras') ||
            recText.includes('forte recomenda√ß√£o de compra') ||
            recText.includes('recomenda√ß√£o de compra') ||
            recText.includes('oportunidade de compra')) {
          return 'buy';
        }
        
        // Sinais de VENDA (Vermelho)
        if (recText.includes('venda') || 
            recText.includes('vender') ||
            recText.includes('sobrevalorizada') ||
            recText.includes('aten√ß√£o para vendas') ||
            recText.includes('forte recomenda√ß√£o de venda') ||
            recText.includes('recomenda√ß√£o de venda') ||
            recText.includes('oportunidade de venda')) {
          return 'sell';
        }
        
        // Sinais de AGUARDAR (Laranja)
        if (recText.includes('aguardar') || 
            recText.includes('aguarde') ||
            recText.includes('volatilidade extrema') ||
            recText.includes('evitar trades') ||
            recText.includes('aguardar redu√ß√£o') ||
            recText.includes('aguardar normaliza√ß√£o')) {
          return 'wait';
        }
        
        // Neutro/Monitorar (Azul) - padr√£o
        return 'neutral';
      }
      
      // Fun√ß√£o para atualizar a cor do c√≠rculo de score
      updateScoreCircleColor(signalType) {
        const scoreCircle = document.querySelector('.score-circle');
        if (!scoreCircle) {
          console.warn('Score circle element not found');
          return;
        }
        
        // Remove todas as classes de cor existentes
        scoreCircle.classList.remove('buy-signal', 'sell-signal', 'neutral-signal', 'wait-signal');
        
        // Adiciona a classe apropriada baseada no sinal
        switch(signalType) {
          case 'buy':
            scoreCircle.classList.add('buy-signal');
            console.log('Score circle: BUY signal (green)');
            break;
          case 'sell':
            scoreCircle.classList.add('sell-signal');
            console.log('Score circle: SELL signal (red)');
            break;
          case 'wait':
            scoreCircle.classList.add('wait-signal');
            console.log('Score circle: WAIT signal (orange)');
            break;
          case 'neutral':
          default:
            scoreCircle.classList.add('neutral-signal');
            console.log('Score circle: NEUTRAL signal (blue)');
            break;
        }
      }
      
      initializeAI() {
        // Initialize AI analysis display
        this.updateAIDisplay();
      }
      
      wireEventListeners() {
        document.getElementById('btnFetch').addEventListener('click', () => this.fetchSimulatedData());
        document.getElementById('btnFetchAPI').addEventListener('click', () => this.fetchAPIData());
        document.getElementById('btnAnalyze').addEventListener('click', () => this.analyze());
		document.getElementById('btnAIAnalysis').addEventListener('click', () => {
			this.performAIAnalysis();
			this.renderStrategyPanel();
		});        
		document.getElementById('btnLoadManual').addEventListener('click', () => this.loadManualData());
        document.getElementById('btnClear').addEventListener('click', () => this.clearData());
        document.getElementById('logoutBtn').addEventListener('click', () => this.logout());
        
        document.getElementById('btnTestAPI').addEventListener('click', () => this.testAPIConnection());
        document.getElementById('btnSaveAPIConfig').addEventListener('click', () => this.saveAPIConfig());
        
        document.querySelectorAll('.provider-card').forEach(card => {
          card.addEventListener('click', () => {
            const provider = card.dataset.provider;
            this.selectProvider(provider);
          });
        });
        
        document.querySelectorAll('#forecastTabs .tab').forEach(tab => {
          tab.addEventListener('click', () => {
            const period = parseInt(tab.dataset.period);
            this.switchForecastPeriod(period);
          });
        });
        
        document.querySelectorAll('#intradayTabs .tab').forEach(tab => {
          tab.addEventListener('click', () => {
            const period = parseInt(tab.dataset.iperiod);
            this.switchIntradayPeriod(period);
          });
        });
        
        document.getElementById('fileUpload').addEventListener('change', (e) => this.handleFileUpload(e));
        
        ['apiKey', 'symbol', 'interval'].forEach(id => {
          document.getElementById(id).addEventListener('input', () => {
            this.updateAPIConfigFromInputs();
          });
        });
      }
      
      wireExpInputs() {
        ['exp9', 'exp18', 'exp27', 'frp', 'maturityDays'].forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener('input', () => {
              this.calculateIntradayExtremes(this.currentIntradayP);
              this.updateExtras();
            });
          }
        });
        
        ['ppp_rate', 'inflation_br', 'inflation_us', 'selic_rate', 'fed_rate', 'risk_premium'].forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener('input', () => {
              this.calculateFairPrices();
            });
          }
        });
        
        const dataTypeSelect = document.getElementById('dataType');
        if (dataTypeSelect) {
          dataTypeSelect.addEventListener('change', () => {
            this.updateDataTypeUI();
            this.refreshAll();
          });
        }
      }
      
      // AI Analysis System - VERS√ÉO MELHORADA
      async performAIAnalysis() {
        if (!this.priceData.length) {
          this.log("Carregue dados primeiro para an√°lise com IA");
          return;
        }
        
        this.showLoading();
        this.log("Executando an√°lise inteligente multidimensional...");
        
        try {
          // Simulate AI processing time
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          // An√°lise original + melhorias
          this.aiAnalysis = this.generateAIAnalysis();
          
          // NOVA: Adicionar m√©tricas avan√ßadas
          this.aiAnalysis.advancedConfidence = this.calculateAdvancedConfidenceScore();
          this.aiAnalysis.marketRegime = this.detectMarketRegime();
          this.aiAnalysis.tradingStrategy = this.generateTradingStrategy();
          this.aiAnalysis.advancedAlerts = this.generateAdvancedAlerts();
          
          this.updateAIDisplay();
          
          this.log(`‚úÖ An√°lise IA avan√ßada conclu√≠da! Regime: ${this.aiAnalysis.marketRegime.type} | Confian√ßa: ${this.aiAnalysis.advancedConfidence}%`);
          
        } catch (error) {
          this.log("‚ùå Erro na an√°lise IA: " + error.message);
        } finally {
          this.hideLoading();
        }
      }
      
      // VERS√ÉO MELHORADA da fun√ß√£o updateAIDisplay()
      updateAIDisplay() {
        if (!this.aiAnalysis) {
          document.getElementById('aiCurrentSituation').textContent = "Execute 'An√°lise IA' para insights multidimensionais...";
          document.getElementById('aiMainRecommendation').textContent = "Aguardando an√°lise de regime de mercado...";
          document.getElementById('opportunityScore').textContent = "--";
          this.updateScoreCircleColor('neutral');
          this.updateAdvancedMetricsDisplay();
          return;
        }
        
        // Calcular m√©tricas avan√ßadas
        const advancedConfidence = this.calculateAdvancedConfidenceScore();
        const regime = this.detectMarketRegime();
        const advancedAlerts = this.generateAdvancedAlerts();
        const strategy = this.generateTradingStrategy();
        
        // Update main insights com dados mais ricos
        const enhancedSituation = `${this.aiAnalysis.currentSituation} | Regime: ${regime.type} (${regime.probability}%) | Confian√ßa: ${advancedConfidence}%`;
        document.getElementById('aiCurrentSituation').textContent = enhancedSituation;
        
        // Recomenda√ß√£o estrat√©gica melhorada
        let enhancedRecommendation = strategy.recommendation;
        if (strategy.direction) {
          enhancedRecommendation += ` | Entrada: ${this.fmt(strategy.entryZone.min)}-${this.fmt(strategy.entryZone.max)}`;
          enhancedRecommendation += ` | Meta: ${this.fmt(strategy.target)} | Stop: ${this.fmt(strategy.stopLoss)}`;
          enhancedRecommendation += ` | R/R: ${strategy.riskReward.toFixed(1)}x`;
        }
        document.getElementById('aiMainRecommendation').textContent = enhancedRecommendation;
        
        // Score com base na confian√ßa avan√ßada
        document.getElementById('opportunityScore').textContent = advancedConfidence;
        
        // Cor do c√≠rculo baseada na estrat√©gia
        const signalType = this.determineSignalTypeFromStrategy(strategy);
        this.updateScoreCircleColor(signalType);
        
        // Update alerts com sistema avan√ßado
        const alertsContainer = document.getElementById('aiAlerts');
        if (advancedAlerts && advancedAlerts.length > 0) {
          alertsContainer.innerHTML = '';
          advancedAlerts.forEach(alert => {
            const alertElement = document.createElement('div');
            alertElement.className = `alert-item ${alert.type}`;
            alertElement.innerHTML = `
              <strong>${alert.icon} ${alert.title}</strong>
              ${alert.message}
              <em>A√ß√£o: ${alert.action} (Confian√ßa: ${alert.confidence}%)</em>
            `;
            alertsContainer.appendChild(alertElement);
          });
          alertsContainer.style.display = 'grid';
        } else {
          alertsContainer.style.display = 'none';
        }
        
        // Update scenarios com probabilidades condicionais
        if (this.aiAnalysis.scenarios) {
          // Ajustar cen√°rios baseado no regime detectado
          const adjustedScenarios = this.adjustScenariosForRegime(this.aiAnalysis.scenarios, regime);
          
          const scenarios = document.querySelectorAll('#aiScenarios .scenario');
          const scenarioValues = [
            adjustedScenarios.strongUp,
            adjustedScenarios.moderateUp, 
            adjustedScenarios.lateral,
            adjustedScenarios.moderateDown,
            adjustedScenarios.strongDown
          ];
          
          scenarios.forEach((scenario, index) => {
            const barFill = scenario.querySelector('.bar-fill');
            const percentage = scenario.querySelector('.percentage');
            const value = scenarioValues[index] || 0;
            
            if (barFill && percentage) {
              barFill.style.width = `${value}%`;
              percentage.textContent = `${value}%`;
            }
          });
        }
        
        // Enhanced narrative com regime e estrat√©gia
        const narrativeContainer = document.getElementById('aiNarrative');
        if (narrativeContainer) {
          const enhancedNarrative = this.generateEnhancedNarrativeWithRegime(regime, strategy, advancedConfidence);
          narrativeContainer.innerHTML = enhancedNarrative;
          narrativeContainer.style.display = 'block';
        }
        
        // Atualizar m√©tricas avan√ßadas
        this.updateAdvancedMetricsDisplay();
      }
      
      // SUBSTITUA APENAS ESTAS FUN√á√ïES NO SEU SISTEMA ORIGINAL
      // Mantenha todo o resto igual, apenas cole estas fun√ß√µes sobre as existentes

      // Nova an√°lise de IA que usa os c√°lculos reais do seu sistema
      generateAIAnalysis() {
        const currentPrice = this.lastClose();
        const garchAnalysis = this.analyzeSystemGARCH();
        const intradayAnalysis = this.analyzeSystemIntraday();
        const fairPriceAnalysis = this.analyzeSystemFairPrice();
        const volatilityAnalysis = this.analyzeSystemVolatility();
        
        const analysis = {
          opportunityScore: this.calculateEnhancedOpportunityScore(garchAnalysis, fairPriceAnalysis, volatilityAnalysis),
          currentSituation: this.generateEnhancedSituation(currentPrice, garchAnalysis, fairPriceAnalysis),
          mainRecommendation: this.generateEnhancedRecommendation(garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis),
          alerts: this.generateEnhancedAlerts(garchAnalysis, fairPriceAnalysis, volatilityAnalysis),
          scenarios: this.calculateEnhancedScenarios(garchAnalysis, fairPriceAnalysis),
          narrative: this.generateEnhancedNarrative(currentPrice, garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis)
        };
        
        return analysis;
      }
      
      // An√°lise GARCH usando os c√°lculos reais do sistema
      analyzeSystemGARCH() {
        const currentPrice = this.lastClose();
        const periods = [9, 18, 27];
        const results = {};
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          if (isNaN(stdDev)) return;
          
          results[`p${period}`] = {
            stdDev: stdDev,
            stdDevPercent: stdDev * 100,
            up1sigma: currentPrice * (1 + stdDev),
            down1sigma: currentPrice * (1 - stdDev),
            up2sigma: currentPrice * (1 + 2 * stdDev),
            down2sigma: currentPrice * (1 - 2 * stdDev),
            currentInRange1: currentPrice >= (currentPrice * (1 - stdDev)) && currentPrice <= (currentPrice * (1 + stdDev)),
            distanceFromMean: Math.abs((currentPrice - currentPrice) / (currentPrice * stdDev))
          };
        });
        
        return results;
      }
      
      // An√°lise Intraday usando fatores EXP do sistema
      analyzeSystemIntraday() {
        const currentPrice = this.lastClose();
        const periods = [9, 18, 27];
        const results = {};
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          const expFactor = this.getExpFor(period);
          
          if (isNaN(stdDev)) return;
          
          const expStdDev = Math.pow(expFactor, stdDev);
          const maxIntraday = currentPrice * expStdDev;
          const minIntraday = currentPrice / expStdDev;
          
          results[`p${period}`] = {
            expFactor: expFactor,
            expStdDev: expStdDev,
            maxIntraday: maxIntraday,
            minIntraday: minIntraday,
            range: maxIntraday - minIntraday,
            rangePercent: ((maxIntraday - minIntraday) / currentPrice) * 100,
            potentialGain: ((maxIntraday - currentPrice) / currentPrice) * 100,
            potentialLoss: ((currentPrice - minIntraday) / currentPrice) * 100
          };
        });
        
        return results;
      }
      
      // An√°lise de Pre√ßo Justo usando f√≥rmulas PPP/UIP do sistema
      analyzeSystemFairPrice() {
        const currentPrice = this.lastClose();
        if (!isFinite(currentPrice) || currentPrice <= 0) {
          return { valid: false };
        }
        
        // Usar os valores dos inputs do sistema
        let pppRate = parseFloat(document.getElementById('ppp_rate')?.value || 5.30);
        const inflationBr = parseFloat(document.getElementById('inflation_br')?.value || 4.5) / 100;
        const inflationUs = parseFloat(document.getElementById('inflation_us')?.value || 3.2) / 100;
        const selicRate = parseFloat(document.getElementById('selic_rate')?.value || 13.75) / 100;
        const fedRate = parseFloat(document.getElementById('fed_rate')?.value || 5.50) / 100;
        const riskPremium = parseFloat(document.getElementById('risk_premium')?.value || 2.5) / 100;

        // Ajuste de escala (igual ao sistema original)
        if (currentPrice > 100) {
          pppRate = pppRate * 1000;
        }

        // C√°lculos PPP e UIP (igual ao sistema original)
        const inflationDifferential = inflationBr - inflationUs;
        const fairPricePPP = pppRate * ((1 + inflationBr) / (1 + inflationUs));

        const interestDifferential = selicRate - fedRate;
        const netInterestDifferential = interestDifferential - riskPremium;
        const uipAdjustmentFactor = 1 + (netInterestDifferential * 0.15);
        const fairPriceUIP = currentPrice * uipAdjustmentFactor;

        // Limites UIP (igual ao sistema original)
        const maxUIPDeviation = 0.20;
        const upperBoundUIP = currentPrice * (1 + maxUIPDeviation);
        const lowerBoundUIP = currentPrice * (1 - maxUIPDeviation);
        const boundedFairPriceUIP = Math.max(lowerBoundUIP, Math.min(upperBoundUIP, fairPriceUIP));

        // Pre√ßo combinado (igual ao sistema original)
        const weightPPP = 0.4;
        const weightUIP = 0.6;
        const fairPriceCombined = (fairPricePPP * weightPPP) + (boundedFairPriceUIP * weightUIP);

        // Limite total (igual ao sistema original)
        const maxTotalDeviation = 0.25;
        const upperBound = currentPrice * (1 + maxTotalDeviation);
        const lowerBound = currentPrice * (1 - maxTotalDeviation);
        const finalFairPrice = Math.max(lowerBound, Math.min(upperBound, fairPriceCombined));

        const deviationPercent = ((currentPrice - finalFairPrice) / finalFairPrice) * 100;
        
        return {
          valid: true,
          currentPrice: currentPrice,
          fairPricePPP: fairPricePPP,
          fairPriceUIP: boundedFairPriceUIP,
          fairPriceCombined: finalFairPrice,
          deviationPercent: deviationPercent,
          deviationAbs: Math.abs(deviationPercent),
          isOvervalued: deviationPercent > 5,
          isUndervalued: deviationPercent < -5,
          severityLevel: Math.abs(deviationPercent) > 10 ? 'EXTREMA' : 
                       Math.abs(deviationPercent) > 5 ? 'ALTA' : 'MODERADA',
          interestDifferential: interestDifferential,
          inflationDifferential: inflationDifferential,
          riskPremium: riskPremium
        };
      }
      
      // An√°lise de volatilidade por per√≠odo
      analyzeSystemVolatility() {
        const periods = [9, 18, 27];
        const results = {};
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          if (isNaN(stdDev)) return;
          
          const volPercent = stdDev * 100;
          let regime, riskLevel, tradingAdvice;
          
          if (volPercent > 3.0) {
            regime = 'ALTA';
            riskLevel = 'EXTREMO';
            tradingAdvice = 'Evitar trades direcionais';
          } else if (volPercent > 2.0) {
            regime = 'MODERADA-ALTA';
            riskLevel = 'ALTO';
            tradingAdvice = 'Reduzir tamanho de posi√ß√£o';
          } else if (volPercent > 1.0) {
            regime = 'MODERADA';
            riskLevel = 'M√âDIO';
            tradingAdvice = 'Condi√ß√µes normais de trading';
          } else {
            regime = 'BAIXA';
            riskLevel = 'BAIXO';
            tradingAdvice = 'Ideal para trades direcionais';
          }
          
          results[`p${period}`] = {
            period: period,
            volatilityPercent: volPercent,
            regime: regime,
            riskLevel: riskLevel,
            tradingAdvice: tradingAdvice,
            isLowVol: volPercent < 1.5,
            isHighVol: volPercent > 3.0
          };
        });
        
        return results;
      }
      
      // Score de oportunidade melhorado usando todos os c√°lculos do sistema
      calculateEnhancedOpportunityScore(garchAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        if (!fairPriceAnalysis.valid) return 30;
        
        let score = 50; // Base score
        
        // Componente: Desvio do pre√ßo justo (0-40 pontos)
        const deviation = fairPriceAnalysis.deviationAbs;
        const deviationScore = Math.min(40, deviation * 3);
        score += deviationScore;
        
        // Componente: Volatilidade (penaliza alta volatilidade)
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        if (vol18 < 1.5) {
          score += 15; // Baixa volatilidade √© boa
        } else if (vol18 > 3.0) {
          score -= 20; // Alta volatilidade penaliza
        }
        
        // Componente: Consist√™ncia entre per√≠odos GARCH
        const periods = [9, 18, 27];
        let consistentDirection = 0;
        const referencePrice = this.lastClose();
        
        periods.forEach(p => {
          const garch = garchAnalysis[`p${p}`];
          if (garch) {
            if (fairPriceAnalysis.deviationPercent > 5 && referencePrice > garch.up1sigma) {
              consistentDirection++; // Pre√ßo alto + acima de +1œÉ
            } else if (fairPriceAnalysis.deviationPercent < -5 && referencePrice < garch.down1sigma) {
              consistentDirection++; // Pre√ßo baixo + abaixo de -1œÉ
            }
          }
        });
        
        score += consistentDirection * 5;
        
        // Limitar entre 0-100
        return Math.max(0, Math.min(100, Math.round(score)));
      }
      
      // Situa√ß√£o atual melhorada
      generateEnhancedSituation(currentPrice, garchAnalysis, fairPriceAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return "Configure os par√¢metros de pre√ßo justo para an√°lise completa.";
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const garch18 = garchAnalysis.p18;
        
        let situation = `USD/BRL em ${this.fmt(currentPrice)}, `;
        
        // An√°lise de pre√ßo justo
        if (Math.abs(deviation) < 2) {
          situation += `pr√≥ximo ao just√≠ssimo (${this.fmt(fairPriceAnalysis.fairPriceCombined)}). `;
        } else if (deviation > 0) {
          situation += `${deviation.toFixed(1)}% ACIMA do just√≠ssimo (${this.fmt(fairPriceAnalysis.fairPriceCombined)}). `;
        } else {
          situation += `${Math.abs(deviation).toFixed(1)}% ABAIXO do just√≠ssimo (${this.fmt(fairPriceAnalysis.fairPriceCombined)}). `;
        }
        
        // An√°lise GARCH 18P
        if (garch18) {
          if (currentPrice > garch18.up1sigma) {
            situation += `Acima da banda +1œÉ GARCH (${this.fmt(garch18.up1sigma)}).`;
          } else if (currentPrice < garch18.down1sigma) {
            situation += `Abaixo da banda -1œÉ GARCH (${this.fmt(garch18.down1sigma)}).`;
          } else {
            situation += `Dentro das bandas GARCH ¬±1œÉ.`;
          }
        }
        
        return situation;
      }
      
      // Recomenda√ß√£o principal melhorada
      generateEnhancedRecommendation(garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return "Configure os par√¢metros do sistema para recomenda√ß√µes precisas.";
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        const garch18 = garchAnalysis.p18;
        const intraday18 = intradayAnalysis.p18;
        const currentPrice = this.lastClose();
        
        let recommendation = "";
        
        // L√≥gica principal baseada nos c√°lculos reais do sistema
        if (Math.abs(deviation) > 8 && vol18 < 2.5) {
          // Desvio extremo + baixa volatilidade = alta confian√ßa
          if (deviation > 8) {
            recommendation = `FORTE RECOMENDA√á√ÉO DE VENDA: Moeda ${deviation.toFixed(1)}% sobrevalorizada com volatilidade controlada (${vol18.toFixed(2)}%). `;
            
            if (garch18 && currentPrice > garch18.up1sigma) {
              recommendation += `GARCH confirma: pre√ßo acima de +1œÉ (${this.fmt(garch18.up1sigma)}). `;
            }
            
            if (intraday18) {
              recommendation += `Meta m√°xima intraday: ${this.fmt(intraday18.maxIntraday)}.`;
            }
          } else {
            recommendation = `FORTE RECOMENDA√á√ÉO DE COMPRA: Moeda ${Math.abs(deviation).toFixed(1)}% subvalorizada com volatilidade controlada (${vol18.toFixed(2)}%). `;
            
            if (garch18 && currentPrice < garch18.down1sigma) {
              recommendation += `GARCH confirma: pre√ßo abaixo de -1œÉ (${this.fmt(garch18.down1sigma)}). `;
            }
            
            if (intraday18) {
              recommendation += `Meta m√≠nima intraday: ${this.fmt(intraday18.minIntraday)}.`;
            }
          }
        } else if (Math.abs(deviation) > 5) {
          // Desvio moderado
          if (deviation > 5) {
            recommendation = `ATEN√á√ÉO PARA VENDAS: ${deviation.toFixed(1)}% sobrevalorizada. `;
          } else {
            recommendation = `ATEN√á√ÉO PARA COMPRAS: ${Math.abs(deviation).toFixed(1)}% subvalorizada. `;
          }
          
          if (vol18 > 3.0) {
            recommendation += `CUIDADO: Volatilidade alta (${vol18.toFixed(2)}%) pode causar falsos sinais. `;
          }
        } else if (vol18 > 4.0) {
          recommendation = `AGUARDAR: Volatilidade extrema (${vol18.toFixed(2)}%) domina. Aguardar normaliza√ß√£o. `;
        } else {
          recommendation = `MONITORAR: Situa√ß√£o equilibrada. Desvio: ${deviation.toFixed(1)}%, Vol: ${vol18.toFixed(2)}%. `;
          
          if (intraday18) {
            recommendation += `Range intraday esperado: ${this.fmt(intraday18.minIntraday)} - ${this.fmt(intraday18.maxIntraday)}.`;
          }
        }
        
        return recommendation;
      }
      
      // Alertas melhorados baseados nos c√°lculos do sistema
      generateEnhancedAlerts(garchAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        const alerts = [];
        
        if (!fairPriceAnalysis.valid) {
          alerts.push({
            type: 'info',
            message: 'Configure par√¢metros PPP/UIP para an√°lise completa do pre√ßo justo.'
          });
          return alerts;
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        const garch18 = garchAnalysis.p18;
        const currentPrice = this.lastClose();
        
        // Alertas de desvio extremo
        if (Math.abs(deviation) > 10) {
          alerts.push({
            type: 'warning',
            message: `DESVIO EXTREMO: ${Math.abs(deviation).toFixed(1)}% do pre√ßo just√≠ssimo! Revers√£o altamente prov√°vel.`
          });
        }
        
        // Alertas GARCH
        if (garch18) {
          if (currentPrice > garch18.up2sigma) {
            alerts.push({
              type: 'warning',
              message: `Pre√ßo acima de +2œÉ GARCH (${this.fmt(garch18.up2sigma)}). Zona de sobrecompra estat√≠stica.`
            });
          } else if (currentPrice < garch18.down2sigma) {
            alerts.push({
              type: 'warning',
              message: `Pre√ßo abaixo de -2œÉ GARCH (${this.fmt(garch18.down2sigma)}). Zona de sobrevenda estat√≠stica.`
            });
          }
        }
        
        // Alertas de volatilidade
        if (vol18 > 4.0) {
          alerts.push({
            type: 'warning',
            message: `VOLATILIDADE EXTREMA: ${vol18.toFixed(2)}%! Mercado imprevis√≠vel, evitar trades direcionais.`
          });
        } else if (vol18 < 1.0 && Math.abs(deviation) > 5) {
          alerts.push({
            type: 'success',
            message: `OPORTUNIDADE: Baixa volatilidade (${vol18.toFixed(2)}%) + desvio significativo = alta probabilidade de acerto.`
          });
        }
        
        // Alertas de conflu√™ncia
        if (Math.abs(deviation) > 5 && garch18) {
          const garchConfirms = (deviation > 0 && currentPrice > garch18.up1sigma) || 
                               (deviation < 0 && currentPrice < garch18.down1sigma);
          
          if (garchConfirms) {
            alerts.push({
              type: 'success',
              message: 'CONFLU√äNCIA: Pre√ßo justo e GARCH apontam mesma dire√ß√£o. Alta confiabilidade.'
            });
          } else {
            alerts.push({
              type: 'info',
              message: 'DIVERG√äNCIA: Pre√ßo justo e GARCH em conflito. Aguardar confirma√ß√£o.'
            });
          }
        }
        
        return alerts;
      }
      
      // Cen√°rios melhorados usando GARCH e pre√ßo justo
      calculateEnhancedScenarios(garchAnalysis, fairPriceAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return {
            strongUp: 20, moderateUp: 20, lateral: 20, moderateDown: 20, strongDown: 20
          };
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const garch18 = garchAnalysis.p18;
        
        // Base probabilities
        let scenarios = {
          strongUp: 15,    // >+2%
          moderateUp: 20,  // +1% to +2%
          lateral: 30,     // -1% to +1%
          moderateDown: 20, // -2% to -1%
          strongDown: 15   // <-2%
        };
        
        // Ajuste baseado no desvio do pre√ßo justo
        if (deviation > 8) {
          // Muito sobrevalorizado - alta probabilidade de queda
          scenarios.strongDown += 25;
          scenarios.moderateDown += 15;
          scenarios.strongUp -= 15;
          scenarios.moderateUp -= 10;
          scenarios.lateral -= 15;
        } else if (deviation > 5) {
          // Moderadamente sobrevalorizado
          scenarios.strongDown += 15;
          scenarios.moderateDown += 10;
          scenarios.strongUp -= 10;
          scenarios.lateral -= 15;
        } else if (deviation < -8) {
          // Muito subvalorizado - alta probabilidade de alta
          scenarios.strongUp += 25;
          scenarios.moderateUp += 15;
          scenarios.strongDown -= 15;
          scenarios.moderateDown -= 10;
          scenarios.lateral -= 15;
        } else if (deviation < -5) {
          // Moderadamente subvalorizado
          scenarios.strongUp += 15;
          scenarios.moderateUp += 10;
          scenarios.strongDown -= 10;
          scenarios.lateral -= 15;
        }
        
        // Ajuste baseado no GARCH
        if (garch18) {
          const currentPrice = this.lastClose();
          
          if (currentPrice > garch18.up1sigma) {
            // Acima de +1œÉ - maior probabilidade de corre√ß√£o
            scenarios.moderateDown += 10;
            scenarios.strongDown += 5;
            scenarios.strongUp -= 10;
            scenarios.lateral -= 5;
          } else if (currentPrice < garch18.down1sigma) {
            // Abaixo de -1œÉ - maior probabilidade de recupera√ß√£o
            scenarios.moderateUp += 10;
            scenarios.strongUp += 5;
            scenarios.strongDown -= 10;
            scenarios.lateral -= 5;
          }
        }
        
        // Normalizar para 100%
        const total = Object.values(scenarios).reduce((sum, val) => sum + val, 0);
        Object.keys(scenarios).forEach(key => {
          scenarios[key] = Math.max(5, Math.round((scenarios[key] / total) * 100));
        });
        
        return scenarios;
      }
      
      // Narrativa melhorada com todos os c√°lculos do sistema
      generateEnhancedNarrative(currentPrice, garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return `
            <h4>AN√ÅLISE DI√ÅRIA - USD/BRL (${new Date().toLocaleDateString('pt-BR')})</h4>
            <p>Configure os par√¢metros de pre√ßo justo (PPP, UIP, juros) para an√°lise narrativa completa.</p>
          `;
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        const garch18 = garchAnalysis.p18;
        const intraday18 = intradayAnalysis.p18;
        
        let narrative = `
          <h4>AN√ÅLISE GARCH COM IA - USD/BRL (${new Date().toLocaleDateString('pt-BR')})</h4>
          
          <p><strong>SITUA√á√ÉO ATUAL:</strong><br>
          O d√≥lar fechou em ${this.fmt(currentPrice)}, operando ${Math.abs(deviation).toFixed(1)}% ${deviation > 0 ? 'ACIMA' : 'ABAIXO'} do pre√ßo just√≠ssimo de ${this.fmt(fairPriceAnalysis.fairPriceCombined)}. 
          Volatilidade 18P em ${vol18.toFixed(2)}% (${volatilityAnalysis.p18?.regime || 'MODERADA'}).</p>
          
          <p><strong>AN√ÅLISE GARCH MULTI-PER√çODO:</strong><br>`;
        
        if (garch18) {
          narrative += `Bandas GARCH 18P: ${this.fmt(garch18.down1sigma)} (-1œÉ) | ${this.fmt(garch18.up1sigma)} (+1œÉ)<br>`;
          
          if (currentPrice > garch18.up1sigma) {
            narrative += `‚ö†Ô∏è Pre√ßo ACIMA da banda superior (+1œÉ) - press√£o de venda estat√≠stica<br>`;
          } else if (currentPrice < garch18.down1sigma) {
            narrative += `‚ö†Ô∏è Pre√ßo ABAIXO da banda inferior (-1œÉ) - press√£o de compra estat√≠stica<br>`;
          } else {
            narrative += `‚úÖ Pre√ßo DENTRO das bandas ¬±1œÉ - comportamento normal<br>`;
          }
        }
        
        narrative += `</p><p><strong>PROJE√á√ïES INTRADAY (FATORES EXP):</strong><br>`;
        
        if (intraday18) {
          narrative += `Range esperado: ${this.fmt(intraday18.minIntraday)} - ${this.fmt(intraday18.maxIntraday)} (${intraday18.rangePercent.toFixed(2)}%)<br>`;
          narrative += `Potencial alta: +${intraday18.potentialGain.toFixed(2)}% | Potencial baixa: -${intraday18.potentialLoss.toFixed(2)}%`;
        }
        
        narrative += `</p><p><strong>PRE√áO JUSTO INTEGRADO (PPP+UIP):</strong><br>`;
        narrative += `PPP: ${this.fmt(fairPriceAnalysis.fairPricePPP)} | UIP: ${this.fmt(fairPriceAnalysis.fairPriceUIP)}<br>`;
        narrative += `Just√≠ssimo (40% PPP + 60% UIP): ${this.fmt(fairPriceAnalysis.fairPriceCombined)}<br>`;
        narrative += `Diferencial juros BR-US: ${(fairPriceAnalysis.interestDifferential * 100).toFixed(2)}p.p.`;
        
        narrative += `</p><p><strong>CEN√ÅRIOS PROBABIL√çSTICOS:</strong><br>`;
        
        if (Math.abs(deviation) > 8) {
          const direction = deviation > 0 ? 'CORRE√á√ÉO BAIXISTA' : 'RECUPERA√á√ÉO ALTISTA';
          const probability = Math.min(80, Math.round(Math.abs(deviation) * 8));
          
          narrative += `üéØ <strong>${direction} (${probability}%):</strong> Desvio extremo tende √† revers√£o<br>`;
          
          if (vol18 < 2.5) {
            narrative += `‚úÖ <strong>ALTA CONFIAN√áA:</strong> Baixa volatilidade favorece movimentos direcionais<br>`;
          } else {
            narrative += `‚ö†Ô∏è <strong>ATEN√á√ÉO:</strong> Alta volatilidade pode gerar ru√≠do no movimento`;
          }
        } else if (Math.abs(deviation) > 5) {
          narrative += `üìä <strong>MOVIMENTO MODERADO:</strong> Desvio ${Math.abs(deviation).toFixed(1)}% sugere corre√ß√£o gradual<br>`;
        } else {
          narrative += `üìä <strong>EQUIL√çBRIO:</strong> Pre√ßo pr√≥ximo ao justo, aguardar catalisador<br>`;
        }
        
        narrative += `</p><p><strong>RECOMENDA√á√ÉO FINAL:</strong><br>`;
        
        if (Math.abs(deviation) > 8 && vol18 < 2.5) {
          if (deviation > 8) {
            narrative += `üî¥ <strong>VENDA RECOMENDADA:</strong> Conflu√™ncia pre√ßo justo + GARCH indica sobrevaloriza√ß√£o. Stop acima de ${garch18 ? this.fmt(garch18.up2sigma) : 'N/D'}.`;
          } else {
            narrative += `üü¢ <strong>COMPRA RECOMENDADA:</strong> Conflu√™ncia pre√ßo justo + GARCH indica subvaloriza√ß√£o. Stop abaixo de ${garch18 ? this.fmt(garch18.down2sigma) : 'N/D'}.`;
          }
        } else if (vol18 > 4.0) {
          narrative += `üü° <strong>AGUARDAR:</strong> Volatilidade extrema (${vol18.toFixed(2)}%) requer paci√™ncia. Aguardar normaliza√ß√£o abaixo de 3%.`;
        } else {
          narrative += `üîç <strong>MONITORAR:</strong> Condi√ß√µes mistas. Aguardar confirma√ß√£o de dire√ß√£o com aumento de volume.`;
        }
        
        narrative += `</p>`;
        
        return narrative;
      }
      
      // Sistema FRP - Forward Rate Premium (mantido do original)
      convertSpotToFuture(spotPrice) {
        const frp = parseFloat(document.getElementById('frp')?.value || 0) / 100;
        const maturityDays = parseInt(document.getElementById('maturityDays')?.value || 30);
        const dataType = document.getElementById('dataType')?.value || 'spot';
        
        if (dataType === 'spot' && frp !== 0) {
          const timeFactor = maturityDays / 365;
          return spotPrice * (1 + frp * timeFactor);
        }
        
        return spotPrice;
      }
      
      convertFutureToSpot(futurePrice) {
        const frp = parseFloat(document.getElementById('frp')?.value || 0) / 100;
        const maturityDays = parseInt(document.getElementById('maturityDays')?.value || 30);
        const dataType = document.getElementById('dataType')?.value || 'spot';
        
        if (dataType === 'future' && frp !== 0) {
          const timeFactor = maturityDays / 365;
          return futurePrice / (1 + frp * timeFactor);
        }
        
        return futurePrice;
      }
      
      updateDataTypeUI() {
        const dataType = document.getElementById('dataType')?.value;
        const frpInput = document.getElementById('frp');
        const maturityInput = document.getElementById('maturityDays');
        
        if (dataType === 'spot') {
          frpInput.classList.add('frp-highlight');
          frpInput.classList.remove('frp-disabled');
          frpInput.placeholder = 'Ex: 13.75 (Selic atual)';
          this.log('Modo SPOT: FRP ser√° aplicado para converter para pre√ßos futuros');
        } else {
          frpInput.classList.remove('frp-highlight');
          frpInput.classList.add('frp-disabled');
          frpInput.placeholder = 'N√£o necess√°rio para dados futuros';
          this.log('Modo FUTURO: Dados j√° incorporam juros impl√≠citos');
        }
      }
      
      processRawData(rawPrices, sourceType = 'api') {
        const dataType = document.getElementById('dataType')?.value || 'spot';
        const frp = parseFloat(document.getElementById('frp')?.value || 0);
        
        let processedPrices = [...rawPrices];
        
        if (sourceType === 'api' && dataType === 'spot' && frp > 0) {
          processedPrices = processedPrices.map(price => this.convertSpotToFuture(price));
          this.log(`Convers√£o aplicada: Spot ‚Üí Futuro (FRP: ${frp.toFixed(2)}%)`);
        } else if (sourceType === 'excel' && dataType === 'future') {
          this.log('Dados futuros do Excel utilizados diretamente');
        } else if (sourceType === 'excel' && dataType === 'spot' && frp > 0) {
          processedPrices = processedPrices.map(price => this.convertSpotToFuture(price));
          this.log(`Convers√£o aplicada: Spot (Excel) ‚Üí Futuro (FRP: ${frp.toFixed(2)}%)`);
        }
        
        return processedPrices;
      }
      
      // API Configuration Methods (mantidos do original)
      selectProvider(provider) {
        document.querySelectorAll('.provider-card').forEach(card => {
          card.classList.remove('active');
        });
        document.querySelector(`[data-provider="${provider}"]`).classList.add('active');
        
        this.apiConfig.provider = provider;
        this.updateAPIInfo();
        this.updateProviderSpecificUI(provider);
      }
      
      updateProviderSpecificUI(provider) {
        const symbolInput = document.getElementById('symbol');
        
        switch(provider) {
          case 'alpha_vantage':
            symbolInput.value = 'USDBRL';
            break;
          case 'yahoo_finance':
            symbolInput.value = 'USDBRL=X';
            break;
          case 'polygon':
            symbolInput.value = 'C:USDBRL';
            break;
          case 'tradier':
            symbolInput.value = 'USD/BRL';
            break;
        }
        
        this.apiConfig.symbol = symbolInput.value;
      }
      
      updateAPIConfigFromInputs() {
        this.apiConfig.apiKey = document.getElementById('apiKey').value;
        this.apiConfig.symbol = document.getElementById('symbol').value;
        this.apiConfig.interval = document.getElementById('interval').value;
      }
      
      saveAPIConfig() {
        this.updateAPIConfigFromInputs();
        this.log(`Configura√ß√£o salva para ${this.apiConfig.provider}`);
        this.updateAPIInfo();
      }
      
      loadAPIConfig() {
        document.getElementById('apiKey').value = this.apiConfig.apiKey;
        document.getElementById('symbol').value = this.apiConfig.symbol;
        document.getElementById('interval').value = this.apiConfig.interval;
      }
      
      updateAPIInfo() {
        document.getElementById('activeProvider').textContent = this.getProviderDisplayName(this.apiConfig.provider);
        document.getElementById('connectionStatus').textContent = this.apiConnected ? 'Conectado' : 'Desconectado';
        document.getElementById('dataCount').textContent = this.priceData.length;
        
        const statusEl = document.getElementById('apiStatus');
        statusEl.textContent = `API: ${this.apiConnected ? 'Conectado' : 'Desconectado'}`;
        statusEl.className = `api-status ${this.apiConnected ? 'connected' : 'disconnected'}`;
      }
      
      getProviderDisplayName(provider) {
        const names = {
          'alpha_vantage': 'Alpha Vantage',
          'yahoo_finance': 'Yahoo Finance',
          'polygon': 'Polygon.io',
          'tradier': 'Tradier'
        };
        return names[provider] || provider;
      }
      
      async testAPIConnection() {
        this.showLoading();
        document.getElementById('apiStatus').className = 'api-status testing';
        document.getElementById('apiStatus').textContent = 'API: Testando...';
        
        try {
          if (this.apiConfig.provider === 'alpha_vantage') {
            const testKey = this.apiConfig.apiKey || 'demo';
            
            if (testKey === 'demo' || testKey === '') {
              this.apiConnected = true;
              this.updateAPIInfo();
              this.log('‚úÖ Modo demo ativo. Clique "üì° Dados via API" para ver dados real√≠sticos.');
              document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
              return;
            }
            
            const testUrl = `https://www.alphavantage.co/query?function=FX_DAILY&from_symbol=USD&to_symbol=BRL&apikey=${testKey}&outputsize=compact`;
            
            try {
              const response = await fetch(testUrl, {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
              });
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: Verifique sua conex√£o`);
              }
              
              const data = await response.json();
              
              if (data['Error Message']) {
                throw new Error(`API Key inv√°lida: ${data['Error Message']}`);
              }
              
              if (data['Note'] || data['Information']) {
                this.log('‚ö†Ô∏è Limite de calls atingido, mas API key √© v√°lida. Usando dados demo.');
                this.apiConnected = true;
              } else if (data['Meta Data'] || data['Time Series (Daily)']) {
                this.apiConnected = true;
                this.log('‚úÖ API Key v√°lida! Conectado ao Alpha Vantage.');
              } else {
                this.log('‚ö†Ô∏è Resposta inesperada da API. Usando dados demo para demonstra√ß√£o.');
                this.apiConnected = true;
              }
              
            } catch (fetchError) {
              console.error('Fetch error:', fetchError);
              
              if (fetchError.message.includes('CORS') || 
                  fetchError.message.includes('Failed to fetch') ||
                  fetchError.message.includes('NetworkError')) {
                this.log('‚ö†Ô∏è Problema de CORS/rede detectado. Sistema funcionar√° com dados demo.');
                this.apiConnected = true;
              } else {
                throw fetchError;
              }
            }
            
            this.updateAPIInfo();
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
          }
          
        } catch (error) {
          console.error('Test connection error:', error);
          this.apiConnected = false;
          this.updateAPIInfo();
          
          if (error.message.includes('API Key inv√°lida')) {
            this.log(`‚ùå ${error.message}. Verifique sua chave ou use 'demo'.`);
          } else if (error.message.includes('HTTP')) {
            this.log(`‚ùå ${error.message}. Tente novamente em alguns segundos.`);
          } else {
            this.log(`‚ùå Erro no teste: ${error.message}. Use 'demo' para testar.`);
          }
        } finally {
          this.hideLoading();
        }
      }
      
      async fetchAPIData() {
        const canProceed = this.apiConnected || 
                          this.apiConfig.provider === 'yahoo_finance' || 
                          this.apiConfig.apiKey === 'demo' || 
                          !this.apiConfig.apiKey;
        
        if (!canProceed) {
          this.log("Teste a conex√£o da API primeiro");
          return;
        }
        
        this.showLoading();
        this.setStatus("buscando dados da API...");
        
        try {
          let data;
          
          switch(this.apiConfig.provider) {
            case 'alpha_vantage':
              data = await this.fetchAlphaVantageData();
              break;
            case 'yahoo_finance':
              data = await this.fetchYahooFinanceData();
              break;
            case 'polygon':
              data = await this.fetchPolygonData();
              break;
            case 'tradier':
              data = await this.fetchTradierData();
              break;
            default:
              throw new Error('Provedor n√£o suportado');
          }
          
          const processedData = this.processRawData(data, 'api');
          this.priceData = processedData;
          this.refreshAll();
          this.setStatus(`${processedData.length} pontos da API`);
          this.log(`‚úÖ Dados processados via ${this.getProviderDisplayName(this.apiConfig.provider)}: ${processedData.length} registros`);
          document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
          
          // Auto-run AI analysis if data is available
          if (processedData.length > 20) {
            setTimeout(() => this.performAIAnalysis(), 1000);
          }
          
          const welcomeBanner = document.querySelector('.welcome-banner');
          if (welcomeBanner) {
            welcomeBanner.style.display = 'none';
          }
          
        } catch (error) {
          this.setStatus("erro na API");
          this.log(`‚ùå Erro API: ${error.message}`);
          
          if (error.message.includes('API Key')) {
            this.log("üí° Dica: Use 'demo' como API key para testar, ou carregue dados manualmente");
          }
        } finally {
          this.hideLoading();
        }
      }
      
      async fetchAlphaVantageData() {
        const apiKey = this.apiConfig.apiKey || 'demo';
        
        if (apiKey === 'demo' || apiKey === '') {
          this.log('üéØ Usando dados demo para demonstra√ß√£o');
          return this.generateFallbackData();
        }

        let url = `https://www.alphavantage.co/query?function=FX_DAILY&from_symbol=USD&to_symbol=BRL&apikey=${apiKey}&outputsize=compact`;
        
        this.log('Conectando com Alpha Vantage...');
        
        try {
          const response = await fetch(url, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
            }
          });
          
          if (!response.ok) {
            this.log(`‚ö†Ô∏è Erro HTTP ${response.status}. Usando dados demo.`);
            return this.generateFallbackData();
          }
          
          const data = await response.json();
          
          if (data['Error Message'] || data['Note'] || data['Information']) {
            this.log('‚ö†Ô∏è Limite de API atingido. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          const timeSeries = data['Time Series (Daily)'] || data['Time Series FX (Daily)'];
          
          if (!timeSeries || typeof timeSeries !== 'object') {
            this.log('‚ö†Ô∏è Estrutura de dados inesperada da API. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          const dates = Object.keys(timeSeries).sort();
          
          if (dates.length === 0) {
            this.log('‚ö†Ô∏è Nenhum dado temporal encontrado. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          const prices = [];
          const recentDates = dates.slice(-60);
          
          for (const date of recentDates) {
            const dayData = timeSeries[date];
            if (!dayData || typeof dayData !== 'object') continue;
            
            const closePrice = parseFloat(
              dayData['4. close'] || 
              dayData['close'] || 
              dayData['Close'] || 
              dayData['4'] ||
              0
            );
            
            if (!isNaN(closePrice) && closePrice > 0) {
              let adjustedPrice = closePrice;
              
              if (closePrice < 10) {
                adjustedPrice = closePrice * 1000;
              }
              
              prices.push(Number(adjustedPrice.toFixed(2)));
            }
          }
          
          if (prices.length === 0) {
            this.log('‚ö†Ô∏è Nenhum pre√ßo v√°lido processado. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          this.log(`‚úÖ Alpha Vantage: ${prices.length} pre√ßos USD/BRL processados com sucesso`);
          return prices;
          
        } catch (error) {
          console.error('Alpha Vantage Error:', error);
          this.log(`‚ö†Ô∏è Erro de conex√£o: ${error.message}. Usando dados demo.`);
          return this.generateFallbackData();
        }
      }
      
      generateFallbackData() {
        const baseRate = 5.20;
        const data = [];
        let currentRate = baseRate;
        
        for (let i = 0; i < 50; i++) {
          const dailyChange = (Math.random() - 0.5) * 0.06;
          const trend = Math.sin(i * 0.1) * 0.01;
          
          currentRate *= (1 + dailyChange + trend);
          currentRate = Math.max(4.80, Math.min(5.80, currentRate));
          
          data.push(Number(currentRate.toFixed(4)));
        }
        
        return data;
      }
      
      async fetchYahooFinanceData() {
        await new Promise(resolve => setTimeout(resolve, 1200));
        return this.generateRealisticData(100);
      }
      
      async fetchPolygonData() {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return this.generateRealisticData(75);
      }
      
      async fetchTradierData() {
        await new Promise(resolve => setTimeout(resolve, 1300));
        return this.generateRealisticData(50);
      }
      
      generateRealisticData(count) {
        const currentClose = 5.437;
        const out = [];
        let x = currentClose;
        
        for (let i = count - 1; i >= 0; i--) {
          const daysBack = i;
          const trend = Math.sin(daysBack * 0.06) * 0.003;
          const dailyVolatility = (Math.random() - 0.5) * 0.018;
          const momentum = Math.sin(daysBack * 0.25) * 0.002;
          const meanReversion = (5.42 - x) * 0.0005;
          
          x *= (1 + trend + dailyVolatility + momentum + meanReversion);
          x = Math.max(5.20, Math.min(5.65, x));
          out.push(Number(x.toFixed(4)));
        }
        
        out.reverse();
        out[out.length - 1] = currentClose;
        
        return out;
      }
      
      async fetchSimulatedData() {
        this.showLoading();
        this.setStatus("buscando dados simulados...");
        
        try {
          await new Promise(resolve => setTimeout(resolve, 1000));
          const data = this.generateRealisticData(50);
          const processedData = this.processRawData(data, 'simulated');
          this.priceData = processedData;
          this.refreshAll();
          this.setStatus(`${processedData.length} pontos simulados`);
          this.log(`Dados simulados carregados: ${processedData.length} pre√ßos`);
          
          // Auto-run AI analysis
          if (processedData.length > 20) {
            setTimeout(() => this.performAIAnalysis(), 500);
          }
          
          const welcomeBanner = document.querySelector('.welcome-banner');
          if (welcomeBanner) {
            welcomeBanner.style.display = 'none';
          }
        } catch (e) {
          this.setStatus("erro ao buscar dados");
          this.log("Erro: " + e.message);
        } finally {
          this.hideLoading();
        }
      }
      
      logout() {
        if (confirm('Deseja realmente sair do sistema?')) {
          sessionStorage.removeItem('currentUser');
          window.location.href = 'index.html';
        }
      }
      
      showLoading() {
        document.getElementById('loadingOverlay').style.display = 'flex';
      }
      
      hideLoading() {
        document.getElementById('loadingOverlay').style.display = 'none';
      }
      
      analyze() {
        if (!this.priceData.length) {
          this.log("Carregue dados primeiro");
          return;
        }
        
        this.showLoading();
        
        setTimeout(() => {
          this.refreshAll();
          this.log("An√°lise executada com sucesso");
          
          // Auto-run AI analysis after regular analysis
          setTimeout(() => this.performAIAnalysis(), 500);
          
          this.hideLoading();
        }, 800);
      }
      
      loadManualData() {
        const text = document.getElementById('manualData').value.trim();
        if (!text) {
          this.log("Digite alguns pre√ßos primeiro");
          return;
        }
        
        const lines = text.split('\n').filter(l => l.trim());
        const rawPrices = lines.map(l => parseFloat(l.trim())).filter(p => !isNaN(p));
        
        if (rawPrices.length === 0) {
          this.log("Nenhum pre√ßo v√°lido encontrado");
          return;
        }
        
        const processedPrices = this.processRawData(rawPrices, 'manual');
        this.priceData = processedPrices;
        this.refreshAll();
        this.setStatus(`${processedPrices.length} pre√ßos manuais`);
        this.log(`${processedPrices.length} pre√ßos processados manualmente`);
        this.updateAPIInfo();
        
        // Auto-run AI analysis
        if (processedPrices.length > 10) {
          setTimeout(() => this.performAIAnalysis(), 500);
        }
      }
      
      clearData() {
        if (!confirm('Deseja realmente limpar todos os dados?')) {
          return;
        }
        
        this.priceData = [];
        this.linearReturns = [];
        this.aiAnalysis = null;
        document.getElementById('manualData').value = "";
        
        const valueElements = document.querySelectorAll('.value');
        valueElements.forEach(el => el.innerText = '--');
        
        document.getElementById('debugInfo').innerText = "Debug: aguardando c√°lculos...";
        
        this.setStatus("dados limpos");
        this.log("Dados limpos");
        this.updateAPIInfo();
        this.updateAIDisplay(); // Reset AI display
      }
      
      handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        this.showLoading();
        this.log("Processando arquivo Excel...");
        
        const reader = new FileReader();
        reader.onload = (evt) => {
          try {
            const data = evt.target.result;
            const workbook = XLSX.read(data, {type: 'binary'});
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
            
            if (jsonData.length === 0) {
              this.log("Planilha vazia");
              this.hideLoading();
              return;
            }
            
            const firstRow = jsonData[0] || [];
            
            let closeColumn = 4;
            for (let i = 0; i < firstRow.length; i++) {
              const header = String(firstRow[i]).toLowerCase();
              if (header.includes('fechamento') || header.includes('close')) {
                closeColumn = i;
                break;
              }
            }
            
            const prices = [];
            
            for (let i = 1; i < jsonData.length; i++) {
              const row = jsonData[i];
              if (!row || row.length <= closeColumn) continue;
              
              let rawPrice = row[closeColumn];
              if (rawPrice === undefined || rawPrice === null || rawPrice === '') continue;
              
              let numPrice;
              if (typeof rawPrice === 'number') {
                numPrice = rawPrice;
              } else if (typeof rawPrice === 'string') {
                const cleaned = rawPrice.trim().replace(',', '.');
                numPrice = parseFloat(cleaned);
              } else {
                continue;
              }
              
              if (!isNaN(numPrice) && numPrice >= 4000 && numPrice <= 7000) {
                prices.push(numPrice);
              }
            }
            
            prices.reverse();
            
            if (prices.length > 0) {
              document.getElementById('dataType').value = 'future';
              this.updateDataTypeUI();
              
              const processedPrices = this.processRawData(prices, 'excel');
              this.priceData = processedPrices;
              this.refreshAll();
              this.setStatus(`${processedPrices.length} pre√ßos importados`);
              this.log(`${processedPrices.length} pre√ßos do Excel processados (DOL Futuro)`);
              this.updateAPIInfo();
              
              // Auto-run AI analysis
              if (processedPrices.length > 20) {
                setTimeout(() => this.performAIAnalysis(), 1000);
              }
            } else {
              this.log(`Nenhum pre√ßo v√°lido encontrado na coluna ${String.fromCharCode(65+closeColumn)}`);
            }
          } catch (err) {
            this.log("Erro ao ler Excel: " + err.message);
          } finally {
            this.hideLoading();
          }
        };
        reader.readAsBinaryString(file);
      }
      
      // Mathematical calculations (maintained from original)
      calculateLinearReturns() {
        this.linearReturns = [];
        if (this.priceData.length < 2) return;
        
        for (let i = 1; i < this.priceData.length; i++) {
          const current = this.priceData[i];
          const previous = this.priceData[i - 1];
          const linearReturn = current / previous;
          this.linearReturns.push(linearReturn);
        }
      }
      
      calculateStdDevReturns(periods) {
        if (this.linearReturns.length < periods) return NaN;
        
        const slice = this.linearReturns.slice(-periods);
        const mean = slice.reduce((sum, ret) => sum + ret, 0) / slice.length;
        const variance = slice.reduce((sum, ret) => sum + Math.pow(ret - mean, 2), 0) / slice.length;
        const stdDev = Math.sqrt(variance);
        
        return stdDev;
      }
      
      lastClose() {
        return this.priceData.length ? this.priceData[this.priceData.length - 1] : NaN;
      }
      
      currentReturn() {
        return this.linearReturns.length ? this.linearReturns[this.linearReturns.length - 1] : NaN;
      }
      
      getExpFor(period) {
        if (period === 9) return parseFloat(document.getElementById('exp9').value) || 2.718;
        if (period === 18) return parseFloat(document.getElementById('exp18').value) || 2.718;
        if (period === 27) return parseFloat(document.getElementById('exp27').value) || 2.718;
        return 2.718;
      }
      
      calculateMultiPeriodForecasts(period) {
        if (!this.priceData.length || this.linearReturns.length < period) return;
        
        const lc = this.lastClose();
        const stdDev = this.calculateStdDevReturns(period);
        
        if (!isFinite(stdDev)) return;
        
        const up1 = lc * (1 + stdDev);
        const dn1 = lc * (1 - stdDev);
        const up2 = lc * (1 + 2 * stdDev);
        const dn2 = lc * (1 - 2 * stdDev);
        
        document.getElementById('f_up1').innerText = this.fmt(up1);
        document.getElementById('f_dn1').innerText = this.fmt(dn1);
        document.getElementById('f_up2').innerText = this.fmt(up2);
        document.getElementById('f_dn2').innerText = this.fmt(dn2);
      }
      
      calculateIntradayExtremes(period) {
        if (!this.priceData.length || this.linearReturns.length < period) return;
        
        const lc = this.lastClose();
        const stdDev = this.calculateStdDevReturns(period);
        const expFactor = this.getExpFor(period);
        
        if (!isFinite(stdDev) || !isFinite(lc)) return;
        
        const expStdDev = Math.pow(expFactor, stdDev);
        const iMax = lc * expStdDev;
        const iMin = lc / expStdDev;
        
        document.getElementById('i_max').innerText = this.fmt(iMax);
        document.getElementById('i_min').innerText = this.fmt(iMin);
        document.getElementById('i_close').innerText = this.fmt(lc);
        document.getElementById('i_sigma').innerText = (stdDev * 100).toFixed(4) + "%";
        
        const debugText = `Per√≠odo: ${period}P | StdDev: ${(stdDev*100).toFixed(4)}% | ExpFactor: ${expFactor} | Exp^œÉ: ${expStdDev.toFixed(6)} | Max: ${this.fmt(iMax)} | Min: ${this.fmt(iMin)}`;
        document.getElementById('debugInfo').innerText = debugText;
      }
      
      switchForecastPeriod(period) {
        this.currentForecastP = period;
        document.querySelectorAll('#forecastTabs .tab').forEach(el => el.classList.remove('active'));
        const target = document.querySelector(`#forecastTabs .tab[data-period="${period}"]`);
        if (target) target.classList.add('active');
        this.calculateMultiPeriodForecasts(period);
      }
      
      switchIntradayPeriod(period) {
        this.currentIntradayP = period;
        document.querySelectorAll('#intradayTabs .tab').forEach(tab => tab.classList.remove('active'));
        const target = document.querySelector(`#intradayTabs .tab[data-iperiod="${period}"]`);
        if (target) target.classList.add('active');
        this.calculateIntradayExtremes(period);
      }
      
      // Fair Price Calculations (maintained from original with fixes)
      calculateFairPrices() {
        const currentPrice = this.lastClose();
        if (!isFinite(currentPrice) || currentPrice <= 0) {
          this.resetFairPriceDisplay();
          return;
        }
        
        let pppRate = parseFloat(document.getElementById('ppp_rate')?.value || 5.30);
        const inflationBr = parseFloat(document.getElementById('inflation_br')?.value || 4.5) / 100;
        const inflationUs = parseFloat(document.getElementById('inflation_us')?.value || 3.2) / 100;
        const selicRate = parseFloat(document.getElementById('selic_rate')?.value || 15.50) / 100;
        const fedRate = parseFloat(document.getElementById('fed_rate')?.value || 5.50) / 100;
        const riskPremium = parseFloat(document.getElementById('risk_premium')?.value || 2.5) / 100;

        if (currentPrice > 100) {
          pppRate = pppRate * 1000;
        }

        const inflationDifferential = inflationBr - inflationUs;
        const fairPricePPP = pppRate * ((1 + inflationBr) / (1 + inflationUs));

        const interestDifferential = selicRate - fedRate;
        const netInterestDifferential = interestDifferential - riskPremium;
        const uipAdjustmentFactor = 1 + (netInterestDifferential * 0.15);
        const fairPriceUIP = currentPrice * uipAdjustmentFactor;

        const maxUIPDeviation = 0.20;
        const upperBoundUIP = currentPrice * (1 + maxUIPDeviation);
        const lowerBoundUIP = currentPrice * (1 - maxUIPDeviation);
        const boundedFairPriceUIP = Math.max(lowerBoundUIP, Math.min(upperBoundUIP, fairPriceUIP));

        const weightPPP = 0.4;
        const weightUIP = 0.6;
        const fairPriceCombined = (fairPricePPP * weightPPP) + (boundedFairPriceUIP * weightUIP);

        const maxTotalDeviation = 0.25;
        const upperBound = currentPrice * (1 + maxTotalDeviation);
        const lowerBound = currentPrice * (1 - maxTotalDeviation);
        const finalFairPrice = Math.max(lowerBound, Math.min(upperBound, fairPriceCombined));

        const deviationFair = ((currentPrice - finalFairPrice) / finalFairPrice) * 100;

        const riskFactor = 1 + riskPremium;
        const trend30d = this.calculateTrend30Days();

        document.getElementById('fair_ppp').innerText = this.fmt(fairPricePPP);
        document.getElementById('fair_uip').innerText = this.fmt(boundedFairPriceUIP);
        document.getElementById('fair_combined').innerText = this.fmt(finalFairPrice);
        document.getElementById('deviation_fair').innerText = deviationFair.toFixed(2) + '%';
        document.getElementById('interest_diff').innerText = (interestDifferential * 100).toFixed(2) + 'p.p.';
        document.getElementById('inflation_diff').innerText = (inflationDifferential * 100).toFixed(2) + 'p.p.';
        document.getElementById('risk_factor').innerText = riskFactor.toFixed(4);
        document.getElementById('trend_30d').innerText = trend30d;

        this.updateFairPriceCardColors(deviationFair);
      }
      
      calculateTrend30Days() {
        if (this.priceData.length < 30) {
          return 'Dados insuficientes';
        }
        
        const recent30 = this.priceData.slice(-30);
        const first = recent30[0];
        const last = recent30[recent30.length - 1];
        const trend = ((last - first) / first) * 100;
        
        if (trend > 2) return `Forte Alta ${trend.toFixed(1)}%`;
        if (trend > 0.5) return `Alta ${trend.toFixed(1)}%`;
        if (trend < -2) return `Forte Baixa ${trend.toFixed(1)}%`;
        if (trend < -0.5) return `Baixa ${trend.toFixed(1)}%`;
        return `Lateral ${trend.toFixed(1)}%`;
      }
      
      updateFairPriceCardColors(deviation) {
        const fairCombinedCard = document.getElementById('fair_combined').closest('.card');
        const deviationCard = document.getElementById('deviation_fair').closest('.card');
        
        [fairCombinedCard, deviationCard].forEach(card => {
          if (card) {
            card.classList.remove('up-card', 'down-card', 'neutral-card');
          }
        });
        
        if (Math.abs(deviation) < 5) {
          if (fairCombinedCard) fairCombinedCard.classList.add('neutral-card');
          if (deviationCard) deviationCard.classList.add('neutral-card');
        } else if (deviation > 0) {
          if (fairCombinedCard) fairCombinedCard.classList.add('down-card');
          if (deviationCard) deviationCard.classList.add('down-card');
        } else {
          if (fairCombinedCard) fairCombinedCard.classList.add('up-card');
          if (deviationCard) deviationCard.classList.add('up-card');
        }
      }
      
      resetFairPriceDisplay() {
        ['fair_ppp', 'fair_uip', 'fair_combined', 'deviation_fair', 
         'interest_diff', 'inflation_diff', 'risk_factor', 'trend_30d'].forEach(id => {
          const element = document.getElementById(id);
          if (element) element.innerText = '--';
        });
      }
      
      updateExtras() {
        const lc = this.lastClose();
        const currentRet = this.currentReturn();
        
        if (isFinite(currentRet)) {
          const retPercent = (currentRet - 1) * 100;
          document.getElementById('ret_current').innerText = currentRet.toFixed(6) + ` (${retPercent.toFixed(2)}%)`;
        }
        
        [9, 18, 27].forEach(p => {
          const stdDev = this.calculateStdDevReturns(p);
          if (isFinite(stdDev)) {
            document.getElementById(`std${p}`).innerText = (stdDev * 100).toFixed(4) + "%";
            
            const expFactor = this.getExpFor(p);
            const expStdDev = Math.pow(expFactor, stdDev);
            document.getElementById(`exp_std${p}`).innerText = expStdDev.toFixed(6);
            
            if (isFinite(lc)) {
              const maxValue = lc * expStdDev;
              const minValue = lc / expStdDev;
              document.getElementById(`max_${p}p`).innerText = this.fmt(maxValue);
              document.getElementById(`min_${p}p`).innerText = this.fmt(minValue);
            }
          }
        });
      }
      
      refreshAll() {
        this.calculateLinearReturns();
        this.calculateMultiPeriodForecasts(this.currentForecastP);
        this.calculateIntradayExtremes(this.currentIntradayP);
        this.updateExtras();
        this.calculateFairPrices();
        this.updateAPIInfo();
      }
      
      fmt(v) {
        return (isFinite(v) ? Number(v).toFixed(2) : '--');
      }
      
      log(msg) {
        document.getElementById("log").innerText = msg;
        console.log(`[Trading System AI] ${msg}`);
      }
      
      setStatus(msg) {
        document.getElementById("dataStatus").innerText = msg;
      }
    }
    
    // Initialize trading system when page loads
    document.addEventListener('DOMContentLoaded', () => {
      window.tradingSystem = new TradingSystemWithAI();
    });
  </script>
  
  
<script>
/* =======================
   PATCH CONSOLIDADO ‚Äî 2 cards (Compra & Venda)
   Toque + 10‚Äì15 pts + Just√≠ssimo + cluster de 3 n√≠veis
   Compat com IA + dist√¢ncias (pts) arredondadas
   ======================= */
(function(){
  function onReady(fn){
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", fn);
    else fn();
  }

  onReady(function(){
    var tries = 0, t = setInterval(function(){
      var ts = window.tradingSystem;
      if (ts && typeof ts.generateTradingStrategy==="function"
            && typeof ts.analyzeSystemIntraday==="function"
            && typeof ts.analyzeSystemFairPrice==="function"
            && typeof ts.analyzeSystemVolatility==="function"
            && typeof ts.analyzeSystemGARCH==="function"
            && typeof ts.lastClose==="function") {
        clearInterval(t);
        apply(ts);
      }
      if (++tries>200) clearInterval(t);
    }, 100);
  });

  // helpers globais
  const F = (x)=> Number.isFinite(x) ? Number(x).toFixed(2) : "--";
  const STORAGE_KEY = "touchMode"; // "prearm" | "strict"
  function getTouchMode(){ return localStorage.getItem(STORAGE_KEY) || "prearm"; }
  function setTouchMode(v){ localStorage.setItem(STORAGE_KEY, v==="strict"?"strict":"prearm"); }

  function apply(ts){
    function getLevels(){
      const ia = ts.analyzeSystemIntraday();
      const p9  = ia.p9  || {}, p18 = ia.p18 || {}, p27 = ia.p27 || {};
      return {
        buys:  [p9.minIntraday,  p18.minIntraday,  p27.minIntraday].filter(Number.isFinite),
        sells: [p9.maxIntraday,  p18.maxIntraday,  p27.maxIntraday].filter(Number.isFinite)
      };
    }
    function getFair(){
      const f = ts.analyzeSystemFairPrice() || {};
      return { valid: !!f.valid, justoPPP: f.fairPricePPP, justissimo: f.fairPriceCombined };
    }
    function choosePts(vol18){
      if (vol18 >= 3.0) return 15;
      if (vol18 <= 1.5) return 10;
      return 12;
    }
    function sizeByVol(vol18, conf){
      if (vol18 > 3.5) return "REDUZIDA (50%)";
      if (vol18 > 3.0) return "REDUZIDA (70%)";
      if (vol18 < 1.5 && conf > 80) return "AUMENTADA (120-150%)";
      if (conf > 85) return "NORMAL+ (110%)";
      return "NORMAL";
    }
    function RR(entry, tgt, stop){
      const g = Math.abs(tgt-entry), l = Math.abs(entry-stop);
      return (l>0) ? (g/l) : 0;
    }
    function clusterOK(levels, maxSpreadPts){
      if (levels.length < 2) return false;
      const min = Math.min(...levels), max = Math.max(...levels);
      return (max - min) <= maxSpreadPts;
    }

    function buildSide(side, px, levels, fair, vol18, conf, g18){
      const mode = getTouchMode();
      const pts  = choosePts(vol18);
      const tol  = pts;                       // toler√¢ncia de toque
      const spreadOK = clusterOK(levels, 10); // 3 n√≠veis dentro de 10 pts

      const levs = levels.slice().sort((a,b)=>a-b);
      const minL = levs[0], maxL = levs[levs.length-1];
      const nearest = levs.reduce((best,lv)=> (Math.abs(px-lv) < Math.abs(px-best)? lv:best), levs[0]);

      const s = {
        side, // "BUY" | "SELL"
        recommendation: "AGUARDAR",
        entryRange: {min: NaN, max: NaN},
        entryRef: NaN,
        stopLoss: NaN,
        target: NaN,
        targetFinal: NaN,
        confidence: conf,
        positionSize: sizeByVol(vol18, conf),
        timeframe: "intraday",
        riskReward: 0,
        preArmNote: "",
        bandsNote: ""
      };

      if (!spreadOK){
        s.entryRange = { min: nearest, max: nearest };
        s.entryRef   = nearest;
      } else {
        s.entryRange = { min: minL, max: maxL };
        s.entryRef   = (minL + maxL)/2;
      }

      // stop 10 pts al√©m do √∫ltimo n√≠vel
      const stop = (side==="BUY") ? (minL - 10) : (maxL + 10);

      // alvo curto 10‚Äì15 pts a partir do ref
      const tgt  = (side==="BUY") ? (s.entryRef + pts) : (s.entryRef - pts);

      // alvo final = Just√≠ssimo quando a dire√ß√£o favorece
      const just = fair.justissimo;
      const aFavorDoJust = (side==="BUY"  && just > s.entryRef) ||
                           (side==="SELL" && just < s.entryRef);
      const tgtFinal = aFavorDoJust ? just : tgt;

      s.stopLoss = stop;
      s.target   = tgt;
      s.targetFinal = tgtFinal;

      // condi√ß√£o de ‚Äútoque/armado‚Äù
      const insideRange = (px >= s.entryRange.min - tol) && (px <= s.entryRange.max + tol);

      if (!insideRange){
        const dist = Math.min(Math.abs(px - s.entryRange.min), Math.abs(px - s.entryRange.max));
        const distPts = Math.round(dist); // <<< arredondado
        if (mode === "prearm"){
          s.recommendation = "AGUARDAR";
          s.preArmNote = `A ${distPts} pts da regi√£o (${F(s.entryRange.min)}‚Äì${F(s.entryRange.max)})`;
        } else {
          s.recommendation = "AGUARDAR";
          s.entryRange = {min: NaN, max: NaN};
          s.entryRef = NaN; s.stopLoss = NaN; s.target = NaN; s.targetFinal = NaN;
          s.preArmNote = `A ${distPts} pts da regi√£o`;
        }
      } else {
        s.recommendation = (side==="BUY") ? "COMPRA NA REGI√ÉO" : "VENDA NA REGI√ÉO";
      }

      // RR
      if (Number.isFinite(s.entryRef) && Number.isFinite(s.target) && Number.isFinite(s.stopLoss)){
        s.riskReward = RR(s.entryRef, s.target, s.stopLoss);
      }

      // nota de bandas (¬±1œÉ) como refer√™ncia
      if (g18) {
        if (side==="BUY") s.bandsNote = `Refer√™ncia bandas: -1œÉ ${F(g18.down1sigma)} | +1œÉ ${F(g18.up1sigma)}`;
        else              s.bandsNote = `Refer√™ncia bandas: +1œÉ ${F(g18.up1sigma)} | -1œÉ ${F(g18.down1sigma)}`;
      }

      return s;
    }

    // ============ ESTRAT√âGIA (2 cards) + OBJETO COMPAT ============
    ts.generateTradingStrategy = function(){
      const fair = getFair();
      const {buys, sells} = getLevels();
      const px   = Number(ts.lastClose()||0) || 0;
      const vol18 = (ts.analyzeSystemVolatility().p18||{}).volatilityPercent || 2.0;
      const conf  = Number(ts.calculateAdvancedConfidenceScore ? ts.calculateAdvancedConfidenceScore() : 60);
      const g18   = (ts.analyzeSystemGARCH()||{}).p18;

      // helpers locais para sele√ß√£o do compat
      function regionDistance(px, s){
        if (!s || !Number.isFinite(s.entryRange?.min) || !Number.isFinite(s.entryRange?.max)) return Infinity;
        const d1 = Math.abs(px - s.entryRange.min);
        const d2 = Math.abs(px - s.entryRange.max);
        return Math.min(d1, d2);
      }
      function centerDist(px, s){
        if (!s || !Number.isFinite(s.entryRange?.min) || !Number.isFinite(s.entryRange?.max)) return Infinity;
        const c = (s.entryRange.min + s.entryRange.max)/2;
        return Math.abs(px - c);
      }
      const isArmed = s => s && typeof s.recommendation==="string" && s.recommendation.includes("REGI√ÉO");

      // sem dados suficientes
      if (!fair.valid || (!buys.length && !sells.length)) {
        return {
          long: null,
          short: null,
          recommendation: "AGUARDAR",
          direction: null,
          entryZone: {min: NaN, max: NaN},
          target: NaN,
          stopLoss: NaN,
          riskReward: 0
        };
      }

      // monta os dois lados
      const long  = buys.length  ? buildSide("BUY",  px, buys,  fair, vol18, conf, g18)  : null;
      const short = sells.length ? buildSide("SELL", px, sells, fair, vol18, conf, g18) : null;

      // ===== escolhe um lado para o compat =====
      let chosen = null;
      if (isArmed(long) || isArmed(short)){
        const cand = [long, short].filter(isArmed);
        chosen = cand.sort((a,b)=>centerDist(px,a)-centerDist(px,b))[0] || null;
      } else {
        const dL = regionDistance(px,long), dS = regionDistance(px,short);
        chosen = (dL < dS) ? long : short;
      }

      // monta campos compat
      let compat = {
        recommendation: "AGUARDAR",
        direction: null,
        entryZone: {min: NaN, max: NaN},
        target: NaN,
        stopLoss: NaN,
        riskReward: 0
      };
      if (chosen){
        compat.recommendation = isArmed(chosen)
          ? (chosen.side==="BUY" ? "COMPRA NA REGI√ÉO" : "VENDA NA REGI√ÉO")
          : "AGUARDAR";
        compat.direction = chosen.side==="BUY" ? "BUY" : "SELL";
        compat.entryZone = { min: chosen.entryRange?.min, max: chosen.entryRange?.max };
        compat.target    = chosen.target;
        compat.stopLoss  = chosen.stopLoss;
        compat.riskReward= chosen.riskReward || 0;
      }

      // devolve os dois cards + o compat na mesma resposta
      return Object.assign(compat, { long, short });
    };

    // ============ PAINEL (dois cards) + Toggle ============
    ts.renderStrategyPanel = function(){
      const out = ts.generateTradingStrategy();
      const op = document.getElementById("aiOperation");
      const rk = document.getElementById("aiRisk");
      const lv = document.getElementById("aiLevels");
      if (!op || !rk || !lv) return;

      const mode = getTouchMode();
      const toggle = `
        <div style="margin:-6px 0 8px 0; display:flex; gap:12px; align-items:center;">
          <label style="font-size:12px; font-weight:700;">Modo:</label>
          <label style="font-size:12px; display:flex; gap:6px; align-items:center; cursor:pointer;">
            <input id="prearmToggle" type="checkbox" ${mode==="prearm"?"checked":""} />
            <span>Pr√©-armar</span>
          </label>
          <span style="font-size:11px; color:#475569;">(desmarque para exigir toque)</span>
        </div>`;

      function cta(s){
        if (!s) return {title:"Aguardando dados", detail:""};
        const dirTxt = s.side==="BUY" ? "COMPRA" : "VENDA";
        const armed  = s.recommendation.includes("REGI√ÉO");
        const title  = armed
          ? `‚úÖ <b>${dirTxt} NA REGI√ÉO</b> ${F(s.entryRange.min)}‚Äì${F(s.entryRange.max)}`
          : `‚è≥ <b>PREPARAR ${dirTxt}</b> ${s.preArmNote ? "‚Äî "+s.preArmNote : ""}`;

        const pts = (Number.isFinite(s.entryRef) && Number.isFinite(s.stopLoss))
                      ? Math.abs(s.entryRef - s.stopLoss).toFixed(0) : "--";

        const detail = `
          <span style="display:block;margin-top:4px;">
            üîî <b>Gatilho:</b> tocar regi√£o ${F(s.entryRange.min)}‚Äì${F(s.entryRange.max)} ¬∑
            üõë <b>Stop:</b> ${F(s.stopLoss)} (${pts} pts ap√≥s √∫ltima ${s.side==="BUY"?"m√≠nima":"m√°xima"}) ¬∑
            üéØ <b>Alvo:</b> ${F(s.target)}${(s.targetFinal && s.targetFinal!==s.target) ? ` ‚Üí ${F(s.targetFinal)}` : ""} ¬∑
            üìä <b>R/R:</b> ${(s.riskReward>0 && Number.isFinite(s.riskReward)) ? ("1:"+s.riskReward.toFixed(2)):"--"}
          </span>
          ${s.bandsNote ? `<span style="display:block;margin-top:4px; font-size:12px; color:#475569;">${s.bandsNote}</span>`:""}
        `;
        return {title, detail};
      }

      const L = cta(out.long), S = cta(out.short);

      // dois cards (verde compra, vermelho venda)
      op.innerHTML = `
        <div class="card-grid">
          <div class="card card-success">
            ${toggle}
            <h4>üü¢ COMPRA ‚Äî 3 M√çNIMAS</h4>
            <p>${L.title}</p>
            ${L.detail}
            <p style="margin-top:6px;">‚è≥ <b>Prazo:</b> intraday &nbsp; üìà <b>Confian√ßa:</b> ${out.long? out.long.confidence:"--"}% &nbsp; üì¶ <b>Tamanho:</b> ${out.long? out.long.positionSize:"--"}</p>
          </div>

          <div class="card card-danger">
            <h4>üî¥ VENDA ‚Äî 3 M√ÅXIMAS</h4>
            <p>${S.title}</p>
            ${S.detail}
            <p style="margin-top:6px;">‚è≥ <b>Prazo:</b> intraday &nbsp; üìà <b>Confian√ßa:</b> ${out.short? out.short.confidence:"--"}% &nbsp; üì¶ <b>Tamanho:</b> ${out.short? out.short.positionSize:"--"}</p>
          </div>
        </div>
      `;

      // liga o toggle
      const cb = op.querySelector("#prearmToggle");
      if (cb){
        cb.addEventListener("change", ()=>{
          setTouchMode(cb.checked ? "prearm" : "strict");
          try{ ts.renderStrategyPanel(); }catch(_){}
        }, { once:true });
      }

      // Gest√£o de risco (texto)
      rk.innerHTML = `
        <div class="card-grid">
          <div class="card card-info" style="border-color:#fca5a5; background:linear-gradient(180deg,#fef2f2,#ffffff);">
            <h4>‚ö†Ô∏è GEST√ÉO DE RISCO</h4>
            <p>‚Ä¢ Trabalhar a <b>regi√£o</b> quando as 3 m√≠nimas/m√°ximas estiverem a ‚â§10 pts entre si;</p>
            <p>‚Ä¢ <b>Stop:</b> 10 pts al√©m da √∫ltima m√°xima/m√≠nima (lado da opera√ß√£o);</p>
            <p>‚Ä¢ <b>Alvo curto:</b> 10‚Äì15 pts (din√¢mico pela vol 18P); <b>Alvo final:</b> Just√≠ssimo quando a dire√ß√£o favorecer;</p>
            <p>‚Ä¢ <b>Break-even:</b> ao atingir +8 pts a favor, mover stop para o pre√ßo de entrada;</p>
            <p>‚Ä¢ <b>Ru√≠do:</b> reduzir lote se vol 18P > 3.0%.</p>
          </div>
        </div>
      `;

      // N√≠veis de decis√£o (GARCH 18P) ‚Äî tipografia do print
const g = (ts.analyzeSystemGARCH()||{}).p18;
const up1 = g?.up1sigma, dn1 = g?.down1sigma;

// helper local para 2 casas (sem mexer em escala)
const F2 = v => (Number.isFinite(v) ? Number(v).toFixed(2) : "--");

lv.innerHTML = `
  <div class="nd-wrap">
    <h4 class="nd-title">üß∑ N√≠veis de Decis√£o</h4>
    <div class="nd-row">
      <div class="nd-pill">
        <div class="nd-label red">RESIST√äNCIA FORTE</div>
        <div class="nd-value">${F2(up1)}</div>
      </div>
      <div class="nd-pill">
        <div class="nd-label green">SUPORTE FORTE</div>
        <div class="nd-value">${F2(dn1)}</div>
      </div>
    </div>
  </div>
`;


    };

    // re-render autom√°tico
    hookAfter(ts, "performAIAnalysis", ()=>{ try{ ts.renderStrategyPanel(); }catch(_){} });
    hookAfter(ts, "updateAIDisplay",   ()=>{ try{ ts.renderStrategyPanel(); }catch(_){} });
    setTimeout(()=>{ try{ ts.renderStrategyPanel(); }catch(_){} }, 200);
  } // apply(ts)

  function hookAfter(obj, method, after){
    try{
      if (typeof obj[method] !== "function") return;
      const orig = obj[method].bind(obj);
      obj[method] = function(){ const r = orig.apply(obj, arguments); try{ after(); }catch(_){ } return r; };
    }catch(_){}
  }
})();
</script>

	
<style>

/* layout vertical para os n√≠veis (+1œÉ / -1œÉ) */
.level-col {
  display: grid;
  grid-template-columns: 1fr;  /* sempre 1 por linha */
  gap: 10px;
}

/* reaproveita o mesmo ‚Äúcardzinho‚Äù de n√≠vel, mas ocupando 100% */
.level-col .level {
  text-align: center;
  padding: 12px 10px;
  background: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
}

/* s√≥ um charme: t√≠tulos em p√≠lula */
.level-col .title {
  display:inline-block;
  padding: 2px 8px;
  border-radius: 10px;
  font-weight: 800;
  font-size: 12px;
  margin-bottom: 6px;
}
.level-col .badge-red   { background:#fee2e2; color:#991b1b; }
.level-col .badge-green { background:#dcfce7; color:#065f46; }
.level-col .value { font-size: 18px; font-weight: 900; }

  .card-grid { display:grid; gap:12px; }
  .card { border-radius:14px; padding:14px 16px; border:1px solid #e5e7eb; background:#fff; }
  .card h4 { margin:0 0 8px; font-size:15px; }
  .card p  { margin:4px 0; font-size:13px; line-height:1.4; }
  .card-success { background: linear-gradient(180deg,#ecfdf5,#ffffff); border-color:#86efac; }
  .card-danger  { background: linear-gradient(180deg,#fef2f2,#ffffff); border-color:#fca5a5; }
  .card-info    { background: linear-gradient(180deg,#eff6ff,#ffffff); border-color:#93c5fd; }
  .badge { display:inline-block; padding:2px 8px; border-radius:10px; font-weight:700; font-size:11px; }
  .badge-red{background:#fee2e2;color:#991b1b}.badge-green{background:#dcfce7;color:#065f46}
  .level-box{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .level{text-align:center;padding:12px 10px;background:#fff;border:1px solid #e5e7eb;border-radius:12px}
  .level .title{font-weight:800;font-size:13px;margin-bottom:8px}
  .level .value{font-size:18px;font-weight:900}
  
  /* ‚Äî‚Äî N√≠veis de Decis√£o (tipografia do print) ‚Äî‚Äî */
.nd-wrap { background:#eef6ff; border-radius:12px; padding:14px; }
.nd-title { font-weight:800; color:#2563eb; margin:0 0 10px; font-size:14px; display:flex; align-items:center; gap:8px; }
.nd-row { display:grid; grid-template-columns:1fr 1fr; gap:12px; }

.nd-pill {
  background:#fff; border:1px solid #e5e7eb; border-radius:12px;
  padding:12px 10px; text-align:center;
  box-shadow:0 1px 0 rgba(0,0,0,.02);
}
.nd-label { font-weight:900; font-size:12px; letter-spacing:.3px; margin-bottom:6px; }
.nd-label.red { color:#ef4444; }      /* RESIST√äNCIA */
.nd-label.green { color:#059669; }    /* SUPORTE    */
.nd-value { font-size:18px; font-weight:900; color:#0f172a; }
@media(max-width:480px){ .nd-row{ grid-template-columns:1fr; } }

</style>



</body>