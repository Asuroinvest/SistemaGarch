<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sistema Quant Pro - G√™nesis Trading</title>
  <style>
    :root{
      --primary-gradient: linear-gradient(135deg, #4f46e5, #7c3aed, #06b6d4);
      --bg: #f8fafc;
      --panel: #ffffff;
      --panel-2: #f1f5f9;
      --text: #1e293b;
      --muted: #64748b;
      --accent: #3b82f6;
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
      --border: #e2e8f0;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --ai-gradient: linear-gradient(135deg, #8b5cf6, #06b6d4);
      --ai-bg: linear-gradient(145deg, #f0f9ff, #e0f2fe);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
    }
    
    header {
      padding: 16px 20px;
      background: var(--primary-gradient);
      color: white;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: var(--shadow-lg);
    }
    
    @media(min-width:768px){header{padding:24px;}}
    
    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .title {
      font-size: 18px;
      font-weight: 800;
      letter-spacing: -.5px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    @media(min-width:768px){.title{font-size:24px;gap:12px;}}
    
    .sub {
      color: rgba(255,255,255,0.9);
      font-size: 12px;
      margin-top: 6px;
      font-weight: 400;
      line-height: 1.4;
    }
    
    @media(min-width:768px){.sub{font-size:14px;}}
    
    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .user-name {
      font-weight: 600;
      font-size: 14px;
    }
    
    .status-badge {
      background: rgba(255,255,255,0.2);
      color: white;
      padding: 4px 8px;
      border-radius: 20px;
      font-size: 10px;
      font-weight: 600;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    @media(min-width:768px){.status-badge{padding:4px 12px;font-size:11px;}}
    
    .logout-btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .logout-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-1px);
    }
    
    main {
      padding: 16px;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    @media(min-width:768px){main{padding:32px 24px;}}
    
    .main-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    @media(min-width:1024px){
      .main-grid{
        grid-template-columns: 1fr 300px;
        gap: 24px;
      }
    }
    
    .content-area {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    @media(min-width:1200px){
      .content-area{
        grid-template-columns: 1.2fr 0.8fr;
        gap: 24px;
      }
    }
    
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    
    @media(min-width:768px){.panel{border-radius:20px;padding:24px;}}
    
    .ai-panel {
      background: var(--ai-bg);
      border: 2px solid #06b6d4;
      position: relative;
      overflow: hidden;
    }
    
    .ai-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--ai-gradient);
    }
    
    h2.section-title {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-title {
      background: var(--ai-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .muted {
      color: var(--muted);
    }
    
    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    
    @media(min-width:480px){.toolbar{gap:12px;}}
    
    .btn {
      background: var(--panel-2);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 12px 16px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: var(--shadow);
    }
    
    .btn:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }
    
    .btn.primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    
    .btn.ai {
      background: var(--ai-gradient);
      color: white;
      border: none;
    }
    
    .btn.success {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .periods {
      display: flex;
      gap: 6px;
      margin: 8px 0 16px;
      flex-wrap: wrap;
    }
    
    @media(min-width:480px){.periods{gap:8px;}}
    
    .tab {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      background: var(--panel-2);
      font-size: 12px;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: var(--shadow);
    }
    
    @media(min-width:480px){.tab{padding:10px 16px;font-size:13px;}}
    
    .tab.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    
    .cards {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    @media(min-width:480px){.cards{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media(min-width:768px){.cards{grid-template-columns:repeat(3,minmax(0,1fr));}}
    @media(min-width:1024px){.cards{grid-template-columns:repeat(4,minmax(0,1fr));}}
    
    .fair-price-cards {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    @media(min-width:480px){.fair-price-cards{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media(min-width:768px){.fair-price-cards{grid-template-columns:repeat(4,minmax(0,1fr));}}
    
    .card {
      background: linear-gradient(145deg, #ffffff, #f8fafc);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--accent), var(--success));
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .card:hover::before {
      opacity: 1;
    }
    
    .card.up-card {
      background: linear-gradient(145deg, #f0fdf4, #dcfce7);
      border-color: #bbf7d0;
    }
    
    .card.down-card {
      background: linear-gradient(145deg, #fef2f2, #fee2e2);
      border-color: #fecaca;
    }
    
    .card.neutral-card {
      background: linear-gradient(145deg, #f1f5f9, #e2e8f0);
      border-color: #cbd5e1;
    }
    
    .label {
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .5px;
      margin-bottom: 8px;
      line-height: 1.3;
    }
    
    .value {
      font-size: 18px;
      font-weight: 900;
      letter-spacing: -.5px;
      line-height: 1.2;
    }
    
    @media(min-width:480px){.value{font-size:20px;}}
    @media(min-width:768px){.value{font-size:22px;}}
    
    .value.up {
      color: var(--success);
    }
    
    .value.down {
      color: var(--error);
    }
    
    .inputs {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 12px;
      margin: 12px 0 16px;
    }
    
    @media(min-width:480px){.inputs{grid-template-columns:repeat(3,minmax(0,1fr));}}
    
    .input {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      box-shadow: var(--shadow);
    }
    
    .input label {
      display: block;
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: .5px;
    }
    
    .input input, .input select {
      width: 100%;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      padding: 10px;
      font-weight: 600;
    }
    
    .hint {
      font-size: 12px;
      color: var(--muted);
      font-weight: 500;
    }
    
    .api-config {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin: 16px 0;
    }
    
    .api-status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }
    
    .api-status.connected {
      background: #dcfce7;
      color: #166534;
    }
    
    .api-status.disconnected {
      background: #fee2e2;
      color: #991b1b;
    }
    
    .api-status.testing {
      background: #fef3c7;
      color: #92400e;
    }
    
    .sep {
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--border), transparent);
      margin: 24px 0;
    }
    
    textarea {
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      resize: vertical;
      box-shadow: var(--shadow);
    }
    
    input[type="file"] {
      color: var(--text);
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      width: 100%;
      box-shadow: var(--shadow);
    }
    
    .debug {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin: 12px 0;
      font-size: 11px;
      color: var(--muted);
      font-family: monospace;
      box-shadow: var(--shadow);
    }
    
    .maxmin-grid {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 12px;
    }
    
    @media(min-width:480px){.maxmin-grid{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media(min-width:768px){.maxmin-grid{grid-template-columns:repeat(3,minmax(0,1fr));gap:16px;}}
    
    footer {
      color: var(--muted);
      text-align: center;
      padding: 32px;
      font-size: 12px;
      font-weight: 600;
      margin-top: 40px;
      border-top: 1px solid var(--border);
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(248, 250, 252, 0.8);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid var(--border);
      border-top: 4px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .welcome-banner {
      background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
      border: 1px solid #7dd3fc;
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 24px;
      text-align: center;
    }
    
    .welcome-banner h3 {
      color: var(--accent);
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    .welcome-banner p {
      color: var(--muted);
      font-size: 14px;
    }
    
    .api-info {
      background: var(--panel-2);
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
      font-size: 11px;
      line-height: 1.4;
    }
    
    .provider-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin: 12px 0;
    }
    
    .provider-card {
      background: var(--panel);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }
    
    .provider-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .provider-card.active {
      border-color: var(--accent);
      background: linear-gradient(145deg, #f0f9ff, #dbeafe);
    }
    
    .provider-card h4 {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 4px;
      color: var(--text);
    }
    
    .provider-card p {
      font-size: 11px;
      color: var(--muted);
    }

    .frp-highlight {
      background: #fff3cd !important;
      border-color: #f59e0b !important;
    }

    .frp-disabled {
      background: #f8f9fa !important;
      opacity: 0.7;
    }
    
    /* AI-specific styles */
    .ai-insights {
      display: grid;
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .insight-card {
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #06b6d4;
      border-radius: 12px;
      padding: 16px;
      transition: all 0.3s;
    }
    
    .insight-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .insight-title {
      font-weight: 700;
      color: #0369a1;
      margin-bottom: 8px;
      font-size: 14px;
    }
    
    .insight-content {
      font-size: 13px;
      line-height: 1.5;
      color: var(--text);
    }
    
    .opportunity-score {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 16px 0;
    }
    
    .score-circle {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--ai-gradient);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      box-shadow: var(--shadow-lg);
      transition: all 0.5s ease;
    }
    
    .score-circle.buy-signal {
      background: linear-gradient(135deg, #10b981, #059669, #047857);
      box-shadow: 0 10px 15px -3px rgba(16, 185, 129, 0.3);
    }
    
    .score-circle.sell-signal {
      background: linear-gradient(135deg, #ef4444, #dc2626, #b91c1c);
      box-shadow: 0 10px 15px -3px rgba(239, 68, 68, 0.3);
    }
    
    .score-circle.neutral-signal {
      background: linear-gradient(135deg, #3b82f6, #2563eb, #1d4ed8);
      box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3);
    }
    
    .score-circle.wait-signal {
      background: linear-gradient(135deg, #f59e0b, #d97706, #b45309);
      box-shadow: 0 10px 15px -3px rgba(245, 158, 11, 0.3);
    }
    
    .score-value {
      font-size: 24px;
      font-weight: 900;
    }
    
    .score-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .scenario-bars {
      display: grid;
      gap: 12px;
    }
    
    .scenario {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .scenario-label {
      flex: 0 0 140px;
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
    }
    
    .probability-bar {
      flex: 1;
      height: 20px;
      background: var(--panel-2);
      border-radius: 10px;
      position: relative;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: var(--ai-gradient);
      border-radius: 10px;
      transition: width 0.5s ease;
    }
    
    .percentage {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 11px;
      font-weight: 600;
      color: var(--text);
    }
    
    .alerts-container {
      display: grid;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .alert-item {
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.4;
      border-left: 4px solid;
      margin-bottom: 4px;
    }
    
    .alert-item strong {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
    }
    
    .alert-item em {
      font-size: 11px;
      opacity: 0.8;
      display: block;
      margin-top: 4px;
    }
    
    .alert-item.warning {
      background: #fef3c7;
      border-color: #f59e0b;
      color: #92400e;
    }
    
    .alert-item.success {
      background: #dcfce7;
      border-color: #10b981;
      color: #166534;
    }
    
    .alert-item.info {
      background: #e0f2fe;
      border-color: #06b6d4;
      color: #0369a1;
    }
    
    .ai-narrative {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #06b6d4;
      border-radius: 12px;
      padding: 16px;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text);
    }
    
    .ai-narrative h4 {
      color: #0369a1;
      margin-bottom: 12px;
      font-size: 14px;
    }
    
    .ai-narrative p {
      margin-bottom: 10px;
    }
    
    .ai-narrative strong {
      color: var(--text);
    }
    
    /* Advanced metrics styles */
    .advanced-metrics {
	display: grid;
	grid-template-columns: repeat(2, 1fr); /* Sempre 2 colunas */
	gap: 12px;
	margin: 16px 0;
	}

	/* Para telas muito pequenas, usar 1 coluna */
	@media(max-width: 480px){
	.advanced-metrics{
    grid-template-columns: repeat(1, 1fr);
	}
	}
    
    .metric-card-advanced {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .metric-value-advanced {
      font-size: 18px;
      font-weight: 900;
      margin-bottom: 4px;
      color: var(--accent);
    }
    
    .metric-label-advanced {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    #apiConfigInputs {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    
    #apiConfigInputs .input input,
    #apiConfigInputs .input select {
      width: 100%;
      font-size: 14px;
      padding: 12px 14px;
    }
    
    @media (max-width: 480px) {
      .cards, .fair-price-cards {
        grid-template-columns: 1fr;
      }
      
      .maxmin-grid {
        grid-template-columns: 1fr;
      }
      
      .inputs {
        grid-template-columns: 1fr;
      }
      
      .toolbar {
        flex-direction: column;
        align-items: stretch;
      }
      
      .btn {
        text-align: center;
      }
      
      .provider-grid {
        grid-template-columns: 1fr;
      }
      
      .main-grid {
        grid-template-columns: 1fr;
      }
      
      .content-area {
        grid-template-columns: 1fr;
      }
      
      .advanced-metrics {
        grid-template-columns: 1fr;
      }
    }
  </style>

<style id="vwap-card-css">
  #aiStrategyPanel .vwap-card{ background:#eef6ff; border:1px solid var(--border); border-radius:16px; padding:14px; margin:8px 0 14px; }
  .vwap-head{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .vwap-title{ font-weight:900; font-size:15px; }
  .vwap-sub{ color: var(--muted); font-size:12px; font-weight:700; }
  .vwap-grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(190px,1fr)); gap:12px; margin-top:10px; }
  .vwap-field{ display:flex; flex-direction:column; gap:6px; }
  .vwap-label{ font-size:12px; color: var(--muted); font-weight:800; }
  .vwap-box{ display:flex; align-items:center; gap:8px; border:1px solid var(--border); background:#fff; border-radius:12px; padding:8px 10px; box-shadow:0 1px 0 rgba(0,0,0,.02); }
  .vwap-chip{ width:24px; height:24px; border-radius:9999px; display:inline-flex; align-items:center; justify-content:center; font-weight:900; background:var(--panel-2); color:var(--text); border:1px solid var(--border); font-size:12px; }
  .vwap-box input[disabled]{ background:transparent; border:0; outline:0; font-weight:900; font-variant-numeric: tabular-nums; color:#0f172a; }
</style>

</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
  </div>
  
  <header>
    <div class="header-content">
      <div>
        <div class="title">Sistema Quant Pro</div>
        <div class="sub">An√°lise Avan√ßada de Contratos Futuros DOL com IA Multidimensional</div>
      </div>
      <div class="user-info">
        <div class="user-name" id="userName">Carregando...</div>
        <div class="status-badge">CONECTADO</div>
        <button class="logout-btn" id="logoutBtn">Sair</button>
      </div>
    </div>
  </header>

  <main>
    <div class="welcome-banner">
      <h3>Sistema IA Avan√ßado Inicializado com Sucesso!</h3>
      <p>Configure sua API ou use dados simulados para an√°lise multidimensional com detec√ß√£o de regime de mercado.</p>
    </div>
    
    <div class="main-grid">
      <div class="content-area">
        <section class="panel" id="proj-panel">
          <h2 class="section-title">Proje√ß√µes para Contratos Futuros</h2>
          <div class="toolbar">
            <button class="btn primary" id="btnFetchAPI">Dados via API</button>
            <button class="btn" id="btnFetch">Dados Simulados</button>
            <button class="btn" id="btnAnalyze">An√°lise Avan√ßada</button>
            <button class="btn ai" id="btnAIAnalysis">An√°lise IA Multidimensional</button>
            <span class="hint" id="dataStatus">aguardando dados‚Ä¶</span>
            <span class="api-status disconnected" id="apiStatus">API: Desconectado</span>
          </div>

          <div class="periods" id="forecastTabs">
            <div class="tab active" data-period="9">1¬™ Proje√ß√£o (9P)</div>
            <div class="tab" data-period="18">2¬™ Proje√ß√£o (18P)</div>
            <div class="tab" data-period="27">3¬™ Proje√ß√£o (27P)</div>
          </div>

          <div class="cards" id="forecastCards">
            <div class="card up-card"><div class="label">Proje√ß√£o +1œÉ</div><div class="value up" id="f_up1">--</div></div>
            <div class="card down-card"><div class="label">Proje√ß√£o -1œÉ</div><div class="value down" id="f_dn1">--</div></div>
            <div class="card up-card"><div class="label">Proje√ß√£o +2œÉ</div><div class="value up" id="f_up2">--</div></div>
            <div class="card down-card"><div class="label">Proje√ß√£o -2œÉ</div><div class="value down" id="f_dn2">--</div></div>
          </div>

          <div class="sep"></div>

          <h2 class="section-title">M√°ximas e M√≠nimas Intraday</h2>
          <div class="inputs">
            <div class="input">
              <label for="frp">FRP - Forward Rate Premium (%)</label>
              <input id="frp" type="number" step="0.01" value="15.50" placeholder="Ex: 15.50 para Selic" />
              <div class="hint">Juros impl√≠citos para converter Spot ‚Üí Futuro</div>
            </div>
            <div class="input">
              <label for="dataType">Tipo de Dados</label>
              <select id="dataType">
                <option value="spot">Spot USD/BRL (API)</option>
                <option value="future">Futuro DOL (Excel)</option>
              </select>
            </div>
            <div class="input">
              <label for="maturityDays">Vencimento (dias)</label>
              <input id="maturityDays" type="number" value="30" min="1" max="365" />
              <div class="hint">Para c√°lculo preciso do FRP</div>
            </div>
          </div>

          <div class="inputs">
            <div class="input">
              <label for="exp9">Fator EXP 9P</label>
              <input id="exp9" type="number" step="0.1" value="2.718" />
            </div>
            <div class="input">
              <label for="exp18">Fator EXP 18P</label>
              <input id="exp18" type="number" step="0.1" value="2.718" />
            </div>
            <div class="input">
              <label for="exp27">Fator EXP 27P</label>
              <input id="exp27" type="number" step="0.1" value="2.718" />
            </div>
          </div>

          <div class="periods" id="intradayTabs">
            <div class="tab active" data-iperiod="9">1¬™ Proje√ß√£o</div>
            <div class="tab" data-iperiod="18">2¬™ Proje√ß√£o </div>
            <div class="tab" data-iperiod="27">3¬™ Proje√ß√£o </div>
          </div>

          <div class="cards">
            <div class="card up-card"><div class="label">M√°xima Intraday</div><div class="value up" id="i_max">--</div></div>
            <div class="card down-card"><div class="label">M√≠nima Intraday</div><div class="value down" id="i_min">--</div></div>
            <div class="card neutral-card"><div class="label">Fechamento Base</div><div class="value" id="i_close">--</div></div>
            <div class="card neutral-card"><div class="label">œÉ Retornos (%)</div><div class="value" id="i_sigma">--</div></div>
          </div>

          <div class="debug" id="debugInfo">
            Debug: aguardando c√°lculos...
          </div>

          <div class="sep"></div>

          <h2 class="section-title">Poss√≠veis M√°ximas e M√≠nimas</h2>
          <div class="cards maxmin-grid">
            <div class="card up-card"><div class="label">M√°xima 1P </div><div class="value up" id="max_9p">--</div></div>
            <div class="card up-card"><div class="label">M√°xima 2P </div><div class="value up" id="max_18p">--</div></div>
            <div class="card up-card"><div class="label">M√°xima 3P </div><div class="value up" id="max_27p">--</div></div>
            <div class="card down-card"><div class="label">M√≠nima 1P </div><div class="value down" id="min_9p">--</div></div>
            <div class="card down-card"><div class="label">M√≠nima 2P </div><div class="value down" id="min_18p">--</div></div>
            <div class="card down-card"><div class="label">M√≠nima 3P </div><div class="value down" id="min_27p">--</div></div>
          </div>

          <div class="sep"></div>

          <h2 class="section-title">Pre√ßo Justo e Just√≠ssimo do D√≥lar</h2>
          
          <div class="fair-price-cards">
            <div class="card up-card"><div class="label">Pre√ßo Justo PPP</div><div class="value" id="fair_ppp">--</div></div>
            <div class="card up-card"><div class="label">Pre√ßo Justo UIP</div><div class="value" id="fair_uip">--</div></div>
            <div class="card neutral-card"><div class="label">Pre√ßo Just√≠ssimo</div><div class="value" id="fair_combined">--</div></div>
            <div class="card down-card"><div class="label">Desvio do Justo (%)</div><div class="value" id="deviation_fair">--</div></div>
          </div>

          <div class="fair-price-cards">
            <div class="card neutral-card"><div class="label">Diferencial Juros</div><div class="value" id="interest_diff">--</div></div>
            <div class="card neutral-card"><div class="label">Diferencial Infla√ß√£o</div><div class="value" id="inflation_diff">--</div></div>
            <div class="card neutral-card"><div class="label">Fator Risco Ajustado</div><div class="value" id="risk_factor">--</div></div>
            <div class="card neutral-card"><div class="label">Tend√™ncia 30D</div><div class="value" id="trend_30d">--</div></div>
          </div>

          <div class="inputs">
            <div class="input">
              <label for="ppp_rate">Taxa PPP Base (R$)</label>
              <input id="ppp_rate" type="number" step="0.01" value="5.20" />
              <div class="hint">Paridade do Poder de Compra hist√≥rica</div>
            </div>
            <div class="input">
              <label for="inflation_br">Infla√ß√£o Brasil (%aa)</label>
              <input id="inflation_br" type="number" step="0.1" value="4.5" />
              <div class="hint">IPCA acumulado 12 meses</div>
            </div>
            <div class="input">
              <label for="inflation_us">Infla√ß√£o EUA (%aa)</label>
              <input id="inflation_us" type="number" step="0.1" value="5.2" />
              <div class="hint">CPI acumulado 12 meses</div>
            </div>
          </div>

          <div class="inputs">
            <div class="input">
              <label for="selic_rate">Taxa Selic (%aa)</label>
              <input id="selic_rate" type="number" step="0.25" value="15.50" />
            </div>
            <div class="input">
              <label for="fed_rate">Taxa Fed (%aa)</label>
              <input id="fed_rate" type="number" step="0.25" value="5.50" />
            </div>
            <div class="input">
              <label for="risk_premium">Pr√™mio de Risco (%)</label>
              <input id="risk_premium" type="number" step="0.1" value="2.5" />
              <div class="hint">Risco pa√≠s + volatilidade</div>
            </div>
          </div>

          <div class="sep"></div>

          <h2 class="section-title">Indicadores Adicionais</h2>
          <div class="cards">
            <div class="card neutral-card"><div class="label">Retorno Linear Atual</div><div class="value" id="ret_current">--</div></div>
            <div class="card neutral-card"><div class="label">Desvio 9P (%)</div><div class="value" id="std9">--</div></div>
            <div class="card neutral-card"><div class="label">Desvio 18P (%)</div><div class="value" id="std18">--</div></div>
            <div class="card neutral-card"><div class="label">Desvio 27P (%)</div><div class="value" id="std27">--</div></div>
            <div class="card neutral-card"><div class="label">Exp(œÉ9) Factor</div><div class="value" id="exp_std9">--</div></div>
            <div class="card neutral-card"><div class="label">Exp(œÉ18) Factor</div><div class="value" id="exp_std18">--</div></div>
            <div class="card neutral-card"><div class="label">Exp(œÉ27) Factor</div><div class="value" id="exp_std27">--</div></div>
          </div>

        </section>

        <section class="panel ai-panel" id="ai-analysis-panel">
          <h2 class="section-title ai-title">An√°lise IA Multidimensional</h2>
          
          <!-- M√©tricas Avan√ßadas -->
          <div class="advanced-metrics">
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="advancedConfidenceDisplay">--</div>
              <div class="metric-label-advanced">Confian√ßa Multi</div>
            </div>
            
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="marketRegimeDisplay">--</div>
              <div class="metric-label-advanced">Regime</div>
            </div>
            
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="confluenceDisplay">--</div>
              <div class="metric-label-advanced">Conflu√™ncia</div>
            </div>
            
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="riskRewardDisplay">--</div>
              <div class="metric-label-advanced">Risk/Reward</div>
            </div>
          </div>
          
          <div class="ai-insights">
            <div class="insight-card">
              <div class="insight-title">Situa√ß√£o Atual</div>
              <div class="insight-content" id="aiCurrentSituation">
                Execute 'An√°lise IA' para insights multidimensionais...
              </div>
            </div>
            
            <div class="opportunity-score">
              <div class="score-circle">
                <span class="score-value" id="opportunityScore">--</span>
                <span class="score-label">Score</span>
              </div>
            </div>
            
            <div class="insight-card">
              <div class="insight-title">Estrat√©gia Operacional</div>
              <div class="insight-content" id="aiMainRecommendation">
                Aguardando an√°lise de regime de mercado...
              </div>
            </div>
          </div>

          <div class="alerts-container" id="aiAlerts" style="display: none;">
            <!-- Alerts will be populated by JS -->
          </div>

          <div class="ai-narrative" id="aiNarrative" style="display: none;">
            <!-- Narrative analysis will be populated by JS -->
          </div>

          <div class="sep"></div>

          <h3 style="font-size: 14px; margin-bottom: 12px;">Cen√°rios Probabil√≠sticos (24h)</h3>
          <div class="scenario-bars" id="aiScenarios">
            <div class="scenario">
              <span class="scenario-label">Alta Forte (>+2%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Alta Moderada (+1%/+2%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Lateral (-1%/+1%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Baixa Moderada (-2%/-1%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Baixa Forte (<-2%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
          </div>
          <div class="sep"></div>		  
		  <div class="panel" id="aiStrategyPanel">
			<div id="vwapCard" class="vwap-card">
				<div class="vwap-head">
					<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" style="opacity:.85">
						<path d="M3 13h2v-2H3v2zm4 0h14v-2H7v2zm0 6h14v-2H7v2zM3 5v2h2V5H3zm4 2h14V5H7v2z"></path>
					</svg>
					<span class="vwap-title">VWAP (D/S/M)</span>
					<span class="vwap-sub">opcional ¬∑ auto da planilha</span>
				</div>
				<div class="vwap-grid">
					<label class="vwap-field"><span class="vwap-label">VWAP D</span><div class="vwap-box"><span class="vwap-chip">D</span><input id="vwapD" type="text" readonly disabled placeholder="‚Äî" /></div></label>
					<label class="vwap-field"><span class="vwap-label">VWAP S</span><div class="vwap-box"><span class="vwap-chip">S</span><input id="vwapS" type="text" readonly disabled placeholder="‚Äî" /></div></label>
					<label class="vwap-field"><span class="vwap-label">VWAP M</span><div class="vwap-box"><span class="vwap-chip">M</span><input id="vwapM" type="text" readonly disabled placeholder="‚Äî" /></div></label>
				</div>
				<div class="vwap-tips">Lemos as colunas <b>VWAP D</b>, <b>VWAP S</b>, <b>VWAP M</b> da √∫ltima linha da planilha.</div>
			</div>

			<h2 class="section-title">‚ö° Estrat√©gia Recomendada</h2>

			<div id="aiOperation" class="insight-card"></div>
			<div id="aiRisk" class="insight-card"></div>
			<div id="aiLevels" class="insight-card"></div>
		</div>
        </section>
      </div>

      <aside class="panel">
        <h2 class="section-title">Configura√ß√£o de APIs</h2>
        
        <!-- API Provider Selection -->
        <div class="api-config">
          <h3 style="font-size: 14px; margin-bottom: 12px;">Provedores de Dados:</h3>
          <div class="provider-grid">
            <div class="provider-card active" data-provider="alpha_vantage">
              <h4>Alpha Vantage</h4>
              <p><strong>RECOMENDADO</strong><br>25 calls/dia gr√°tis<br>USD/BRL dispon√≠vel</p>
            </div>
            <div class="provider-card" data-provider="yahoo_finance">
              <h4>Yahoo Finance</h4>
              <p>Gratuito (com limita√ß√µes)<br>Precisa de proxy CORS</p>
            </div>
            <div class="provider-card" data-provider="polygon">
              <h4>Polygon.io</h4>
              <p>5 calls/min gr√°tis<br>Dados profissionais</p>
            </div>
            <div class="provider-card" data-provider="tradier">
              <h4>Tradier</h4>
              <p>Sandbox gratuito<br>Live data premium</p>
            </div>
          </div>
        </div>

        <!-- API Configuration -->
        <div class="inputs" id="apiConfigInputs">
          <div class="input">
            <label for="apiKey">API Key Alpha Vantage</label>
            <input id="apiKey" type="password" placeholder="Cole sua chave aqui ou digite 'demo'" />
          </div>
          <div class="input">
            <label for="symbol">Par de Moedas</label>
            <input id="symbol" type="text" value="USD/BRL" placeholder="USD/BRL (fixo)" readonly style="background: #f8f9fa;" />
          </div>
          <div class="input">
            <label for="interval">Intervalo</label>
            <select id="interval">
              <option value="daily">Di√°rio (Recomendado)</option>
              <option value="weekly">Semanal</option>
              <option value="monthly">Mensal</option>
            </select>
          </div>
        </div>

        <div class="api-info" style="margin: 12px 0; padding: 12px; background: linear-gradient(135deg, #f0fdf4, #dcfce7); border-radius: 8px;">
          <h4 style="color: #166534; margin-bottom: 8px;">Sistema FRP (Forward Rate Premium)</h4>
          <div style="font-size: 12px; line-height: 1.6; color: #374151;">
            <p><strong>Dados de Excel (DOL Futuro):</strong> J√° incorporam juros, usar "Futuro DOL"</p>
            <p><strong>Dados da API (Spot USD/BRL):</strong> Configurar FRP para converter</p>
            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; padding: 8px; margin-top: 8px; font-size: 11px;">
              üí° <strong>FRP Sugerido:</strong> Use ~13.75% (Selic atual) para convers√£o spot‚Üífuturo
            </div>
          </div>
        </div>

        <div class="api-info" style="margin: 12px 0; padding: 12px; background: linear-gradient(135deg, #f0f9ff, #e0f2fe); border-radius: 8px;">
          <h4 style="color: #0369a1; margin-bottom: 8px;">üîß Solu√ß√£o para Problemas de CORS:</h4>
          <div style="font-size: 12px; line-height: 1.6; color: #374151;">
            <p><strong>Se der erro de "Resposta inv√°lida":</strong></p>
            <ol style="padding-left: 16px; margin: 8px 0;">
              <li>Use <code style="background: #f3f4f6; padding: 2px 4px; border-radius: 3px;">demo</code> como API Key</li>
              <li>Clique "üîç Testar API" (vai funcionar em modo demo)</li>
              <li>Clique "üì° Dados via API" (carregar√° dados real√≠sticos)</li>
            </ol>
            <p><strong>Para API Key real:</strong></p>
            <ol style="padding-left: 16px; margin: 8px 0;">
              <li><strong>Cadastre-se GR√ÅTIS:</strong> <a href="https://www.alphavantage.co/support/#api-key" target="_blank" style="color: #0369a1;">alphavantage.co/support/#api-key</a></li>
              <li><strong>Receba</strong> API key por email</li>
              <li><strong>Cole aqui</strong> e teste</li>
            </ol>
          </div>
          <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; padding: 8px; margin-top: 8px; font-size: 11px;">
            üí° <strong>IMPORTANTE:</strong> Mesmo com erro de CORS, o sistema funciona perfeitamente com dados demo real√≠sticos!
          </div>
        </div>

        <div class="toolbar" style="margin-top: 16px;">
          <button class="btn success" id="btnTestAPI">üîç Testar API</button>
          <button class="btn" id="btnSaveAPIConfig">üíæ Salvar Config</button>
        </div>

        <div class="api-info">
          <strong>Provedor Ativo:</strong> <span id="activeProvider">Alpha Vantage</span><br>
          <strong>Status:</strong> <span id="connectionStatus">Desconectado</span><br>
          <strong>√öltima Atualiza√ß√£o:</strong> <span id="lastUpdate">Nunca</span><br>
          <strong>Dados Dispon√≠veis:</strong> <span id="dataCount">0</span> registros
        </div>

        <div class="sep"></div>

        <!-- Manual Data Input -->
        <h3 style="font-size: 14px; margin-bottom: 8px;">Dados Manuais (Backup)</h3>
        <div class="hint">Cole abaixo fechamentos (um por linha) se quiser testar manualmente:</div>
        <textarea id="manualData" rows="6" style="width:100%;margin-top:8px;" placeholder="5500.00&#10;5510.25&#10;5505.80&#10;..."></textarea>
        <div class="toolbar" style="margin-top:10px">
          <button class="btn" id="btnLoadManual">Carregar Fechamentos</button>
          <button class="btn" id="btnClear">Limpar</button>
        </div>

        <div class="sep"></div>
        
        <!-- Excel Import -->
        <div class="hint">Importar Fechamentos do Excel:</div>
        <div style="font-size:11px;color:var(--muted);margin:4px 0;">
          Aceita formatos: <br>
          ‚Ä¢ Coluna √∫nica com pre√ßos (A1: 5437, A2: 5485.5...)<br>
          ‚Ä¢ Planilha completa (detecta coluna "Fechamento" automaticamente)
        </div>
        <input type="file" id="fileUpload" accept=".xlsx,.xls" />

        <div class="sep"></div>
        <div class="hint">Status:</div>
        <div class="muted" id="log">Pronto para uso - Configure uma API para dados em tempo real</div>
      </aside>
    </div>
  </main>

  <footer>Deivitti Almir - G√™nesis Trading</footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
    class TradingSystemWithAI {
      constructor() {
        this.priceData = [];
        this.linearReturns = [];
        this.currentForecastP = 9;
        this.currentIntradayP = 9;
        this.apiConfig = {
          provider: 'alpha_vantage',
          apiKey: '',
          symbol: 'USDBRL=X',
          interval: '1d'
        };
        this.apiConnected = false;
        this.aiAnalysis = null;
        
        this.initUserSession();
        this.init();
      }
      
      initUserSession() {
        try {
          const userData = sessionStorage.getItem('currentUser');
          if (userData) {
            const user = JSON.parse(userData);
            const userNameElement = document.getElementById('userName');
            if (userNameElement) {
              userNameElement.textContent = user.name || 'Usu√°rio';
            }
            
            if (user.system !== 'garch') {
              console.warn('Usu√°rio n√£o tem acesso ao sistema GARCH');
              if (user.system === 'quant') {
                this.log('‚ö†Ô∏è Redirecionando para Sistema QUANT...');
                setTimeout(() => {
                  window.location.href = 'dashboard-quant.html';
                }, 2000);
              }
            }
            
            console.log('Usu√°rio logado:', user.name, 'Sistema:', user.system);
            this.log(`‚úÖ Bem-vindo, ${user.name}! Sistema GARCH com IA inicializado.`);
            
          } else {
            console.warn('Nenhum usu√°rio logado encontrado');
            this.log('‚ö†Ô∏è Sess√£o n√£o encontrada. Redirecionando...');
            setTimeout(() => {
              window.location.href = 'index.html';
            }, 3000);
          }
        } catch (error) {
          console.error('Erro ao carregar dados do usu√°rio:', error);
          this.log('‚ùå Erro ao carregar sess√£o. Redirecionando...');
          setTimeout(() => {
            window.location.href = 'index.html';
          }, 3000);
        }
      }
      
      checkSessionValidity() {
        try {
          const userData = sessionStorage.getItem('currentUser');
          if (userData) {
            const user = JSON.parse(userData);
            const loginTime = user.loginTime || 0;
            const sessionTimeout = 4 * 60 * 60 * 1000;
            
            if (Date.now() - loginTime > sessionTimeout) {
              alert('Sua sess√£o expirou. Fa√ßa login novamente.');
              sessionStorage.removeItem('currentUser');
              window.location.href = 'index.html';
              return false;
            }
          } else {
            this.log('‚ö†Ô∏è Sess√£o perdida. Redirecionando para login...');
            setTimeout(() => {
              window.location.href = 'index.html';
            }, 2000);
            return false;
          }
          return true;
        } catch (error) {
          console.error('Erro ao verificar sess√£o:', error);
          return false;
        }
      }
      
      init() {
        this.loadAPIConfig();
        this.wireEventListeners();
        this.wireExpInputs();
        this.updateAPIInfo();
        this.updateDataTypeUI();
        this.initializeAI();
        
        setInterval(() => {
          this.checkSessionValidity();
        }, 5 * 60 * 1000);
      }
      
      // ========================================
      // NOVAS FUN√á√ïES DE IA AVAN√áADA
      // ========================================
      
      // 1. SCORE DE CONFIAN√áA MULTIDIMENSIONAL
      calculateAdvancedConfidenceScore() {
        let totalScore = 0;
        let totalWeight = 0;
        
        // Componente GARCH (peso 30)
        const garchScore = this.calculateGARCHConfidenceComponent();
        totalScore += garchScore * 30;
        totalWeight += 30;
        
        // Componente Pre√ßo Justo (peso 25)
        const fairPriceScore = this.calculateFairPriceConfidenceComponent();
        totalScore += fairPriceScore * 25;
        totalWeight += 25;
        
        // Componente Volatilidade (peso 20)
        const volScore = this.calculateVolatilityConfidenceComponent();
        totalScore += volScore * 20;
        totalWeight += 20;
        
        // Componente Momentum (peso 15)
        const momentumScore = this.calculateMomentumConfidenceComponent();
        totalScore += momentumScore * 15;
        totalWeight += 15;
        
        // Componente Conflu√™ncia (peso 10)
        const confluenceScore = this.calculateConfluenceComponent();
        totalScore += confluenceScore * 10;
        totalWeight += 10;
        
        return Math.round(totalScore / totalWeight);
      }
      
      calculateGARCHConfidenceComponent() {
        const periods = [9, 18, 27];
        let consistency = 0;
        let validPeriods = 0;
        
        const currentPrice = this.lastClose();
        if (!isFinite(currentPrice)) return 30;
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          if (!isFinite(stdDev)) return;
          
          validPeriods++;
          const up1sigma = currentPrice * (1 + stdDev);
          const down1sigma = currentPrice * (1 - stdDev);
          
          // Maior pontua√ß√£o quando pre√ßo est√° pr√≥ximo das bandas
          if (currentPrice > up1sigma || currentPrice < down1sigma) {
            consistency += 80;
          } else {
            const distanceFromBands = Math.min(
              Math.abs(currentPrice - up1sigma) / currentPrice,
              Math.abs(currentPrice - down1sigma) / currentPrice
            );
            consistency += Math.max(20, 80 - (distanceFromBands * 1000));
          }
        });
        
        return validPeriods > 0 ? consistency / validPeriods : 30;
      }
      
      calculateFairPriceConfidenceComponent() {
        const fairAnalysis = this.analyzeSystemFairPrice();
        if (!fairAnalysis.valid) return 30;
        
        const deviation = fairAnalysis.deviationAbs;
        
        // Quanto maior o desvio, maior a confian√ßa na dire√ß√£o
        if (deviation > 10) return 95;
        if (deviation > 8) return 85;
        if (deviation > 5) return 70;
        if (deviation > 3) return 50;
        if (deviation > 1) return 35;
        return 20;
      }
      
      calculateVolatilityConfidenceComponent() {
        const vol18 = this.calculateStdDevReturns(18) * 100;
        if (!isFinite(vol18)) return 50;
        
        // Volatilidade ideal entre 1.5% e 2.5%
        if (vol18 >= 1.5 && vol18 <= 2.5) return 90;
        if (vol18 < 1.0) return 60; // Muito baixa
        if (vol18 > 4.0) return 20; // Muito alta
        if (vol18 > 3.0) return 40;
        return 70;
      }
      
      calculateMomentumConfidenceComponent() {
        const mom9 = this.calculateMomentum(9);
        const mom18 = this.calculateMomentum(18);
        const mom27 = this.calculateMomentum(27);
        
        if (!isFinite(mom9) || !isFinite(mom18) || !isFinite(mom27)) return 40;
        
        // Momentum consistente em todas as janelas = alta confian√ßa
        if ((mom9 > 0 && mom18 > 0 && mom27 > 0) || 
            (mom9 < 0 && mom18 < 0 && mom27 < 0)) {
          return 85;
        }
        
        // Diverg√™ncias = menor confian√ßa
        const directions = [mom9 > 0, mom18 > 0, mom27 > 0];
        const consistent = directions.filter(d => d === directions[0]).length;
        
        return Math.max(25, consistent * 30);
      }
      
      calculateMomentum(periods) {
        if (this.priceData.length < periods + 1) return NaN;
        
        const recent = this.priceData.slice(-periods);
        const older = this.priceData.slice(-(periods * 2), -periods);
        
        if (recent.length === 0 || older.length === 0) return NaN;
        
        const recentAvg = recent.reduce((sum, p) => sum + p, 0) / recent.length;
        const olderAvg = older.reduce((sum, p) => sum + p, 0) / older.length;
        
        return ((recentAvg - olderAvg) / olderAvg) * 100;
      }
      
      calculateConfluenceComponent() {
        const garchAnalysis = this.analyzeSystemGARCH();
        const fairAnalysis = this.analyzeSystemFairPrice();
        
        if (!fairAnalysis.valid || !garchAnalysis.p18) return 50;
        
        const currentPrice = this.lastClose();
        const fairPrice = fairAnalysis.fairPriceCombined;
        const garch18 = garchAnalysis.p18;
        
        let confluenceScore = 50;
        
        // Conflu√™ncia: pre√ßo alto + acima GARCH + acima justo
        if (currentPrice > fairPrice && currentPrice > garch18.up1sigma) {
          confluenceScore = 90;
        }
        // Conflu√™ncia: pre√ßo baixo + abaixo GARCH + abaixo justo  
        else if (currentPrice < fairPrice && currentPrice < garch18.down1sigma) {
          confluenceScore = 90;
        }
        // Diverg√™ncia: sinais conflitantes
        else if ((currentPrice > fairPrice && currentPrice < garch18.down1sigma) ||
                 (currentPrice < fairPrice && currentPrice > garch18.up1sigma)) {
          confluenceScore = 25;
        }
        
        return confluenceScore;
      }
      
      // 2. DETEC√á√ÉO DE REGIME DE MERCADO
      detectMarketRegime() {
        const fairAnalysis = this.analyzeSystemFairPrice();
        const volAnalysis = this.analyzeSystemVolatility();
        const garchAnalysis = this.analyzeSystemGARCH();
        
        if (!fairAnalysis.valid || !volAnalysis.p18 || !garchAnalysis.p18) {
          return {
            type: 'UNDEFINED',
            confidence: 'LOW',
            description: 'Dados insuficientes para determinar regime',
            probability: 50
          };
        }
        
        const deviation = fairAnalysis.deviationPercent;
        const vol18 = volAnalysis.p18.volatilityPercent;
        const currentPrice = this.lastClose();
        const garch18 = garchAnalysis.p18;
        
        // Regime de REVERS√ÉO √Ä M√âDIA
        if (Math.abs(deviation) > 6 && vol18 < 3.0) {
          const direction = deviation > 0 ? 'BAIXISTA' : 'ALTISTA';
          const probability = Math.min(85, Math.abs(deviation) * 8 + (3.0 - vol18) * 10);
          
          return {
            type: 'MEAN_REVERSION',
            direction: direction,
            confidence: 'HIGH',
            description: `Revers√£o √† m√©dia ${direction.toLowerCase()} detectada. Desvio ${Math.abs(deviation).toFixed(1)}% com volatilidade controlada (${vol18.toFixed(2)}%).`,
            probability: Math.round(probability),
            expectedDuration: '2-5 preg√µes'
          };
        }
        
        // Regime de ALTA VOLATILIDADE
        if (vol18 > 4.0) {
          return {
            type: 'HIGH_VOLATILITY',
            confidence: 'HIGH',
            description: `Volatilidade extrema (${vol18.toFixed(2)}%). Mercado imprevis√≠vel, evitar trades direcionais.`,
            probability: 75,
            expectedDuration: 'Indefinido - aguardar normaliza√ß√£o'
          };
        }
        
        // Regime de BREAKOUT
        if (garch18 && ((currentPrice > garch18.up2sigma) || (currentPrice < garch18.down2sigma))) {
          const direction = currentPrice > garch18.up2sigma ? 'ALTISTA' : 'BAIXISTA';
          return {
            type: 'BREAKOUT',
            direction: direction,
            confidence: 'MEDIUM',
            description: `Poss√≠vel breakout ${direction.toLowerCase()}. Pre√ßo al√©m de ¬±2œÉ GARCH.`,
            probability: 65,
            expectedDuration: '1-3 preg√µes'
          };
        }
        
        // Regime LATERAL
        return {
          type: 'LATERAL',
          confidence: 'MEDIUM', 
          description: `Mercado em equil√≠brio. Desvio: ${Math.abs(deviation).toFixed(1)}%, Vol: ${vol18.toFixed(2)}%.`,
          probability: 60,
          expectedDuration: 'Aguardar catalisador'
        };
      }
      
      // 3. ALERTAS CONTEXTUALIZADOS E HIERARQUIZADOS
      generateAdvancedAlerts() {
        const alerts = [];
        const regime = this.detectMarketRegime();
        const fairAnalysis = this.analyzeSystemFairPrice();
        const garchAnalysis = this.analyzeSystemGARCH();
        const volAnalysis = this.analyzeSystemVolatility();
        const confluence = this.calculateConfluenceComponent();
        
        // ALERTAS CR√çTICOS (A√ß√£o imediata)
        if (regime.type === 'MEAN_REVERSION' && regime.confidence === 'HIGH' && confluence > 80) {
          alerts.push({
            level: 'CRITICAL',
            type: 'success',
            icon: 'üö®',
            title: 'OPORTUNIDADE DE ALTA PROBABILIDADE',
            message: `${regime.description} Conflu√™ncia t√©cnica: ${confluence}%. A√á√ÉO RECOMENDADA: ${regime.direction === 'BAIXISTA' ? 'VENDA' : 'COMPRA'} direcional.`,
            action: 'Considerar entrada imediata',
            confidence: regime.probability
          });
        }
        
        if (volAnalysis.p18 && volAnalysis.p18.volatilityPercent > 4.5) {
          alerts.push({
            level: 'CRITICAL',
            type: 'warning',
            icon: '‚ö†Ô∏è',
            title: 'VOLATILIDADE EXTREMA',
            message: `Volatilidade em ${volAnalysis.p18.volatilityPercent.toFixed(2)}% - ZONA PERIGOSA. Evitar novas posi√ß√µes at√© normaliza√ß√£o.`,
            action: 'Reduzir exposi√ß√£o imediatamente',
            confidence: 90
          });
        }
        
        // ALERTAS IMPORTANTES (Aten√ß√£o redobrada)
        if (garchAnalysis.p18) {
          const currentPrice = this.lastClose();
          if (currentPrice > garchAnalysis.p18.up2sigma) {
            alerts.push({
              level: 'IMPORTANT',
              type: 'warning',
              icon: 'üìà',
              title: 'SOBRECOMPRA ESTAT√çSTICA',
              message: `Pre√ßo ${((currentPrice/garchAnalysis.p18.up2sigma - 1) * 100).toFixed(1)}% acima de +2œÉ GARCH (${this.fmt(garchAnalysis.p18.up2sigma)}). Press√£o de venda esperada.`,
              action: 'Monitorar revers√£o',
              confidence: 70
            });
          } else if (currentPrice < garchAnalysis.p18.down2sigma) {
            alerts.push({
              level: 'IMPORTANT', 
              type: 'info',
              icon: 'üìâ',
              title: 'SOBREVENDA ESTAT√çSTICA',
              message: `Pre√ßo ${((1 - currentPrice/garchAnalysis.p18.down2sigma) * 100).toFixed(1)}% abaixo de -2œÉ GARCH (${this.fmt(garchAnalysis.p18.down2sigma)}). Press√£o de compra esperada.`,
              action: 'Monitorar recupera√ß√£o',
              confidence: 70
            });
          }
        }
        
        if (fairAnalysis.valid && fairAnalysis.deviationAbs > 8) {
          alerts.push({
            level: 'IMPORTANT',
            type: fairAnalysis.deviationPercent > 0 ? 'warning' : 'info',
            icon: fairAnalysis.deviationPercent > 0 ? 'üí∞' : 'üî•',
            title: fairAnalysis.deviationPercent > 0 ? 'SOBREVALORIZA√á√ÉO SEVERA' : 'SUBVALORIZA√á√ÉO SEVERA',
            message: `Desvio de ${fairAnalysis.deviationAbs.toFixed(1)}% do pre√ßo just√≠ssimo (${this.fmt(fairAnalysis.fairPriceCombined)}). ${fairAnalysis.severityLevel} probabilidade de revers√£o.`,
            action: `Preparar ${fairAnalysis.deviationPercent > 0 ? 'venda' : 'compra'}`,
            confidence: Math.min(85, fairAnalysis.deviationAbs * 8)
          });
        }
        
        // ALERTAS INFORMATIVOS
        if (confluence > 75) {
          alerts.push({
            level: 'INFO',
            type: 'success',
            icon: '‚úÖ',
            title: 'CONFLU√äNCIA T√âCNICA FORTE',
            message: `M√∫ltiplos indicadores apontam mesma dire√ß√£o (${confluence}% conflu√™ncia). Sinal consistente.`,
            action: 'Considerar aumento de posi√ß√£o',
            confidence: confluence
          });
        } else if (confluence < 40) {
          alerts.push({
            level: 'INFO',
            type: 'info',
            icon: 'ü§î',
            title: 'SINAIS CONFLITANTES',
            message: `Indicadores divergindo (${confluence}% conflu√™ncia). Aguardar defini√ß√£o de dire√ß√£o.`,
            action: 'Aguardar confirma√ß√£o',
            confidence: 100 - confluence
          });
        }
        
        // Ordenar por prioridade
        const priority = { 'CRITICAL': 3, 'IMPORTANT': 2, 'INFO': 1 };
        alerts.sort((a, b) => priority[b.level] - priority[a.level] || b.confidence - a.confidence);
        
        return alerts.slice(0, 5); // M√°ximo 5 alertas
      }
      
      // 4. ESTRAT√âGIA OPERACIONAL ESPEC√çFICA
      generateTradingStrategy() {
        const regime = this.detectMarketRegime();
        const fairAnalysis = this.analyzeSystemFairPrice();
        const garchAnalysis = this.analyzeSystemGARCH();
        const intradayAnalysis = this.analyzeSystemIntraday();
        const confidence = this.calculateAdvancedConfidenceScore();
        
        if (!fairAnalysis.valid || !garchAnalysis.p18 || !intradayAnalysis.p18) {
          return {
            recommendation: 'AGUARDAR',
            reason: 'Dados insuficientes para estrat√©gia operacional',
            confidence: 30
          };
        }
        
        const currentPrice = this.lastClose();
        const garch18 = garchAnalysis.p18;
        const intraday18 = intradayAnalysis.p18;
        const vol18 = this.analyzeSystemVolatility().p18?.volatilityPercent || 2.0;
        
        let strategy = {
          recommendation: 'MONITORAR',
          direction: null,
          entryZone: { min: 0, max: 0 },
          target: 0,
          stopLoss: 0,
          positionSize: 'NORMAL',
          timeframe: '1-3 preg√µes',
          confidence: confidence,
          riskReward: 0
        };
        
        // ESTRAT√âGIA PARA REVERS√ÉO √Ä M√âDIA
        if (regime.type === 'MEAN_REVERSION' && confidence > 70) {
          if (regime.direction === 'BAIXISTA') {
            // Entrada de VENDA
            strategy.recommendation = 'VENDA DIRECIONAL';
            strategy.direction = 'SELL';
            strategy.entryZone = { 
              min: Math.max(currentPrice * 0.998, garch18.up1sigma * 0.999),
              max: Math.min(currentPrice * 1.005, garch18.up2sigma)
            };
            strategy.target = Math.max(
              fairAnalysis.fairPriceCombined * 1.02,
              intraday18.minIntraday * 1.01
            );
            strategy.stopLoss = Math.min(
              currentPrice * 1.015,
              garch18.up2sigma * 1.005
            );
            
          } else {
            // Entrada de COMPRA
            strategy.recommendation = 'COMPRA DIRECIONAL';
            strategy.direction = 'BUY';
            strategy.entryZone = {
              min: Math.max(currentPrice * 0.995, garch18.down2sigma),
              max: Math.min(currentPrice * 1.002, garch18.down1sigma * 1.001)
            };
            strategy.target = Math.min(
              fairAnalysis.fairPriceCombined * 0.98,
              intraday18.maxIntraday * 0.99
            );
            strategy.stopLoss = Math.max(
              currentPrice * 0.985,
              garch18.down2sigma * 0.995
            );
          }
          
          strategy.timeframe = '2-5 preg√µes';
        }
        
        // AJUSTE DE TAMANHO DE POSI√á√ÉO BASEADO EM VOLATILIDADE
        if (vol18 > 3.0) {
          strategy.positionSize = 'REDUZIDA (50-70%)';
        } else if (vol18 < 1.5 && confidence > 80) {
          strategy.positionSize = 'AUMENTADA (120-150%)';
        } else if (confidence > 85) {
          strategy.positionSize = 'NORMAL+ (110%)';
        }
        
        // C√ÅLCULO RISK/REWARD
        if (strategy.target > 0 && strategy.stopLoss > 0 && currentPrice > 0) {
          const potentialGain = Math.abs(strategy.target - currentPrice) / currentPrice;
          const potentialLoss = Math.abs(strategy.stopLoss - currentPrice) / currentPrice;
          strategy.riskReward = potentialLoss > 0 ? potentialGain / potentialLoss : 0;
        }
        
        return strategy;
      }
		renderStrategyPanel() {
		const strategy = this.generateTradingStrategy();
		const operationDiv = document.getElementById("aiOperation");
		const riskDiv = document.getElementById("aiRisk");
		const levelsDiv = document.getElementById("aiLevels");

		if (!operationDiv || !riskDiv || !levelsDiv) return;

  // 1. Opera√ß√£o sugerida
  operationDiv.innerHTML = `
    <strong>OPERA√á√ÉO SUGERIDA</strong><br>
    ${strategy.recommendation}<br>
    <em>Entrada: ${strategy.entryZone.min.toFixed(2)} ‚Äì ${strategy.entryZone.max.toFixed(2)}</em><br>
    üéØ Meta: ${strategy.target.toFixed(2)}<br>
    üõë Stop Loss: ${strategy.stopLoss.toFixed(2)}<br>
    ‚è≥ Prazo: ${strategy.timeframe}<br>
    üìä Confian√ßa: ${strategy.confidence}%
  `;

  // 2. Gest√£o de Risco
  riskDiv.innerHTML = `
    <strong>GEST√ÉO DE RISCO</strong><br>
    Cen√°rio adverso: rompimento pode levar a ${ (strategy.stopLoss * 1.01).toFixed(2) }<br>
    Gatilho de sa√≠da: Volatilidade > 3.5% ou perda de conflu√™ncia<br>
    Hedge sugerido: Put protection se exposi√ß√£o > R$ 100k
  `;

  // 3. Suporte e Resist√™ncia
  const garch = this.analyzeSystemGARCH();
  if (garch.p18) {
    levelsDiv.innerHTML = `
      <strong>N√çVEIS DE DECIS√ÉO</strong><br>
      Resist√™ncia forte: ${garch.p18.up1sigma.toFixed(2)}<br>
      Suporte forte: ${garch.p18.down1sigma.toFixed(2)}
    `;
  }
}

      
      // FUN√á√ïES AUXILIARES PARA AS MELHORIAS
      determineSignalTypeFromStrategy(strategy) {
        if (strategy.recommendation.includes('VENDA')) return 'sell';
        if (strategy.recommendation.includes('COMPRA')) return 'buy';
        if (strategy.recommendation.includes('AGUARDAR')) return 'wait';
        return 'neutral';
      }
      
      adjustScenariosForRegime(baseScenarios, regime) {
        let scenarios = { ...baseScenarios };
        
        if (regime.type === 'MEAN_REVERSION') {
          if (regime.direction === 'BAIXISTA') {
            scenarios.strongDown = Math.min(40, scenarios.strongDown + 20);
            scenarios.moderateDown = Math.min(35, scenarios.moderateDown + 15);
            scenarios.strongUp = Math.max(5, scenarios.strongUp - 15);
            scenarios.lateral = Math.max(10, scenarios.lateral - 20);
          } else if (regime.direction === 'ALTISTA') {
            scenarios.strongUp = Math.min(40, scenarios.strongUp + 20);
            scenarios.moderateUp = Math.min(35, scenarios.moderateUp + 15);
            scenarios.strongDown = Math.max(5, scenarios.strongDown - 15);
            scenarios.lateral = Math.max(10, scenarios.lateral - 20);
          }
        } else if (regime.type === 'HIGH_VOLATILITY') {
          scenarios.lateral = Math.max(50, scenarios.lateral + 20);
          scenarios.strongUp = Math.max(5, scenarios.strongUp - 10);
          scenarios.strongDown = Math.max(5, scenarios.strongDown - 10);
        }
        
        return scenarios;
      }
      
      generateEnhancedNarrativeWithRegime(regime, strategy, confidence) {
        const currentPrice = this.lastClose();
        const fairAnalysis = this.analyzeSystemFairPrice();
        
        return `
          <h4>AN√ÅLISE GARCH-IA AVAN√áADA - ${new Date().toLocaleDateString('pt-BR')}</h4>
          
          <p><strong>REGIME IDENTIFICADO: ${regime.type}</strong><br>
          ${regime.description} Probabilidade: ${regime.probability}%</p>
          
          <p><strong>ESTRAT√âGIA OPERACIONAL:</strong><br>
          ${strategy.recommendation} | Confian√ßa Multidimensional: ${confidence}%<br>
          ${strategy.direction ? `Zona de Entrada: ${this.fmt(strategy.entryZone.min)} - ${this.fmt(strategy.entryZone.max)}` : ''}<br>
          ${strategy.target > 0 ? `Meta Prim√°ria: ${this.fmt(strategy.target)} | Stop Loss: ${this.fmt(strategy.stopLoss)}` : ''}<br>
          ${strategy.riskReward > 0 ? `Risk/Reward: 1:${strategy.riskReward.toFixed(1)} | Tamanho: ${strategy.positionSize}` : ''}</p>
          
          <p><strong>CONFLU√äNCIA T√âCNICA:</strong><br>
          Pre√ßoJusto: ${fairAnalysis.valid ? this.fmt(fairAnalysis.fairPriceCombined) : 'N/D'} | 
          Desvio: ${fairAnalysis.valid ? fairAnalysis.deviationPercent.toFixed(1) + '%' : 'N/D'}<br>
          Conflu√™ncia: ${this.calculateConfluenceComponent()}% | 
          Timeframe: ${strategy.timeframe}</p>
          
          <p><strong>GEST√ÉO DE RISCO:</strong><br>
          ${confidence > 80 ? '‚úÖ ALTA confian√ßa - Opera√ß√£o recomendada' : 
            confidence > 60 ? '‚ö†Ô∏è M√âDIA confian√ßa - Aguardar confirma√ß√£o' : 
            '‚ùå BAIXA confian√ßa - Evitar trades direcionais'}</p>
        `;
      }
      
      updateAdvancedMetricsDisplay() {
        if (!this.aiAnalysis) {
          document.getElementById('advancedConfidenceDisplay').textContent = '--';
          document.getElementById('marketRegimeDisplay').textContent = '--';
          document.getElementById('confluenceDisplay').textContent = '--';
          document.getElementById('riskRewardDisplay').textContent = '--';
          return;
        }
        
        // Atualizar displays das m√©tricas avan√ßadas
        const advancedConfidence = this.calculateAdvancedConfidenceScore();
        const regime = this.detectMarketRegime();
        const confluence = this.calculateConfluenceComponent();
        const strategy = this.generateTradingStrategy();
        
        document.getElementById('advancedConfidenceDisplay').textContent = advancedConfidence + '%';
        document.getElementById('marketRegimeDisplay').textContent = regime.type;
        document.getElementById('confluenceDisplay').textContent = confluence + '%';
        document.getElementById('riskRewardDisplay').textContent = strategy.riskReward > 0 ? 
          '1:' + strategy.riskReward.toFixed(1) : '--';
      }
      
      // ========================================
      // FIM DAS NOVAS FUN√á√ïES DE IA AVAN√áADA  
      // ========================================
      
      // Fun√ß√£o para determinar o tipo de sinal baseado na recomenda√ß√£o
      determineSignalType(recommendation) {
        if (!recommendation || typeof recommendation !== 'string') {
          return 'neutral';
        }
        
        const recText = recommendation.toLowerCase();
        
        // Sinais de COMPRA (Verde)
        if (recText.includes('compra') || 
            recText.includes('comprar') ||
            recText.includes('subvalorizada') ||
            recText.includes('aten√ß√£o para compras') ||
            recText.includes('forte recomenda√ß√£o de compra') ||
            recText.includes('recomenda√ß√£o de compra') ||
            recText.includes('oportunidade de compra')) {
          return 'buy';
        }
        
        // Sinais de VENDA (Vermelho)
        if (recText.includes('venda') || 
            recText.includes('vender') ||
            recText.includes('sobrevalorizada') ||
            recText.includes('aten√ß√£o para vendas') ||
            recText.includes('forte recomenda√ß√£o de venda') ||
            recText.includes('recomenda√ß√£o de venda') ||
            recText.includes('oportunidade de venda')) {
          return 'sell';
        }
        
        // Sinais de AGUARDAR (Laranja)
        if (recText.includes('aguardar') || 
            recText.includes('aguarde') ||
            recText.includes('volatilidade extrema') ||
            recText.includes('evitar trades') ||
            recText.includes('aguardar redu√ß√£o') ||
            recText.includes('aguardar normaliza√ß√£o')) {
          return 'wait';
        }
        
        // Neutro/Monitorar (Azul) - padr√£o
        return 'neutral';
      }
      
      // Fun√ß√£o para atualizar a cor do c√≠rculo de score
      updateScoreCircleColor(signalType) {
        const scoreCircle = document.querySelector('.score-circle');
        if (!scoreCircle) {
          console.warn('Score circle element not found');
          return;
        }
        
        // Remove todas as classes de cor existentes
        scoreCircle.classList.remove('buy-signal', 'sell-signal', 'neutral-signal', 'wait-signal');
        
        // Adiciona a classe apropriada baseada no sinal
        switch(signalType) {
          case 'buy':
            scoreCircle.classList.add('buy-signal');
            console.log('Score circle: BUY signal (green)');
            break;
          case 'sell':
            scoreCircle.classList.add('sell-signal');
            console.log('Score circle: SELL signal (red)');
            break;
          case 'wait':
            scoreCircle.classList.add('wait-signal');
            console.log('Score circle: WAIT signal (orange)');
            break;
          case 'neutral':
          default:
            scoreCircle.classList.add('neutral-signal');
            console.log('Score circle: NEUTRAL signal (blue)');
            break;
        }
      }
      
      initializeAI() {
        // Initialize AI analysis display
        this.updateAIDisplay();
      }
      
      wireEventListeners() {
        document.getElementById('btnFetch').addEventListener('click', () => this.fetchSimulatedData());
        document.getElementById('btnFetchAPI').addEventListener('click', () => this.fetchAPIData());
        document.getElementById('btnAnalyze').addEventListener('click', () => this.analyze());
		document.getElementById('btnAIAnalysis').addEventListener('click', () => {
			this.performAIAnalysis();
			this.renderStrategyPanel();
		});        
		document.getElementById('btnLoadManual').addEventListener('click', () => this.loadManualData());
        document.getElementById('btnClear').addEventListener('click', () => this.clearData());
        document.getElementById('logoutBtn').addEventListener('click', () => this.logout());
        
        document.getElementById('btnTestAPI').addEventListener('click', () => this.testAPIConnection());
        document.getElementById('btnSaveAPIConfig').addEventListener('click', () => this.saveAPIConfig());
        
        document.querySelectorAll('.provider-card').forEach(card => {
          card.addEventListener('click', () => {
            const provider = card.dataset.provider;
            this.selectProvider(provider);
          });
        });
        
        document.querySelectorAll('#forecastTabs .tab').forEach(tab => {
          tab.addEventListener('click', () => {
            const period = parseInt(tab.dataset.period);
            this.switchForecastPeriod(period);
          });
        });
        
        document.querySelectorAll('#intradayTabs .tab').forEach(tab => {
          tab.addEventListener('click', () => {
            const period = parseInt(tab.dataset.iperiod);
            this.switchIntradayPeriod(period);
          });
        });
        
        document.getElementById('fileUpload').addEventListener('change', (e) => this.handleFileUpload(e));
        
        ['apiKey', 'symbol', 'interval'].forEach(id => {
          document.getElementById(id).addEventListener('input', () => {
            this.updateAPIConfigFromInputs();
          });
        });
      }
      
      wireExpInputs() {
        ['exp9', 'exp18', 'exp27', 'frp', 'maturityDays'].forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener('input', () => {
              this.calculateIntradayExtremes(this.currentIntradayP);
              this.updateExtras();
            });
          }
        });
        
        ['ppp_rate', 'inflation_br', 'inflation_us', 'selic_rate', 'fed_rate', 'risk_premium'].forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener('input', () => {
              this.calculateFairPrices();
            });
          }
        });
        
        const dataTypeSelect = document.getElementById('dataType');
        if (dataTypeSelect) {
          dataTypeSelect.addEventListener('change', () => {
            this.updateDataTypeUI();
            this.refreshAll();
          });
        }
      }
      
      // AI Analysis System - VERS√ÉO MELHORADA
      async performAIAnalysis() {
        if (!this.priceData.length) {
          this.log("Carregue dados primeiro para an√°lise com IA");
          return;
        }
        
        this.showLoading();
        this.log("Executando an√°lise inteligente multidimensional...");
        
        try {
          // Simulate AI processing time
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          // An√°lise original + melhorias
          this.aiAnalysis = this.generateAIAnalysis();
          
          // NOVA: Adicionar m√©tricas avan√ßadas
          this.aiAnalysis.advancedConfidence = this.calculateAdvancedConfidenceScore();
          this.aiAnalysis.marketRegime = this.detectMarketRegime();
          this.aiAnalysis.tradingStrategy = this.generateTradingStrategy();
          this.aiAnalysis.advancedAlerts = this.generateAdvancedAlerts();
          
          this.updateAIDisplay();
          
          this.log(`‚úÖ An√°lise IA avan√ßada conclu√≠da! Regime: ${this.aiAnalysis.marketRegime.type} | Confian√ßa: ${this.aiAnalysis.advancedConfidence}%`);
          
        } catch (error) {
          this.log("‚ùå Erro na an√°lise IA: " + error.message);
        } finally {
          this.hideLoading();
        }
      }
      
      // VERS√ÉO MELHORADA da fun√ß√£o updateAIDisplay()
      updateAIDisplay() {
        if (!this.aiAnalysis) {
          document.getElementById('aiCurrentSituation').textContent = "Execute 'An√°lise IA' para insights multidimensionais...";
          document.getElementById('aiMainRecommendation').textContent = "Aguardando an√°lise de regime de mercado...";
          document.getElementById('opportunityScore').textContent = "--";
          this.updateScoreCircleColor('neutral');
          this.updateAdvancedMetricsDisplay();
          return;
        }
        
        // Calcular m√©tricas avan√ßadas
        const advancedConfidence = this.calculateAdvancedConfidenceScore();
        const regime = this.detectMarketRegime();
        const advancedAlerts = this.generateAdvancedAlerts();
        const strategy = this.generateTradingStrategy();
        
        // Update main insights com dados mais ricos
        const enhancedSituation = `${this.aiAnalysis.currentSituation} | Regime: ${regime.type} (${regime.probability}%) | Confian√ßa: ${advancedConfidence}%`;
        document.getElementById('aiCurrentSituation').textContent = enhancedSituation;
        
        // Recomenda√ß√£o estrat√©gica melhorada
        let enhancedRecommendation = strategy.recommendation;
        if (strategy.direction) {
          enhancedRecommendation += ` | Entrada: ${this.fmt(strategy.entryZone.min)}-${this.fmt(strategy.entryZone.max)}`;
          enhancedRecommendation += ` | Meta: ${this.fmt(strategy.target)} | Stop: ${this.fmt(strategy.stopLoss)}`;
          enhancedRecommendation += ` | R/R: ${strategy.riskReward.toFixed(1)}x`;
        }
        document.getElementById('aiMainRecommendation').textContent = enhancedRecommendation;
        
        // Score com base na confian√ßa avan√ßada
        document.getElementById('opportunityScore').textContent = advancedConfidence;
        
        // Cor do c√≠rculo baseada na estrat√©gia
        const signalType = this.determineSignalTypeFromStrategy(strategy);
        this.updateScoreCircleColor(signalType);
        
        // Update alerts com sistema avan√ßado
        const alertsContainer = document.getElementById('aiAlerts');
        if (advancedAlerts && advancedAlerts.length > 0) {
          alertsContainer.innerHTML = '';
          advancedAlerts.forEach(alert => {
            const alertElement = document.createElement('div');
            alertElement.className = `alert-item ${alert.type}`;
            alertElement.innerHTML = `
              <strong>${alert.icon} ${alert.title}</strong>
              ${alert.message}
              <em>A√ß√£o: ${alert.action} (Confian√ßa: ${alert.confidence}%)</em>
            `;
            alertsContainer.appendChild(alertElement);
          });
          alertsContainer.style.display = 'grid';
        } else {
          alertsContainer.style.display = 'none';
        }
        
        // Update scenarios com probabilidades condicionais
        if (this.aiAnalysis.scenarios) {
          // Ajustar cen√°rios baseado no regime detectado
          const adjustedScenarios = this.adjustScenariosForRegime(this.aiAnalysis.scenarios, regime);
          
          const scenarios = document.querySelectorAll('#aiScenarios .scenario');
          const scenarioValues = [
            adjustedScenarios.strongUp,
            adjustedScenarios.moderateUp, 
            adjustedScenarios.lateral,
            adjustedScenarios.moderateDown,
            adjustedScenarios.strongDown
          ];
          
          scenarios.forEach((scenario, index) => {
            const barFill = scenario.querySelector('.bar-fill');
            const percentage = scenario.querySelector('.percentage');
            const value = scenarioValues[index] || 0;
            
            if (barFill && percentage) {
              barFill.style.width = `${value}%`;
              percentage.textContent = `${value}%`;
            }
          });
        }
        
        // Enhanced narrative com regime e estrat√©gia
        const narrativeContainer = document.getElementById('aiNarrative');
        if (narrativeContainer) {
          const enhancedNarrative = this.generateEnhancedNarrativeWithRegime(regime, strategy, advancedConfidence);
          narrativeContainer.innerHTML = enhancedNarrative;
          narrativeContainer.style.display = 'block';
        }
        
        // Atualizar m√©tricas avan√ßadas
        this.updateAdvancedMetricsDisplay();
      }
      
      // SUBSTITUA APENAS ESTAS FUN√á√ïES NO SEU SISTEMA ORIGINAL
      // Mantenha todo o resto igual, apenas cole estas fun√ß√µes sobre as existentes

      // Nova an√°lise de IA que usa os c√°lculos reais do seu sistema
      generateAIAnalysis() {
        const currentPrice = this.lastClose();
        const garchAnalysis = this.analyzeSystemGARCH();
        const intradayAnalysis = this.analyzeSystemIntraday();
        const fairPriceAnalysis = this.analyzeSystemFairPrice();
        const volatilityAnalysis = this.analyzeSystemVolatility();
        
        const analysis = {
          opportunityScore: this.calculateEnhancedOpportunityScore(garchAnalysis, fairPriceAnalysis, volatilityAnalysis),
          currentSituation: this.generateEnhancedSituation(currentPrice, garchAnalysis, fairPriceAnalysis),
          mainRecommendation: this.generateEnhancedRecommendation(garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis),
          alerts: this.generateEnhancedAlerts(garchAnalysis, fairPriceAnalysis, volatilityAnalysis),
          scenarios: this.calculateEnhancedScenarios(garchAnalysis, fairPriceAnalysis),
          narrative: this.generateEnhancedNarrative(currentPrice, garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis)
        };
        
        return analysis;
      }
      
      // An√°lise GARCH usando os c√°lculos reais do sistema
      analyzeSystemGARCH() {
        const currentPrice = this.lastClose();
        const periods = [9, 18, 27];
        const results = {};
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          if (isNaN(stdDev)) return;
          
          results[`p${period}`] = {
            stdDev: stdDev,
            stdDevPercent: stdDev * 100,
            up1sigma: currentPrice * (1 + stdDev),
            down1sigma: currentPrice * (1 - stdDev),
            up2sigma: currentPrice * (1 + 2 * stdDev),
            down2sigma: currentPrice * (1 - 2 * stdDev),
            currentInRange1: currentPrice >= (currentPrice * (1 - stdDev)) && currentPrice <= (currentPrice * (1 + stdDev)),
            distanceFromMean: Math.abs((currentPrice - currentPrice) / (currentPrice * stdDev))
          };
        });
        
        return results;
      }
      
      // An√°lise Intraday usando fatores EXP do sistema
      analyzeSystemIntraday() {
        const currentPrice = this.lastClose();
        const periods = [9, 18, 27];
        const results = {};
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          const expFactor = this.getExpFor(period);
          
          if (isNaN(stdDev)) return;
          
          const expStdDev = Math.pow(expFactor, stdDev);
          const maxIntraday = currentPrice * expStdDev;
          const minIntraday = currentPrice / expStdDev;
          
          results[`p${period}`] = {
            expFactor: expFactor,
            expStdDev: expStdDev,
            maxIntraday: maxIntraday,
            minIntraday: minIntraday,
            range: maxIntraday - minIntraday,
            rangePercent: ((maxIntraday - minIntraday) / currentPrice) * 100,
            potentialGain: ((maxIntraday - currentPrice) / currentPrice) * 100,
            potentialLoss: ((currentPrice - minIntraday) / currentPrice) * 100
          };
        });
        
        return results;
      }
      
      // An√°lise de Pre√ßo Justo usando f√≥rmulas PPP/UIP do sistema
      analyzeSystemFairPrice() {
        const currentPrice = this.lastClose();
        if (!isFinite(currentPrice) || currentPrice <= 0) {
          return { valid: false };
        }
        
        // Usar os valores dos inputs do sistema
        let pppRate = parseFloat(document.getElementById('ppp_rate')?.value || 5.30);
        const inflationBr = parseFloat(document.getElementById('inflation_br')?.value || 4.5) / 100;
        const inflationUs = parseFloat(document.getElementById('inflation_us')?.value || 3.2) / 100;
        const selicRate = parseFloat(document.getElementById('selic_rate')?.value || 13.75) / 100;
        const fedRate = parseFloat(document.getElementById('fed_rate')?.value || 5.50) / 100;
        const riskPremium = parseFloat(document.getElementById('risk_premium')?.value || 2.5) / 100;

        // Ajuste de escala (igual ao sistema original)
        if (currentPrice > 100) {
          pppRate = pppRate * 1000;
        }

        // C√°lculos PPP e UIP (igual ao sistema original)
        const inflationDifferential = inflationBr - inflationUs;
        const fairPricePPP = pppRate * ((1 + inflationBr) / (1 + inflationUs));

        const interestDifferential = selicRate - fedRate;
        const netInterestDifferential = interestDifferential - riskPremium;
        const uipAdjustmentFactor = 1 + (netInterestDifferential * 0.15);
        const fairPriceUIP = currentPrice * uipAdjustmentFactor;

        // Limites UIP (igual ao sistema original)
        const maxUIPDeviation = 0.20;
        const upperBoundUIP = currentPrice * (1 + maxUIPDeviation);
        const lowerBoundUIP = currentPrice * (1 - maxUIPDeviation);
        const boundedFairPriceUIP = Math.max(lowerBoundUIP, Math.min(upperBoundUIP, fairPriceUIP));

        // Pre√ßo combinado (igual ao sistema original)
        const weightPPP = 0.4;
        const weightUIP = 0.6;
        const fairPriceCombined = (fairPricePPP * weightPPP) + (boundedFairPriceUIP * weightUIP);

        // Limite total (igual ao sistema original)
        const maxTotalDeviation = 0.25;
        const upperBound = currentPrice * (1 + maxTotalDeviation);
        const lowerBound = currentPrice * (1 - maxTotalDeviation);
        const finalFairPrice = Math.max(lowerBound, Math.min(upperBound, fairPriceCombined));

        const deviationPercent = ((currentPrice - finalFairPrice) / finalFairPrice) * 100;
        
        return {
          valid: true,
          currentPrice: currentPrice,
          fairPricePPP: fairPricePPP,
          fairPriceUIP: boundedFairPriceUIP,
          fairPriceCombined: finalFairPrice,
          deviationPercent: deviationPercent,
          deviationAbs: Math.abs(deviationPercent),
          isOvervalued: deviationPercent > 5,
          isUndervalued: deviationPercent < -5,
          severityLevel: Math.abs(deviationPercent) > 10 ? 'EXTREMA' : 
                       Math.abs(deviationPercent) > 5 ? 'ALTA' : 'MODERADA',
          interestDifferential: interestDifferential,
          inflationDifferential: inflationDifferential,
          riskPremium: riskPremium
        };
      }
      
      // An√°lise de volatilidade por per√≠odo
      analyzeSystemVolatility() {
        const periods = [9, 18, 27];
        const results = {};
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          if (isNaN(stdDev)) return;
          
          const volPercent = stdDev * 100;
          let regime, riskLevel, tradingAdvice;
          
          if (volPercent > 3.0) {
            regime = 'ALTA';
            riskLevel = 'EXTREMO';
            tradingAdvice = 'Evitar trades direcionais';
          } else if (volPercent > 2.0) {
            regime = 'MODERADA-ALTA';
            riskLevel = 'ALTO';
            tradingAdvice = 'Reduzir tamanho de posi√ß√£o';
          } else if (volPercent > 1.0) {
            regime = 'MODERADA';
            riskLevel = 'M√âDIO';
            tradingAdvice = 'Condi√ß√µes normais de trading';
          } else {
            regime = 'BAIXA';
            riskLevel = 'BAIXO';
            tradingAdvice = 'Ideal para trades direcionais';
          }
          
          results[`p${period}`] = {
            period: period,
            volatilityPercent: volPercent,
            regime: regime,
            riskLevel: riskLevel,
            tradingAdvice: tradingAdvice,
            isLowVol: volPercent < 1.5,
            isHighVol: volPercent > 3.0
          };
        });
        
        return results;
      }
      
      // Score de oportunidade melhorado usando todos os c√°lculos do sistema
      calculateEnhancedOpportunityScore(garchAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        if (!fairPriceAnalysis.valid) return 30;
        
        let score = 50; // Base score
        
        // Componente: Desvio do pre√ßo justo (0-40 pontos)
        const deviation = fairPriceAnalysis.deviationAbs;
        const deviationScore = Math.min(40, deviation * 3);
        score += deviationScore;
        
        // Componente: Volatilidade (penaliza alta volatilidade)
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        if (vol18 < 1.5) {
          score += 15; // Baixa volatilidade √© boa
        } else if (vol18 > 3.0) {
          score -= 20; // Alta volatilidade penaliza
        }
        
        // Componente: Consist√™ncia entre per√≠odos GARCH
        const periods = [9, 18, 27];
        let consistentDirection = 0;
        const referencePrice = this.lastClose();
        
        periods.forEach(p => {
          const garch = garchAnalysis[`p${p}`];
          if (garch) {
            if (fairPriceAnalysis.deviationPercent > 5 && referencePrice > garch.up1sigma) {
              consistentDirection++; // Pre√ßo alto + acima de +1œÉ
            } else if (fairPriceAnalysis.deviationPercent < -5 && referencePrice < garch.down1sigma) {
              consistentDirection++; // Pre√ßo baixo + abaixo de -1œÉ
            }
          }
        });
        
        score += consistentDirection * 5;
        
        // Limitar entre 0-100
        return Math.max(0, Math.min(100, Math.round(score)));
      }
      
      // Situa√ß√£o atual melhorada
      generateEnhancedSituation(currentPrice, garchAnalysis, fairPriceAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return "Configure os par√¢metros de pre√ßo justo para an√°lise completa.";
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const garch18 = garchAnalysis.p18;
        
        let situation = `USD/BRL em ${this.fmt(currentPrice)}, `;
        
        // An√°lise de pre√ßo justo
        if (Math.abs(deviation) < 2) {
          situation += `pr√≥ximo ao just√≠ssimo (${this.fmt(fairPriceAnalysis.fairPriceCombined)}). `;
        } else if (deviation > 0) {
          situation += `${deviation.toFixed(1)}% ACIMA do just√≠ssimo (${this.fmt(fairPriceAnalysis.fairPriceCombined)}). `;
        } else {
          situation += `${Math.abs(deviation).toFixed(1)}% ABAIXO do just√≠ssimo (${this.fmt(fairPriceAnalysis.fairPriceCombined)}). `;
        }
        
        // An√°lise GARCH 18P
        if (garch18) {
          if (currentPrice > garch18.up1sigma) {
            situation += `Acima da banda +1œÉ GARCH (${this.fmt(garch18.up1sigma)}).`;
          } else if (currentPrice < garch18.down1sigma) {
            situation += `Abaixo da banda -1œÉ GARCH (${this.fmt(garch18.down1sigma)}).`;
          } else {
            situation += `Dentro das bandas GARCH ¬±1œÉ.`;
          }
        }
        
        return situation;
      }
      
      // Recomenda√ß√£o principal melhorada
      generateEnhancedRecommendation(garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return "Configure os par√¢metros do sistema para recomenda√ß√µes precisas.";
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        const garch18 = garchAnalysis.p18;
        const intraday18 = intradayAnalysis.p18;
        const currentPrice = this.lastClose();
        
        let recommendation = "";
        
        // L√≥gica principal baseada nos c√°lculos reais do sistema
        if (Math.abs(deviation) > 8 && vol18 < 2.5) {
          // Desvio extremo + baixa volatilidade = alta confian√ßa
          if (deviation > 8) {
            recommendation = `FORTE RECOMENDA√á√ÉO DE VENDA: Moeda ${deviation.toFixed(1)}% sobrevalorizada com volatilidade controlada (${vol18.toFixed(2)}%). `;
            
            if (garch18 && currentPrice > garch18.up1sigma) {
              recommendation += `GARCH confirma: pre√ßo acima de +1œÉ (${this.fmt(garch18.up1sigma)}). `;
            }
            
            if (intraday18) {
              recommendation += `Meta m√°xima intraday: ${this.fmt(intraday18.maxIntraday)}.`;
            }
          } else {
            recommendation = `FORTE RECOMENDA√á√ÉO DE COMPRA: Moeda ${Math.abs(deviation).toFixed(1)}% subvalorizada com volatilidade controlada (${vol18.toFixed(2)}%). `;
            
            if (garch18 && currentPrice < garch18.down1sigma) {
              recommendation += `GARCH confirma: pre√ßo abaixo de -1œÉ (${this.fmt(garch18.down1sigma)}). `;
            }
            
            if (intraday18) {
              recommendation += `Meta m√≠nima intraday: ${this.fmt(intraday18.minIntraday)}.`;
            }
          }
        } else if (Math.abs(deviation) > 5) {
          // Desvio moderado
          if (deviation > 5) {
            recommendation = `ATEN√á√ÉO PARA VENDAS: ${deviation.toFixed(1)}% sobrevalorizada. `;
          } else {
            recommendation = `ATEN√á√ÉO PARA COMPRAS: ${Math.abs(deviation).toFixed(1)}% subvalorizada. `;
          }
          
          if (vol18 > 3.0) {
            recommendation += `CUIDADO: Volatilidade alta (${vol18.toFixed(2)}%) pode causar falsos sinais. `;
          }
        } else if (vol18 > 4.0) {
          recommendation = `AGUARDAR: Volatilidade extrema (${vol18.toFixed(2)}%) domina. Aguardar normaliza√ß√£o. `;
        } else {
          recommendation = `MONITORAR: Situa√ß√£o equilibrada. Desvio: ${deviation.toFixed(1)}%, Vol: ${vol18.toFixed(2)}%. `;
          
          if (intraday18) {
            recommendation += `Range intraday esperado: ${this.fmt(intraday18.minIntraday)} - ${this.fmt(intraday18.maxIntraday)}.`;
          }
        }
        
        return recommendation;
      }
      
      // Alertas melhorados baseados nos c√°lculos do sistema
      generateEnhancedAlerts(garchAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        const alerts = [];
        
        if (!fairPriceAnalysis.valid) {
          alerts.push({
            type: 'info',
            message: 'Configure par√¢metros PPP/UIP para an√°lise completa do pre√ßo justo.'
          });
          return alerts;
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        const garch18 = garchAnalysis.p18;
        const currentPrice = this.lastClose();
        
        // Alertas de desvio extremo
        if (Math.abs(deviation) > 10) {
          alerts.push({
            type: 'warning',
            message: `DESVIO EXTREMO: ${Math.abs(deviation).toFixed(1)}% do pre√ßo just√≠ssimo! Revers√£o altamente prov√°vel.`
          });
        }
        
        // Alertas GARCH
        if (garch18) {
          if (currentPrice > garch18.up2sigma) {
            alerts.push({
              type: 'warning',
              message: `Pre√ßo acima de +2œÉ GARCH (${this.fmt(garch18.up2sigma)}). Zona de sobrecompra estat√≠stica.`
            });
          } else if (currentPrice < garch18.down2sigma) {
            alerts.push({
              type: 'warning',
              message: `Pre√ßo abaixo de -2œÉ GARCH (${this.fmt(garch18.down2sigma)}). Zona de sobrevenda estat√≠stica.`
            });
          }
        }
        
        // Alertas de volatilidade
        if (vol18 > 4.0) {
          alerts.push({
            type: 'warning',
            message: `VOLATILIDADE EXTREMA: ${vol18.toFixed(2)}%! Mercado imprevis√≠vel, evitar trades direcionais.`
          });
        } else if (vol18 < 1.0 && Math.abs(deviation) > 5) {
          alerts.push({
            type: 'success',
            message: `OPORTUNIDADE: Baixa volatilidade (${vol18.toFixed(2)}%) + desvio significativo = alta probabilidade de acerto.`
          });
        }
        
        // Alertas de conflu√™ncia
        if (Math.abs(deviation) > 5 && garch18) {
          const garchConfirms = (deviation > 0 && currentPrice > garch18.up1sigma) || 
                               (deviation < 0 && currentPrice < garch18.down1sigma);
          
          if (garchConfirms) {
            alerts.push({
              type: 'success',
              message: 'CONFLU√äNCIA: Pre√ßo justo e GARCH apontam mesma dire√ß√£o. Alta confiabilidade.'
            });
          } else {
            alerts.push({
              type: 'info',
              message: 'DIVERG√äNCIA: Pre√ßo justo e GARCH em conflito. Aguardar confirma√ß√£o.'
            });
          }
        }
        
        return alerts;
      }
      
      // Cen√°rios melhorados usando GARCH e pre√ßo justo
      calculateEnhancedScenarios(garchAnalysis, fairPriceAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return {
            strongUp: 20, moderateUp: 20, lateral: 20, moderateDown: 20, strongDown: 20
          };
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const garch18 = garchAnalysis.p18;
        
        // Base probabilities
        let scenarios = {
          strongUp: 15,    // >+2%
          moderateUp: 20,  // +1% to +2%
          lateral: 30,     // -1% to +1%
          moderateDown: 20, // -2% to -1%
          strongDown: 15   // <-2%
        };
        
        // Ajuste baseado no desvio do pre√ßo justo
        if (deviation > 8) {
          // Muito sobrevalorizado - alta probabilidade de queda
          scenarios.strongDown += 25;
          scenarios.moderateDown += 15;
          scenarios.strongUp -= 15;
          scenarios.moderateUp -= 10;
          scenarios.lateral -= 15;
        } else if (deviation > 5) {
          // Moderadamente sobrevalorizado
          scenarios.strongDown += 15;
          scenarios.moderateDown += 10;
          scenarios.strongUp -= 10;
          scenarios.lateral -= 15;
        } else if (deviation < -8) {
          // Muito subvalorizado - alta probabilidade de alta
          scenarios.strongUp += 25;
          scenarios.moderateUp += 15;
          scenarios.strongDown -= 15;
          scenarios.moderateDown -= 10;
          scenarios.lateral -= 15;
        } else if (deviation < -5) {
          // Moderadamente subvalorizado
          scenarios.strongUp += 15;
          scenarios.moderateUp += 10;
          scenarios.strongDown -= 10;
          scenarios.lateral -= 15;
        }
        
        // Ajuste baseado no GARCH
        if (garch18) {
          const currentPrice = this.lastClose();
          
          if (currentPrice > garch18.up1sigma) {
            // Acima de +1œÉ - maior probabilidade de corre√ß√£o
            scenarios.moderateDown += 10;
            scenarios.strongDown += 5;
            scenarios.strongUp -= 10;
            scenarios.lateral -= 5;
          } else if (currentPrice < garch18.down1sigma) {
            // Abaixo de -1œÉ - maior probabilidade de recupera√ß√£o
            scenarios.moderateUp += 10;
            scenarios.strongUp += 5;
            scenarios.strongDown -= 10;
            scenarios.lateral -= 5;
          }
        }
        
        // Normalizar para 100%
        const total = Object.values(scenarios).reduce((sum, val) => sum + val, 0);
        Object.keys(scenarios).forEach(key => {
          scenarios[key] = Math.max(5, Math.round((scenarios[key] / total) * 100));
        });
        
        return scenarios;
      }
      
      // Narrativa melhorada com todos os c√°lculos do sistema
      generateEnhancedNarrative(currentPrice, garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return `
            <h4>AN√ÅLISE DI√ÅRIA - USD/BRL (${new Date().toLocaleDateString('pt-BR')})</h4>
            <p>Configure os par√¢metros de pre√ßo justo (PPP, UIP, juros) para an√°lise narrativa completa.</p>
          `;
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        const garch18 = garchAnalysis.p18;
        const intraday18 = intradayAnalysis.p18;
        
        let narrative = `
          <h4>AN√ÅLISE GARCH COM IA - USD/BRL (${new Date().toLocaleDateString('pt-BR')})</h4>
          
          <p><strong>SITUA√á√ÉO ATUAL:</strong><br>
          O d√≥lar fechou em ${this.fmt(currentPrice)}, operando ${Math.abs(deviation).toFixed(1)}% ${deviation > 0 ? 'ACIMA' : 'ABAIXO'} do pre√ßo just√≠ssimo de ${this.fmt(fairPriceAnalysis.fairPriceCombined)}. 
          Volatilidade 18P em ${vol18.toFixed(2)}% (${volatilityAnalysis.p18?.regime || 'MODERADA'}).</p>
          
          <p><strong>AN√ÅLISE GARCH MULTI-PER√çODO:</strong><br>`;
        
        if (garch18) {
          narrative += `Bandas GARCH 18P: ${this.fmt(garch18.down1sigma)} (-1œÉ) | ${this.fmt(garch18.up1sigma)} (+1œÉ)<br>`;
          
          if (currentPrice > garch18.up1sigma) {
            narrative += `‚ö†Ô∏è Pre√ßo ACIMA da banda superior (+1œÉ) - press√£o de venda estat√≠stica<br>`;
          } else if (currentPrice < garch18.down1sigma) {
            narrative += `‚ö†Ô∏è Pre√ßo ABAIXO da banda inferior (-1œÉ) - press√£o de compra estat√≠stica<br>`;
          } else {
            narrative += `‚úÖ Pre√ßo DENTRO das bandas ¬±1œÉ - comportamento normal<br>`;
          }
        }
        
        narrative += `</p><p><strong>PROJE√á√ïES INTRADAY (FATORES EXP):</strong><br>`;
        
        if (intraday18) {
          narrative += `Range esperado: ${this.fmt(intraday18.minIntraday)} - ${this.fmt(intraday18.maxIntraday)} (${intraday18.rangePercent.toFixed(2)}%)<br>`;
          narrative += `Potencial alta: +${intraday18.potentialGain.toFixed(2)}% | Potencial baixa: -${intraday18.potentialLoss.toFixed(2)}%`;
        }
        
        narrative += `</p><p><strong>PRE√áO JUSTO INTEGRADO (PPP+UIP):</strong><br>`;
        narrative += `PPP: ${this.fmt(fairPriceAnalysis.fairPricePPP)} | UIP: ${this.fmt(fairPriceAnalysis.fairPriceUIP)}<br>`;
        narrative += `Just√≠ssimo (40% PPP + 60% UIP): ${this.fmt(fairPriceAnalysis.fairPriceCombined)}<br>`;
        narrative += `Diferencial juros BR-US: ${(fairPriceAnalysis.interestDifferential * 100).toFixed(2)}p.p.`;
        
        narrative += `</p><p><strong>CEN√ÅRIOS PROBABIL√çSTICOS:</strong><br>`;
        
        if (Math.abs(deviation) > 8) {
          const direction = deviation > 0 ? 'CORRE√á√ÉO BAIXISTA' : 'RECUPERA√á√ÉO ALTISTA';
          const probability = Math.min(80, Math.round(Math.abs(deviation) * 8));
          
          narrative += `üéØ <strong>${direction} (${probability}%):</strong> Desvio extremo tende √† revers√£o<br>`;
          
          if (vol18 < 2.5) {
            narrative += `‚úÖ <strong>ALTA CONFIAN√áA:</strong> Baixa volatilidade favorece movimentos direcionais<br>`;
          } else {
            narrative += `‚ö†Ô∏è <strong>ATEN√á√ÉO:</strong> Alta volatilidade pode gerar ru√≠do no movimento`;
          }
        } else if (Math.abs(deviation) > 5) {
          narrative += `üìä <strong>MOVIMENTO MODERADO:</strong> Desvio ${Math.abs(deviation).toFixed(1)}% sugere corre√ß√£o gradual<br>`;
        } else {
          narrative += `üìä <strong>EQUIL√çBRIO:</strong> Pre√ßo pr√≥ximo ao justo, aguardar catalisador<br>`;
        }
        
        narrative += `</p><p><strong>RECOMENDA√á√ÉO FINAL:</strong><br>`;
        
        if (Math.abs(deviation) > 8 && vol18 < 2.5) {
          if (deviation > 8) {
            narrative += `üî¥ <strong>VENDA RECOMENDADA:</strong> Conflu√™ncia pre√ßo justo + GARCH indica sobrevaloriza√ß√£o. Stop acima de ${garch18 ? this.fmt(garch18.up2sigma) : 'N/D'}.`;
          } else {
            narrative += `üü¢ <strong>COMPRA RECOMENDADA:</strong> Conflu√™ncia pre√ßo justo + GARCH indica subvaloriza√ß√£o. Stop abaixo de ${garch18 ? this.fmt(garch18.down2sigma) : 'N/D'}.`;
          }
        } else if (vol18 > 4.0) {
          narrative += `üü° <strong>AGUARDAR:</strong> Volatilidade extrema (${vol18.toFixed(2)}%) requer paci√™ncia. Aguardar normaliza√ß√£o abaixo de 3%.`;
        } else {
          narrative += `üîç <strong>MONITORAR:</strong> Condi√ß√µes mistas. Aguardar confirma√ß√£o de dire√ß√£o com aumento de volume.`;
        }
        
        narrative += `</p>`;
        
        return narrative;
      }
      
      // Sistema FRP - Forward Rate Premium (mantido do original)
      convertSpotToFuture(spotPrice) {
        const frp = parseFloat(document.getElementById('frp')?.value || 0) / 100;
        const maturityDays = parseInt(document.getElementById('maturityDays')?.value || 30);
        const dataType = document.getElementById('dataType')?.value || 'spot';
        
        if (dataType === 'spot' && frp !== 0) {
          const timeFactor = maturityDays / 365;
          return spotPrice * (1 + frp * timeFactor);
        }
        
        return spotPrice;
      }
      
      convertFutureToSpot(futurePrice) {
        const frp = parseFloat(document.getElementById('frp')?.value || 0) / 100;
        const maturityDays = parseInt(document.getElementById('maturityDays')?.value || 30);
        const dataType = document.getElementById('dataType')?.value || 'spot';
        
        if (dataType === 'future' && frp !== 0) {
          const timeFactor = maturityDays / 365;
          return futurePrice / (1 + frp * timeFactor);
        }
        
        return futurePrice;
      }
      
      updateDataTypeUI() {
        const dataType = document.getElementById('dataType')?.value;
        const frpInput = document.getElementById('frp');
        const maturityInput = document.getElementById('maturityDays');
        
        if (dataType === 'spot') {
          frpInput.classList.add('frp-highlight');
          frpInput.classList.remove('frp-disabled');
          frpInput.placeholder = 'Ex: 13.75 (Selic atual)';
          this.log('Modo SPOT: FRP ser√° aplicado para converter para pre√ßos futuros');
        } else {
          frpInput.classList.remove('frp-highlight');
          frpInput.classList.add('frp-disabled');
          frpInput.placeholder = 'N√£o necess√°rio para dados futuros';
          this.log('Modo FUTURO: Dados j√° incorporam juros impl√≠citos');
        }
      }
      
      processRawData(rawPrices, sourceType = 'api') {
        const dataType = document.getElementById('dataType')?.value || 'spot';
        const frp = parseFloat(document.getElementById('frp')?.value || 0);
        
        let processedPrices = [...rawPrices];
        
        if (sourceType === 'api' && dataType === 'spot' && frp > 0) {
          processedPrices = processedPrices.map(price => this.convertSpotToFuture(price));
          this.log(`Convers√£o aplicada: Spot ‚Üí Futuro (FRP: ${frp.toFixed(2)}%)`);
        } else if (sourceType === 'excel' && dataType === 'future') {
          this.log('Dados futuros do Excel utilizados diretamente');
        } else if (sourceType === 'excel' && dataType === 'spot' && frp > 0) {
          processedPrices = processedPrices.map(price => this.convertSpotToFuture(price));
          this.log(`Convers√£o aplicada: Spot (Excel) ‚Üí Futuro (FRP: ${frp.toFixed(2)}%)`);
        }
        
        return processedPrices;
      }
      
      // API Configuration Methods (mantidos do original)
      selectProvider(provider) {
        document.querySelectorAll('.provider-card').forEach(card => {
          card.classList.remove('active');
        });
        document.querySelector(`[data-provider="${provider}"]`).classList.add('active');
        
        this.apiConfig.provider = provider;
        this.updateAPIInfo();
        this.updateProviderSpecificUI(provider);
      }
      
      updateProviderSpecificUI(provider) {
        const symbolInput = document.getElementById('symbol');
        
        switch(provider) {
          case 'alpha_vantage':
            symbolInput.value = 'USDBRL';
            break;
          case 'yahoo_finance':
            symbolInput.value = 'USDBRL=X';
            break;
          case 'polygon':
            symbolInput.value = 'C:USDBRL';
            break;
          case 'tradier':
            symbolInput.value = 'USD/BRL';
            break;
        }
        
        this.apiConfig.symbol = symbolInput.value;
      }
      
      updateAPIConfigFromInputs() {
        this.apiConfig.apiKey = document.getElementById('apiKey').value;
        this.apiConfig.symbol = document.getElementById('symbol').value;
        this.apiConfig.interval = document.getElementById('interval').value;
      }
      
      saveAPIConfig() {
        this.updateAPIConfigFromInputs();
        this.log(`Configura√ß√£o salva para ${this.apiConfig.provider}`);
        this.updateAPIInfo();
      }
      
      loadAPIConfig() {
        document.getElementById('apiKey').value = this.apiConfig.apiKey;
        document.getElementById('symbol').value = this.apiConfig.symbol;
        document.getElementById('interval').value = this.apiConfig.interval;
      }
      
      updateAPIInfo() {
        document.getElementById('activeProvider').textContent = this.getProviderDisplayName(this.apiConfig.provider);
        document.getElementById('connectionStatus').textContent = this.apiConnected ? 'Conectado' : 'Desconectado';
        document.getElementById('dataCount').textContent = this.priceData.length;
        
        const statusEl = document.getElementById('apiStatus');
        statusEl.textContent = `API: ${this.apiConnected ? 'Conectado' : 'Desconectado'}`;
        statusEl.className = `api-status ${this.apiConnected ? 'connected' : 'disconnected'}`;
      }
      
      getProviderDisplayName(provider) {
        const names = {
          'alpha_vantage': 'Alpha Vantage',
          'yahoo_finance': 'Yahoo Finance',
          'polygon': 'Polygon.io',
          'tradier': 'Tradier'
        };
        return names[provider] || provider;
      }
      
      async testAPIConnection() {
        this.showLoading();
        document.getElementById('apiStatus').className = 'api-status testing';
        document.getElementById('apiStatus').textContent = 'API: Testando...';
        
        try {
          if (this.apiConfig.provider === 'alpha_vantage') {
            const testKey = this.apiConfig.apiKey || 'demo';
            
            if (testKey === 'demo' || testKey === '') {
              this.apiConnected = true;
              this.updateAPIInfo();
              this.log('‚úÖ Modo demo ativo. Clique "üì° Dados via API" para ver dados real√≠sticos.');
              document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
              return;
            }
            
            const testUrl = `https://www.alphavantage.co/query?function=FX_DAILY&from_symbol=USD&to_symbol=BRL&apikey=${testKey}&outputsize=compact`;
            
            try {
              const response = await fetch(testUrl, {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
              });
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: Verifique sua conex√£o`);
              }
              
              const data = await response.json();
              
              if (data['Error Message']) {
                throw new Error(`API Key inv√°lida: ${data['Error Message']}`);
              }
              
              if (data['Note'] || data['Information']) {
                this.log('‚ö†Ô∏è Limite de calls atingido, mas API key √© v√°lida. Usando dados demo.');
                this.apiConnected = true;
              } else if (data['Meta Data'] || data['Time Series (Daily)']) {
                this.apiConnected = true;
                this.log('‚úÖ API Key v√°lida! Conectado ao Alpha Vantage.');
              } else {
                this.log('‚ö†Ô∏è Resposta inesperada da API. Usando dados demo para demonstra√ß√£o.');
                this.apiConnected = true;
              }
              
            } catch (fetchError) {
              console.error('Fetch error:', fetchError);
              
              if (fetchError.message.includes('CORS') || 
                  fetchError.message.includes('Failed to fetch') ||
                  fetchError.message.includes('NetworkError')) {
                this.log('‚ö†Ô∏è Problema de CORS/rede detectado. Sistema funcionar√° com dados demo.');
                this.apiConnected = true;
              } else {
                throw fetchError;
              }
            }
            
            this.updateAPIInfo();
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
          }
          
        } catch (error) {
          console.error('Test connection error:', error);
          this.apiConnected = false;
          this.updateAPIInfo();
          
          if (error.message.includes('API Key inv√°lida')) {
            this.log(`‚ùå ${error.message}. Verifique sua chave ou use 'demo'.`);
          } else if (error.message.includes('HTTP')) {
            this.log(`‚ùå ${error.message}. Tente novamente em alguns segundos.`);
          } else {
            this.log(`‚ùå Erro no teste: ${error.message}. Use 'demo' para testar.`);
          }
        } finally {
          this.hideLoading();
        }
      }
      
      async fetchAPIData() {
        const canProceed = this.apiConnected || 
                          this.apiConfig.provider === 'yahoo_finance' || 
                          this.apiConfig.apiKey === 'demo' || 
                          !this.apiConfig.apiKey;
        
        if (!canProceed) {
          this.log("Teste a conex√£o da API primeiro");
          return;
        }
        
        this.showLoading();
        this.setStatus("buscando dados da API...");
        
        try {
          let data;
          
          switch(this.apiConfig.provider) {
            case 'alpha_vantage':
              data = await this.fetchAlphaVantageData();
              break;
            case 'yahoo_finance':
              data = await this.fetchYahooFinanceData();
              break;
            case 'polygon':
              data = await this.fetchPolygonData();
              break;
            case 'tradier':
              data = await this.fetchTradierData();
              break;
            default:
              throw new Error('Provedor n√£o suportado');
          }
          
          const processedData = this.processRawData(data, 'api');
          this.priceData = processedData;
          this.refreshAll();
          this.setStatus(`${processedData.length} pontos da API`);
          this.log(`‚úÖ Dados processados via ${this.getProviderDisplayName(this.apiConfig.provider)}: ${processedData.length} registros`);
          document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
          
          // Auto-run AI analysis if data is available
          if (processedData.length > 20) {
            setTimeout(() => this.performAIAnalysis(), 1000);
          }
          
          const welcomeBanner = document.querySelector('.welcome-banner');
          if (welcomeBanner) {
            welcomeBanner.style.display = 'none';
          }
          
        } catch (error) {
          this.setStatus("erro na API");
          this.log(`‚ùå Erro API: ${error.message}`);
          
          if (error.message.includes('API Key')) {
            this.log("üí° Dica: Use 'demo' como API key para testar, ou carregue dados manualmente");
          }
        } finally {
          this.hideLoading();
        }
      }
      
      async fetchAlphaVantageData() {
        const apiKey = this.apiConfig.apiKey || 'demo';
        
        if (apiKey === 'demo' || apiKey === '') {
          this.log('üéØ Usando dados demo para demonstra√ß√£o');
          return this.generateFallbackData();
        }

        let url = `https://www.alphavantage.co/query?function=FX_DAILY&from_symbol=USD&to_symbol=BRL&apikey=${apiKey}&outputsize=compact`;
        
        this.log('Conectando com Alpha Vantage...');
        
        try {
          const response = await fetch(url, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
            }
          });
          
          if (!response.ok) {
            this.log(`‚ö†Ô∏è Erro HTTP ${response.status}. Usando dados demo.`);
            return this.generateFallbackData();
          }
          
          const data = await response.json();
          
          if (data['Error Message'] || data['Note'] || data['Information']) {
            this.log('‚ö†Ô∏è Limite de API atingido. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          const timeSeries = data['Time Series (Daily)'] || data['Time Series FX (Daily)'];
          
          if (!timeSeries || typeof timeSeries !== 'object') {
            this.log('‚ö†Ô∏è Estrutura de dados inesperada da API. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          const dates = Object.keys(timeSeries).sort();
          
          if (dates.length === 0) {
            this.log('‚ö†Ô∏è Nenhum dado temporal encontrado. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          const prices = [];
          const recentDates = dates.slice(-180);
          
          for (const date of recentDates) {
            const dayData = timeSeries[date];
            if (!dayData || typeof dayData !== 'object') continue;
            
            const closePrice = parseFloat(
              dayData['4. close'] || 
              dayData['close'] || 
              dayData['Close'] || 
              dayData['4'] ||
              0
            );
            
            if (!isNaN(closePrice) && closePrice > 0) {
              let adjustedPrice = closePrice;
              
              if (closePrice < 10) {
                adjustedPrice = closePrice * 1000;
              }
              
              prices.push(Number(adjustedPrice.toFixed(2)));
            }
          }
          
          if (prices.length === 0) {
            this.log('‚ö†Ô∏è Nenhum pre√ßo v√°lido processado. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          this.log(`‚úÖ Alpha Vantage: ${prices.length} pre√ßos USD/BRL processados com sucesso`);
          return prices;
          
        } catch (error) {
          console.error('Alpha Vantage Error:', error);
          this.log(`‚ö†Ô∏è Erro de conex√£o: ${error.message}. Usando dados demo.`);
          return this.generateFallbackData();
        }
      }
      
      generateFallbackData() {
        const baseRate = 5.20;
        const data = [];
        let currentRate = baseRate;
        
        for (let i = 0; i < 180; i++) {
          const dailyChange = (Math.random() - 0.5) * 0.06;
          const trend = Math.sin(i * 0.1) * 0.01;
          
          currentRate *= (1 + dailyChange + trend);
          currentRate = Math.max(4.80, Math.min(5.80, currentRate));
          
          data.push(Number(currentRate.toFixed(4)));
        }
        
        return data;
      }
      
      async fetchYahooFinanceData() {
        await new Promise(resolve => setTimeout(resolve, 1200));
        return this.generateRealisticData(180);
      }
      
      async fetchPolygonData() {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return this.generateRealisticData(180);
      }
      
      async fetchTradierData() {
        await new Promise(resolve => setTimeout(resolve, 1300));
        return this.generateRealisticData(180);
      }
      
      generateRealisticData(count) {
        const currentClose = 5.437;
        const out = [];
        let x = currentClose;
        
        for (let i = count - 1; i >= 0; i--) {
          const daysBack = i;
          const trend = Math.sin(daysBack * 0.06) * 0.003;
          const dailyVolatility = (Math.random() - 0.5) * 0.018;
          const momentum = Math.sin(daysBack * 0.25) * 0.002;
          const meanReversion = (5.42 - x) * 0.0005;
          
          x *= (1 + trend + dailyVolatility + momentum + meanReversion);
          x = Math.max(5.20, Math.min(5.65, x));
          out.push(Number(x.toFixed(4)));
        }
        
        out.reverse();
        out[out.length - 1] = currentClose;
        
        return out;
      }
      
      async fetchSimulatedData() {
        this.showLoading();
        this.setStatus("buscando dados simulados...");
        
        try {
          await new Promise(resolve => setTimeout(resolve, 1000));
          const data = this.generateRealisticData(180);
          const processedData = this.processRawData(data, 'simulated');
          this.priceData = processedData;
          this.refreshAll();
          this.setStatus(`${processedData.length} pontos simulados`);
          this.log(`Dados simulados carregados: ${processedData.length} pre√ßos`);
          
          // Auto-run AI analysis
          if (processedData.length > 20) {
            setTimeout(() => this.performAIAnalysis(), 500);
          }
          
          const welcomeBanner = document.querySelector('.welcome-banner');
          if (welcomeBanner) {
            welcomeBanner.style.display = 'none';
          }
        } catch (e) {
          this.setStatus("erro ao buscar dados");
          this.log("Erro: " + e.message);
        } finally {
          this.hideLoading();
        }
      }
      
      logout() {
        if (confirm('Deseja realmente sair do sistema?')) {
          sessionStorage.removeItem('currentUser');
          window.location.href = 'index.html';
        }
      }
      
      showLoading() {
        document.getElementById('loadingOverlay').style.display = 'flex';
      }
      
      hideLoading() {
        document.getElementById('loadingOverlay').style.display = 'none';
      }
      
      analyze() {
        if (!this.priceData.length) {
          this.log("Carregue dados primeiro");
          return;
        }
        
        this.showLoading();
        
        setTimeout(() => {
          this.refreshAll();
          this.log("An√°lise executada com sucesso");
          
          // Auto-run AI analysis after regular analysis
          setTimeout(() => this.performAIAnalysis(), 500);
          
          this.hideLoading();
        }, 800);
      }
      
      loadManualData() {
        const text = document.getElementById('manualData').value.trim();
        if (!text) {
          this.log("Digite alguns pre√ßos primeiro");
          return;
        }
        
        const lines = text.split('\n').filter(l => l.trim());
        const rawPrices = lines.map(l => parseFloat(l.trim())).filter(p => !isNaN(p));
        
        if (rawPrices.length === 0) {
          this.log("Nenhum pre√ßo v√°lido encontrado");
          return;
        }
        
        const processedPrices = this.processRawData(rawPrices, 'manual');
        this.priceData = processedPrices;
        this.refreshAll();
        this.setStatus(`${processedPrices.length} pre√ßos manuais`);
        this.log(`${processedPrices.length} pre√ßos processados manualmente`);
        this.updateAPIInfo();
        
        // Auto-run AI analysis
        if (processedPrices.length > 10) {
          setTimeout(() => this.performAIAnalysis(), 500);
        }
      }
      
      clearData() {
        if (!confirm('Deseja realmente limpar todos os dados?')) {
          return;
        }
        
        this.priceData = [];
        this.linearReturns = [];
        this.aiAnalysis = null;
        document.getElementById('manualData').value = "";
        
        const valueElements = document.querySelectorAll('.value');
        valueElements.forEach(el => el.innerText = '--');
        
        document.getElementById('debugInfo').innerText = "Debug: aguardando c√°lculos...";
        
        this.setStatus("dados limpos");
        this.log("Dados limpos");
        this.updateAPIInfo();
        this.updateAIDisplay(); // Reset AI display
      }
      
      handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        this.showLoading();
        this.log("Processando arquivo Excel...");
        
        const reader = new FileReader();
        reader.onload = (evt) => {
          try {
            const data = evt.target.result;
            const workbook = XLSX.read(data, {type: 'binary'});
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
            
            if (jsonData.length === 0) {
              this.log("Planilha vazia");
              this.hideLoading();
              return;
            }
            
            const firstRow = jsonData[0] || [];
            
            
            // Detectar colunas VWAP e utilit√°rios
            let vwapDCol = -1, vwapSCol = -1, vwapMCol = -1, dateCol = -1;
            function _toNumBR(v){ if(v==null||v==='') return NaN; if(typeof v==='number') return v; const s=String(v).trim().replace(/\./g,'').replace(',', '.'); const n=parseFloat(s); return isFinite(n)?n:NaN; }
            function _fmtBR(x){ if(!(x>0)) return ''; const s=Number(x).toFixed(2); const p=s.split('.'); p[0]=p[0].replace(/\B(?=(\d{3})+(?!\d))/g,'.'); return p[0]+','+p[1]; }
            function _parseDate(v){
              if (v==null || v==='') return null;
              if (typeof v==='number'){ const base = new Date(Date.UTC(1899,11,30)); base.setUTCDate(base.getUTCDate()+Math.floor(v)); return new Date(base.getFullYear(), base.getMonth(), base.getDate()); }
              const s = String(v).trim();
              const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/);
              if (m){ const yy = (m[3].length===2? Number('20'+m[3]): Number(m[3])); return new Date(yy, Number(m[2])-1, Number(m[1])); }
              const d = new Date(s); if (!isNaN(d)) return new Date(d.getFullYear(), d.getMonth(), d.getDate());
              return null;
            }
            for (let j=0;j<firstRow.length;j++){ const h=String(firstRow[j]||'').toLowerCase();
              if (h.includes('data') || h.includes('date')) dateCol = j;
              if(h.includes('vwap')){
                if (h.includes('vwap d') || h.includes('vwap_d') || /\bd\b|dia|daily/.test(h)) vwapDCol=j;
                if (h.includes('vwap s') || h.includes('vwap_s') || /\bs\b|sem|week/.test(h)) vwapSCol=j;
                if (h.includes('vwap m') || h.includes('vwap_m') || /\bm\b|m[e√™]s|month/.test(h)) vwapMCol=j;
              }
            }
            let _lastDate = null;
            for (let i=1;i<jsonData.length;i++){ const row=jsonData[i]; const dv = (dateCol>=0? row[dateCol] : null); const dt=_parseDate(dv); if(dt){ if(!_lastDate || dt>_lastDate) _lastDate = dt; } }
            let _firstD = NaN, _firstS = NaN, _firstM = NaN;
            if (_lastDate){
              for (let i=1;i<jsonData.length;i++){
                const row=jsonData[i]; const dv=(dateCol>=0? row[dateCol] : null); const dt=_parseDate(dv);
                if (dt && dt.getFullYear()===_lastDate.getFullYear() && dt.getMonth()===_lastDate.getMonth() && dt.getDate()===_lastDate.getDate()){
                  if (isNaN(_firstD) && vwapDCol>=0){ const vv=_toNumBR(row[vwapDCol]); if (isFinite(vv)) _firstD = vv; }
                  if (isNaN(_firstS) && vwapSCol>=0){ const vv=_toNumBR(row[vwapSCol]); if (isFinite(vv)) _firstS = vv; }
                  if (isNaN(_firstM) && vwapMCol>=0){ const vv=_toNumBR(row[vwapMCol]); if (isFinite(vv)) _firstM = vv; }
                  if (!isNaN(_firstD) && !isNaN(_firstS) && !isNaN(_firstM)) break;
                }
              }
            }
            let _lastD=NaN,_lastS=NaN,_lastM=NaN; // mantido por compatibilidade, mas n√£o usado

    
            
            let closeColumn = 4;
            for (let i = 0; i < firstRow.length; i++) {
              const header = String(firstRow[i]).toLowerCase();
              if (header.includes('fechamento') || header.includes('close')) {
                closeColumn = i;
                break;
              }
            }
            
            const prices = [];
            
            for (let i = 1; i < jsonData.length; i++) {
              const row = jsonData[i];
                            if (vwapSCol>=0){ const vv=_toNumBR(row[vwapSCol]); if (isFinite(vv)) _lastS=vv; }
              if (vwapMCol>=0){ const vv=_toNumBR(row[vwapMCol]); if (isFinite(vv)) _lastM=vv; }
    
              if (!row || row.length <= closeColumn) continue;
              
              let rawPrice = row[closeColumn];
              if (rawPrice === undefined || rawPrice === null || rawPrice === '') continue;
              
              let numPrice;
              if (typeof rawPrice === 'number') {
                numPrice = rawPrice;
              } else if (typeof rawPrice === 'string') {
                const cleaned = rawPrice.trim().replace(',', '.');
                numPrice = parseFloat(cleaned);
              } else {
                continue;
              }
              
              if (!isNaN(numPrice) && numPrice >= 4000 && numPrice <= 7000) {
                prices.push(numPrice);
              }
            }
            
            prices.reverse();
            
            if (prices.length > 0) {
              document.getElementById('dataType').value = 'future';
              this.updateDataTypeUI();
              
              const processedPrices = this.processRawData(prices, 'excel');
              this.priceData = processedPrices;
              this.refreshAll();
              this.setStatus(`${processedPrices.length} pre√ßos importados`);
              this.log(`${processedPrices.length} pre√ßos do Excel processados (DOL Futuro)`);
              // Preencher VWAP filtrando por ordem de grandeza do √∫ltimo fechamento
              try{
                const lc = this.lastClose?.() || (this.priceData?.slice(-1)[0]) || NaN;
                function within(x){ if(!isFinite(lc)) return (x>800 && x<20000); return (x>=lc*0.3 && x<=lc*3); }
                function backfill(series){ for (let k=series.length-1;k>=0;k--){ const v=series[k]; if(isFinite(v) && within(v)) return v; } return NaN; }
                // Reconstr√≥i s√©ries r√°pidas a partir do loop feito acima
                const d=_firstD, s=_firstS, m=_firstM;
                const D = d, S = s, M = m;
                const Df=document.getElementById('vwapD'), Sf=document.getElementById('vwapS'), Mf=document.getElementById('vwapM');
                if (Df && isFinite(D)) Df.value = _fmtBR(D);
                if (Sf && isFinite(S)) Sf.value = _fmtBR(S);
                if (Mf && isFinite(M)) Mf.value = _fmtBR(M);
              }catch(_){}
    
              this.updateAPIInfo();
              
              // Auto-run AI analysis
              if (processedPrices.length > 20) {
                setTimeout(() => this.performAIAnalysis(), 1000);
              }
            } else {
              this.log(`Nenhum pre√ßo v√°lido encontrado na coluna ${String.fromCharCode(65+closeColumn)}`);
            }
          } catch (err) {
            this.log("Erro ao ler Excel: " + err.message);
          } finally {
            this.hideLoading();
          }
        };
        reader.readAsBinaryString(file);
      }
      
      // Mathematical calculations (maintained from original)
      calculateLinearReturns() {
        this.linearReturns = [];
        if (this.priceData.length < 2) return;
        
        for (let i = 1; i < this.priceData.length; i++) {
          const current = this.priceData[i];
          const previous = this.priceData[i - 1];
          const linearReturn = current / previous;
          this.linearReturns.push(linearReturn);
        }
      }
      
      calculateStdDevReturns(periods) {
        if (this.linearReturns.length < periods) return NaN;
        
        const slice = this.linearReturns.slice(-periods);
        const mean = slice.reduce((sum, ret) => sum + ret, 0) / slice.length;
        const variance = slice.reduce((sum, ret) => sum + Math.pow(ret - mean, 2), 0) / slice.length;
        const stdDev = Math.sqrt(variance);
        
        return stdDev;
      }
      
      lastClose() {
        return this.priceData.length ? this.priceData[this.priceData.length - 1] : NaN;
      }
      
      currentReturn() {
        return this.linearReturns.length ? this.linearReturns[this.linearReturns.length - 1] : NaN;
      }
      
      getExpFor(period) {
        if (period === 9) return parseFloat(document.getElementById('exp9').value) || 2.718;
        if (period === 18) return parseFloat(document.getElementById('exp18').value) || 2.718;
        if (period === 27) return parseFloat(document.getElementById('exp27').value) || 2.718;
        return 2.718;
      }
      
      calculateMultiPeriodForecasts(period) {
        if (!this.priceData.length || this.linearReturns.length < period) return;
        
        const lc = this.lastClose();
        const stdDev = this.calculateStdDevReturns(period);
        
        if (!isFinite(stdDev)) return;
        
        const up1 = lc * (1 + stdDev);
        const dn1 = lc * (1 - stdDev);
        const up2 = lc * (1 + 2 * stdDev);
        const dn2 = lc * (1 - 2 * stdDev);
        
        document.getElementById('f_up1').innerText = this.fmt(up1);
        document.getElementById('f_dn1').innerText = this.fmt(dn1);
        document.getElementById('f_up2').innerText = this.fmt(up2);
        document.getElementById('f_dn2').innerText = this.fmt(dn2);
      }
      
      calculateIntradayExtremes(period) {
        if (!this.priceData.length || this.linearReturns.length < period) return;
        
        const lc = this.lastClose();
        const stdDev = this.calculateStdDevReturns(period);
        const expFactor = this.getExpFor(period);
        
        if (!isFinite(stdDev) || !isFinite(lc)) return;
        
        const expStdDev = Math.pow(expFactor, stdDev);
        const iMax = lc * expStdDev;
        const iMin = lc / expStdDev;
        
        document.getElementById('i_max').innerText = this.fmt(iMax);
        document.getElementById('i_min').innerText = this.fmt(iMin);
        document.getElementById('i_close').innerText = this.fmt(lc);
        document.getElementById('i_sigma').innerText = (stdDev * 100).toFixed(4) + "%";
        
        const debugText = `Per√≠odo: ${period}P | StdDev: ${(stdDev*100).toFixed(4)}% | ExpFactor: ${expFactor} | Exp^œÉ: ${expStdDev.toFixed(6)} | Max: ${this.fmt(iMax)} | Min: ${this.fmt(iMin)}`;
        document.getElementById('debugInfo').innerText = debugText;
      }
      
      switchForecastPeriod(period) {
        this.currentForecastP = period;
        document.querySelectorAll('#forecastTabs .tab').forEach(el => el.classList.remove('active'));
        const target = document.querySelector(`#forecastTabs .tab[data-period="${period}"]`);
        if (target) target.classList.add('active');
        this.calculateMultiPeriodForecasts(period);
      }
      
      switchIntradayPeriod(period) {
        this.currentIntradayP = period;
        document.querySelectorAll('#intradayTabs .tab').forEach(tab => tab.classList.remove('active'));
        const target = document.querySelector(`#intradayTabs .tab[data-iperiod="${period}"]`);
        if (target) target.classList.add('active');
        this.calculateIntradayExtremes(period);
      }
      
      // Fair Price Calculations (maintained from original with fixes)
      calculateFairPrices() {
        const currentPrice = this.lastClose();
        if (!isFinite(currentPrice) || currentPrice <= 0) {
          this.resetFairPriceDisplay();
          return;
        }
        
        let pppRate = parseFloat(document.getElementById('ppp_rate')?.value || 5.30);
        const inflationBr = parseFloat(document.getElementById('inflation_br')?.value || 4.5) / 100;
        const inflationUs = parseFloat(document.getElementById('inflation_us')?.value || 3.2) / 100;
        const selicRate = parseFloat(document.getElementById('selic_rate')?.value || 15.50) / 100;
        const fedRate = parseFloat(document.getElementById('fed_rate')?.value || 5.50) / 100;
        const riskPremium = parseFloat(document.getElementById('risk_premium')?.value || 2.5) / 100;

        if (currentPrice > 100) {
          pppRate = pppRate * 1000;
        }

        const inflationDifferential = inflationBr - inflationUs;
        const fairPricePPP = pppRate * ((1 + inflationBr) / (1 + inflationUs));

        const interestDifferential = selicRate - fedRate;
        const netInterestDifferential = interestDifferential - riskPremium;
        const uipAdjustmentFactor = 1 + (netInterestDifferential * 0.15);
        const fairPriceUIP = currentPrice * uipAdjustmentFactor;

        const maxUIPDeviation = 0.20;
        const upperBoundUIP = currentPrice * (1 + maxUIPDeviation);
        const lowerBoundUIP = currentPrice * (1 - maxUIPDeviation);
        const boundedFairPriceUIP = Math.max(lowerBoundUIP, Math.min(upperBoundUIP, fairPriceUIP));

        const weightPPP = 0.4;
        const weightUIP = 0.6;
        const fairPriceCombined = (fairPricePPP * weightPPP) + (boundedFairPriceUIP * weightUIP);

        const maxTotalDeviation = 0.25;
        const upperBound = currentPrice * (1 + maxTotalDeviation);
        const lowerBound = currentPrice * (1 - maxTotalDeviation);
        const finalFairPrice = Math.max(lowerBound, Math.min(upperBound, fairPriceCombined));

        const deviationFair = ((currentPrice - finalFairPrice) / finalFairPrice) * 100;

        const riskFactor = 1 + riskPremium;
        const trend30d = this.calculateTrend30Days();

        document.getElementById('fair_ppp').innerText = this.fmt(fairPricePPP);
        document.getElementById('fair_uip').innerText = this.fmt(boundedFairPriceUIP);
        document.getElementById('fair_combined').innerText = this.fmt(finalFairPrice);
        document.getElementById('deviation_fair').innerText = deviationFair.toFixed(2) + '%';
        document.getElementById('interest_diff').innerText = (interestDifferential * 100).toFixed(2) + 'p.p.';
        document.getElementById('inflation_diff').innerText = (inflationDifferential * 100).toFixed(2) + 'p.p.';
        document.getElementById('risk_factor').innerText = riskFactor.toFixed(4);
        document.getElementById('trend_30d').innerText = trend30d;

        this.updateFairPriceCardColors(deviationFair);
      }
      
      calculateTrend30Days() {
        if (this.priceData.length < 30) {
          return 'Dados insuficientes';
        }
        
        const recent30 = this.priceData.slice(-30);
        const first = recent30[0];
        const last = recent30[recent30.length - 1];
        const trend = ((last - first) / first) * 100;
        
        if (trend > 2) return `Forte Alta ${trend.toFixed(1)}%`;
        if (trend > 0.5) return `Alta ${trend.toFixed(1)}%`;
        if (trend < -2) return `Forte Baixa ${trend.toFixed(1)}%`;
        if (trend < -0.5) return `Baixa ${trend.toFixed(1)}%`;
        return `Lateral ${trend.toFixed(1)}%`;
      }
      
      updateFairPriceCardColors(deviation) {
        const fairCombinedCard = document.getElementById('fair_combined').closest('.card');
        const deviationCard = document.getElementById('deviation_fair').closest('.card');
        
        [fairCombinedCard, deviationCard].forEach(card => {
          if (card) {
            card.classList.remove('up-card', 'down-card', 'neutral-card');
          }
        });
        
        if (Math.abs(deviation) < 5) {
          if (fairCombinedCard) fairCombinedCard.classList.add('neutral-card');
          if (deviationCard) deviationCard.classList.add('neutral-card');
        } else if (deviation > 0) {
          if (fairCombinedCard) fairCombinedCard.classList.add('down-card');
          if (deviationCard) deviationCard.classList.add('down-card');
        } else {
          if (fairCombinedCard) fairCombinedCard.classList.add('up-card');
          if (deviationCard) deviationCard.classList.add('up-card');
        }
      }
      
      resetFairPriceDisplay() {
        ['fair_ppp', 'fair_uip', 'fair_combined', 'deviation_fair', 
         'interest_diff', 'inflation_diff', 'risk_factor', 'trend_30d'].forEach(id => {
          const element = document.getElementById(id);
          if (element) element.innerText = '--';
        });
      }
      
      updateExtras() {
        const lc = this.lastClose();
        const currentRet = this.currentReturn();
        
        if (isFinite(currentRet)) {
          const retPercent = (currentRet - 1) * 100;
          document.getElementById('ret_current').innerText = currentRet.toFixed(6) + ` (${retPercent.toFixed(2)}%)`;
        }
        
        [9, 18, 27].forEach(p => {
          const stdDev = this.calculateStdDevReturns(p);
          if (isFinite(stdDev)) {
            document.getElementById(`std${p}`).innerText = (stdDev * 100).toFixed(4) + "%";
            
            const expFactor = this.getExpFor(p);
            const expStdDev = Math.pow(expFactor, stdDev);
            document.getElementById(`exp_std${p}`).innerText = expStdDev.toFixed(6);
            
            if (isFinite(lc)) {
              const maxValue = lc * expStdDev;
              const minValue = lc / expStdDev;
              document.getElementById(`max_${p}p`).innerText = this.fmt(maxValue);
              document.getElementById(`min_${p}p`).innerText = this.fmt(minValue);
            }
          }
        });
      }
      
      refreshAll() {
        this.calculateLinearReturns();
        this.calculateMultiPeriodForecasts(this.currentForecastP);
        this.calculateIntradayExtremes(this.currentIntradayP);
        this.updateExtras();
        this.calculateFairPrices();
        this.updateAPIInfo();
      }
      
      fmt(v) {
        return (isFinite(v) ? Number(v).toFixed(2) : '--');
      }
      
      log(msg) {
        document.getElementById("log").innerText = msg;
        console.log(`[Trading System AI] ${msg}`);
      }
      
      setStatus(msg) {
        document.getElementById("dataStatus").innerText = msg;
      }
    }
    
    // Initialize trading system when page loads
    document.addEventListener('DOMContentLoaded', () => {
      window.tradingSystem = new TradingSystemWithAI();
    });
  </script>
  
  
<script>
/* =======================
   PATCH CONSOLIDADO ‚Äî 2 cards (Compra & Venda)
   Toque + 10‚Äì15 pts + Just√≠ssimo + cluster de 3 n√≠veis
   Compat com IA + dist√¢ncias (pts) arredondadas
   ======================= */
(function(){
  function onReady(fn){
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", fn);
    else fn();
  }

  onReady(function(){
    var tries = 0, t = setInterval(function(){
      var ts = window.tradingSystem;
      if (ts && typeof ts.generateTradingStrategy==="function"
            && typeof ts.analyzeSystemIntraday==="function"
            && typeof ts.analyzeSystemFairPrice==="function"
            && typeof ts.analyzeSystemVolatility==="function"
            && typeof ts.analyzeSystemGARCH==="function"
            && typeof ts.lastClose==="function") {
        clearInterval(t);
        apply(ts);
      }
      if (++tries>200) clearInterval(t);
    }, 100);
  });

  // helpers globais
  const F = (x)=> Number.isFinite(x) ? Number(x).toFixed(2) : "--";
  const STORAGE_KEY = "touchMode"; // "prearm" | "strict"
  function getTouchMode(){ return localStorage.getItem(STORAGE_KEY) || "prearm"; }
  function setTouchMode(v){ localStorage.setItem(STORAGE_KEY, v==="strict"?"strict":"prearm"); }

  function apply(ts){
    function getLevels(){
      const ia = ts.analyzeSystemIntraday();
      const p9  = ia.p9  || {}, p18 = ia.p18 || {}, p27 = ia.p27 || {};
      return {
        buys:  [p9.minIntraday,  p18.minIntraday,  p27.minIntraday].filter(Number.isFinite),
        sells: [p9.maxIntraday,  p18.maxIntraday,  p27.maxIntraday].filter(Number.isFinite)
      };
    }
    function getFair(){
      const f = ts.analyzeSystemFairPrice() || {};
      return { valid: !!f.valid, justoPPP: f.fairPricePPP, justissimo: f.fairPriceCombined };
    }
    function choosePts(vol18){
      if (vol18 >= 3.0) return 15;
      if (vol18 <= 1.5) return 10;
      return 12;
    }
    function sizeByVol(vol18, conf){
      if (vol18 > 3.5) return "REDUZIDA (50%)";
      if (vol18 > 3.0) return "REDUZIDA (70%)";
      if (vol18 < 1.5 && conf > 80) return "AUMENTADA (120-150%)";
      if (conf > 85) return "NORMAL+ (110%)";
      return "NORMAL";
    }
    function RR(entry, tgt, stop){
      const g = Math.abs(tgt-entry), l = Math.abs(entry-stop);
      return (l>0) ? (g/l) : 0;
    }
    function clusterOK(levels, maxSpreadPts){
      if (levels.length < 2) return false;
      const min = Math.min(...levels), max = Math.max(...levels);
      return (max - min) <= maxSpreadPts;
    }

    function buildSide(side, px, levels, fair, vol18, conf, g18){
      const mode = getTouchMode();
      const pts  = choosePts(vol18);
      const tol  = pts;                       // toler√¢ncia de toque
      const spreadOK = clusterOK(levels, 10); // 3 n√≠veis dentro de 10 pts

      const levs = levels.slice().sort((a,b)=>a-b);
      const minL = levs[0], maxL = levs[levs.length-1];
      const nearest = levs.reduce((best,lv)=> (Math.abs(px-lv) < Math.abs(px-best)? lv:best), levs[0]);

      const s = {
        side, // "BUY" | "SELL"
        recommendation: "AGUARDAR",
        entryRange: {min: NaN, max: NaN},
        entryRef: NaN,
        stopLoss: NaN,
        target: NaN,
        targetFinal: NaN,
        confidence: conf,
        positionSize: sizeByVol(vol18, conf),
        timeframe: "intraday",
        riskReward: 0,
        preArmNote: "",
        bandsNote: ""
      };

      if (!spreadOK){
        s.entryRange = { min: nearest, max: nearest };
        s.entryRef   = nearest;
      } else {
        s.entryRange = { min: minL, max: maxL };
        s.entryRef   = (minL + maxL)/2;
      }

      // stop 10 pts al√©m do √∫ltimo n√≠vel
      const stop = (side==="BUY") ? (minL - 10) : (maxL + 10);

      // alvo curto 10‚Äì15 pts a partir do ref
      const tgt  = (side==="BUY") ? (s.entryRef + pts) : (s.entryRef - pts);

      // alvo final = Just√≠ssimo quando a dire√ß√£o favorece
      const just = fair.justissimo;
      const aFavorDoJust = (side==="BUY"  && just > s.entryRef) ||
                           (side==="SELL" && just < s.entryRef);
      const tgtFinal = aFavorDoJust ? just : tgt;

      s.stopLoss = stop;
      s.target   = tgt;
      s.targetFinal = tgtFinal;

      // condi√ß√£o de ‚Äútoque/armado‚Äù
      const insideRange = (px >= s.entryRange.min - tol) && (px <= s.entryRange.max + tol);

      if (!insideRange){
        const dist = Math.min(Math.abs(px - s.entryRange.min), Math.abs(px - s.entryRange.max));
        const distPts = Math.round(dist); // <<< arredondado
        if (mode === "prearm"){
          s.recommendation = "AGUARDAR";
          s.preArmNote = `A ${distPts} pts da regi√£o (${F(s.entryRange.min)}‚Äì${F(s.entryRange.max)})`;
        } else {
          s.recommendation = "AGUARDAR";
          s.entryRange = {min: NaN, max: NaN};
          s.entryRef = NaN; s.stopLoss = NaN; s.target = NaN; s.targetFinal = NaN;
          s.preArmNote = `A ${distPts} pts da regi√£o`;
        }
      } else {
        s.recommendation = (side==="BUY") ? "COMPRA NA REGI√ÉO" : "VENDA NA REGI√ÉO";
      }

      // RR
      if (Number.isFinite(s.entryRef) && Number.isFinite(s.target) && Number.isFinite(s.stopLoss)){
        s.riskReward = RR(s.entryRef, s.target, s.stopLoss);
      }

      // nota de bandas (¬±1œÉ) como refer√™ncia
      if (g18) {
        if (side==="BUY") s.bandsNote = `Refer√™ncia bandas: -1œÉ ${F(g18.down1sigma)} | +1œÉ ${F(g18.up1sigma)}`;
        else              s.bandsNote = `Refer√™ncia bandas: +1œÉ ${F(g18.up1sigma)} | -1œÉ ${F(g18.down1sigma)}`;
      }

      return s;
    }

    // ============ ESTRAT√âGIA (2 cards) + OBJETO COMPAT ============
    ts.generateTradingStrategy = function(){
      const fair = getFair();
      const {buys, sells} = getLevels();
      const px   = Number(ts.lastClose()||0) || 0;
      const vol18 = (ts.analyzeSystemVolatility().p18||{}).volatilityPercent || 2.0;
      const conf  = Number(ts.calculateAdvancedConfidenceScore ? ts.calculateAdvancedConfidenceScore() : 60);
      const g18   = (ts.analyzeSystemGARCH()||{}).p18;

      // helpers locais para sele√ß√£o do compat
      function regionDistance(px, s){
        if (!s || !Number.isFinite(s.entryRange?.min) || !Number.isFinite(s.entryRange?.max)) return Infinity;
        const d1 = Math.abs(px - s.entryRange.min);
        const d2 = Math.abs(px - s.entryRange.max);
        return Math.min(d1, d2);
      }
      function centerDist(px, s){
        if (!s || !Number.isFinite(s.entryRange?.min) || !Number.isFinite(s.entryRange?.max)) return Infinity;
        const c = (s.entryRange.min + s.entryRange.max)/2;
        return Math.abs(px - c);
      }
      const isArmed = s => s && typeof s.recommendation==="string" && s.recommendation.includes("REGI√ÉO");

      // sem dados suficientes
      if (!fair.valid || (!buys.length && !sells.length)) {
        return {
          long: null,
          short: null,
          recommendation: "AGUARDAR",
          direction: null,
          entryZone: {min: NaN, max: NaN},
          target: NaN,
          stopLoss: NaN,
          riskReward: 0
        };
      }

      // monta os dois lados
      const long  = buys.length  ? buildSide("BUY",  px, buys,  fair, vol18, conf, g18)  : null;
      const short = sells.length ? buildSide("SELL", px, sells, fair, vol18, conf, g18) : null;

      // ===== escolhe um lado para o compat =====
      let chosen = null;
      if (isArmed(long) || isArmed(short)){
        const cand = [long, short].filter(isArmed);
        chosen = cand.sort((a,b)=>centerDist(px,a)-centerDist(px,b))[0] || null;
      } else {
        const dL = regionDistance(px,long), dS = regionDistance(px,short);
        chosen = (dL < dS) ? long : short;
      }

      // monta campos compat
      let compat = {
        recommendation: "AGUARDAR",
        direction: null,
        entryZone: {min: NaN, max: NaN},
        target: NaN,
        stopLoss: NaN,
        riskReward: 0
      };
      if (chosen){
        compat.recommendation = isArmed(chosen)
          ? (chosen.side==="BUY" ? "COMPRA NA REGI√ÉO" : "VENDA NA REGI√ÉO")
          : "AGUARDAR";
        compat.direction = chosen.side==="BUY" ? "BUY" : "SELL";
        compat.entryZone = { min: chosen.entryRange?.min, max: chosen.entryRange?.max };
        compat.target    = chosen.target;
        compat.stopLoss  = chosen.stopLoss;
        compat.riskReward= chosen.riskReward || 0;
      }

      // devolve os dois cards + o compat na mesma resposta
      return Object.assign(compat, { long, short });
    };

    // ============ PAINEL (dois cards) + Toggle ============
    ts.renderStrategyPanel = function(){
      const out = ts.generateTradingStrategy();
      const op = document.getElementById("aiOperation");
      const rk = document.getElementById("aiRisk");
      const lv = document.getElementById("aiLevels");
      if (!op || !rk || !lv) return;

      const mode = getTouchMode();
      const toggle = `
        <div style="margin:-6px 0 8px 0; display:flex; gap:12px; align-items:center;">
          <label style="font-size:12px; font-weight:700;">Modo:</label>
          <label style="font-size:12px; display:flex; gap:6px; align-items:center; cursor:pointer;">
            <input id="prearmToggle" type="checkbox" ${mode==="prearm"?"checked":""} />
            <span>Pr√©-armar</span>
          </label>
          <span style="font-size:11px; color:#475569;">(desmarque para exigir toque)</span>
        </div>`;

      function cta(s){
        if (!s) return {title:"Aguardando dados", detail:""};
        const dirTxt = s.side==="BUY" ? "COMPRA" : "VENDA";
        const armed  = s.recommendation.includes("REGI√ÉO");
        const title  = armed
          ? `‚úÖ <b>${dirTxt} NA REGI√ÉO</b> ${F(s.entryRange.min)}‚Äì${F(s.entryRange.max)}`
          : `‚è≥ <b>PREPARAR ${dirTxt}</b> ${s.preArmNote ? "‚Äî "+s.preArmNote : ""}`;

        const pts = (Number.isFinite(s.entryRef) && Number.isFinite(s.stopLoss))
                      ? Math.abs(s.entryRef - s.stopLoss).toFixed(0) : "--";

        const detail = `
          <span style="display:block;margin-top:4px;">
            üîî <b>Gatilho:</b> tocar regi√£o ${F(s.entryRange.min)}‚Äì${F(s.entryRange.max)} ¬∑
            üõë <b>Stop:</b> ${F(s.stopLoss)} (${pts} pts ap√≥s √∫ltima ${s.side==="BUY"?"m√≠nima":"m√°xima"}) ¬∑
            üéØ <b>Alvo:</b> ${F(s.target)}${(s.targetFinal && s.targetFinal!==s.target) ? ` ‚Üí ${F(s.targetFinal)}` : ""} ¬∑
            üìä <b>R/R:</b> ${(s.riskReward>0 && Number.isFinite(s.riskReward)) ? ("1:"+s.riskReward.toFixed(2)):"--"}
          </span>
          ${s.bandsNote ? `<span style="display:block;margin-top:4px; font-size:12px; color:#475569;">${s.bandsNote}</span>`:""}
        `;
        return {title, detail};
      }

      const L = cta(out.long), S = cta(out.short);

      // dois cards (verde compra, vermelho venda)
      op.innerHTML = `
        <div class="card-grid">
          <div class="card card-success">
            ${toggle}
            <h4>üü¢ COMPRA ‚Äî 3 M√çNIMAS</h4>
            <p>${L.title}</p>
            ${L.detail}
            <p style="margin-top:6px;">‚è≥ <b>Prazo:</b> intraday &nbsp; üìà <b>Confian√ßa:</b> ${out.long? out.long.confidence:"--"}% &nbsp; üì¶ <b>Tamanho:</b> ${out.long? out.long.positionSize:"--"}</p>
          </div>

          <div class="card card-danger">
            <h4>üî¥ VENDA ‚Äî 3 M√ÅXIMAS</h4>
            <p>${S.title}</p>
            ${S.detail}
            <p style="margin-top:6px;">‚è≥ <b>Prazo:</b> intraday &nbsp; üìà <b>Confian√ßa:</b> ${out.short? out.short.confidence:"--"}% &nbsp; üì¶ <b>Tamanho:</b> ${out.short? out.short.positionSize:"--"}</p>
          </div>
        </div>
      `;

      // liga o toggle
      const cb = op.querySelector("#prearmToggle");
      if (cb){
        cb.addEventListener("change", ()=>{
          setTouchMode(cb.checked ? "prearm" : "strict");
          try{ ts.renderStrategyPanel(); }catch(_){}
        }, { once:true });
      }

      // Gest√£o de risco (texto)
      rk.innerHTML = `
        <div class="card-grid">
          <div class="card card-info" style="border-color:#fca5a5; background:linear-gradient(180deg,#fef2f2,#ffffff);">
            <h4>‚ö†Ô∏è GEST√ÉO DE RISCO</h4>
            <p>‚Ä¢ Trabalhar a <b>regi√£o</b> quando as 3 m√≠nimas/m√°ximas estiverem a ‚â§10 pts entre si;</p>
            <p>‚Ä¢ <b>Stop:</b> 10 pts al√©m da √∫ltima m√°xima/m√≠nima (lado da opera√ß√£o);</p>
            <p>‚Ä¢ <b>Alvo curto:</b> 10‚Äì15 pts (din√¢mico pela vol 18P); <b>Alvo final:</b> Just√≠ssimo quando a dire√ß√£o favorecer;</p>
            <p>‚Ä¢ <b>Break-even:</b> ao atingir +8 pts a favor, mover stop para o pre√ßo de entrada;</p>
            <p>‚Ä¢ <b>Ru√≠do:</b> reduzir lote se vol 18P > 3.0%.</p>
          </div>
        </div>
      `;

      // N√≠veis de decis√£o (GARCH 18P) ‚Äî tipografia do print
const g = (ts.analyzeSystemGARCH()||{}).p18;
const up1 = g?.up1sigma, dn1 = g?.down1sigma;

// helper local para 2 casas (sem mexer em escala)
const F2 = v => (Number.isFinite(v) ? Number(v).toFixed(2) : "--");

lv.innerHTML = `
  <div class="nd-wrap">
    <h4 class="nd-title">üß∑ N√≠veis de Decis√£o</h4>
    <div class="nd-row">
      <div class="nd-pill">
        <div class="nd-label red">RESIST√äNCIA FORTE</div>
        <div class="nd-value">${F2(up1)}</div>
      </div>
      <div class="nd-pill">
        <div class="nd-label green">SUPORTE FORTE</div>
        <div class="nd-value">${F2(dn1)}</div>
      </div>
    </div>
  </div>
`;


    };

    // re-render autom√°tico
    hookAfter(ts, "performAIAnalysis", ()=>{ try{ ts.renderStrategyPanel(); }catch(_){} });
    hookAfter(ts, "updateAIDisplay",   ()=>{ try{ ts.renderStrategyPanel(); }catch(_){} });
    setTimeout(()=>{ try{ ts.renderStrategyPanel(); }catch(_){} }, 200);
  } // apply(ts)

  function hookAfter(obj, method, after){
    try{
      if (typeof obj[method] !== "function") return;
      const orig = obj[method].bind(obj);
      obj[method] = function(){ const r = orig.apply(obj, arguments); try{ after(); }catch(_){ } return r; };
    }catch(_){}
  }
})();
</script>

	
<style>


  
  /* ‚Äî‚Äî N√≠veis de Decis√£o (tipografia do print) ‚Äî‚Äî */
.nd-wrap { background:#eef6ff; border-radius:12px; padding:14px; }
.nd-title { font-weight:800; color:#2563eb; margin:0 0 10px; font-size:14px; display:flex; align-items:center; gap:8px; }
.nd-row { display:grid; grid-template-columns:1fr 1fr; gap:12px; }

.nd-pill {
  background:#fff; border:1px solid #e5e7eb; border-radius:12px;
  padding:12px 10px; text-align:center;
  box-shadow:0 1px 0 rgba(0,0,0,.02);
}
.nd-label { font-weight:900; font-size:12px; letter-spacing:.3px; margin-bottom:6px; }
.nd-label.red { color:#ef4444; }      /* RESIST√äNCIA */
.nd-label.green { color:#059669; }    /* SUPORTE    */
.nd-value { font-size:18px; font-weight:900; color:#0f172a; }
@media(max-width:480px){ .nd-row{ grid-template-columns:1fr; } }

</style>


<!-- ===== BACKTEST GARCH ‚Äî CONSOLIDADO (V2) ===== -->
<style id="gbStyles-v2">
/* Painel */
#garchBacktestPanel{border:1px solid var(--border,#e5e7eb);border-radius:16px;background:linear-gradient(180deg,#f8fafc,#ffffff);box-shadow:0 1px 3px rgba(0,0,0,.06);margin-top:14px;padding:16px}
#garchBacktestPanel .section-title{display:flex;align-items:center;gap:8px;font-weight:800;font-size:16px;color:#0f172a;margin:10px 0 12px}
#garchBacktestPanel .section-title::before{content:"üìà";font-size:18px}
/* Grid: controles (esq) + bot√£o (dir) */
#garchBacktestPanel .gb-row{display:grid;grid-template-columns:minmax(0,1fr) 230px;gap:14px;align-items:start}
#garchBacktestPanel .gb-col-controls{display:grid;grid-template-columns:1fr;gap:10px}
/* P√≠lulas */
#garchBacktestPanel .gb-control{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px 10px 12px;box-shadow:0 1px 0 rgba(0,0,0,.03)}
#garchBacktestPanel .gb-control label{display:block;margin:0 0 6px;font-size:11px;letter-spacing:.3px;text-transform:uppercase;color:#475569;font-weight:900}
#garchBacktestPanel .gb-control input,#garchBacktestPanel .gb-control select{width:100%;height:40px;line-height:40px;border:1px solid #e2e8f0;border-radius:10px;padding:0 12px;font-weight:800;color:#0f172a;background:#fff;outline:none;appearance:auto}
#garchBacktestPanel .gb-control input::placeholder{color:#94a3b8;font-weight:600}
#garchBacktestPanel .gb-control input:focus,#garchBacktestPanel .gb-control select:focus{border-color:#93c5fd;box-shadow:0 0 0 3px rgba(59,130,246,.18)}
/* Bot√µes (direita) */
#garchBacktestPanel .gb-buttons{display:flex;flex-direction:column;gap:10px;align-items:stretch}
#garchBacktestPanel #gbRun{height:100%;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#3b82f6,#6366f1);color:#fff;border:none;border-radius:12px;padding:12px 14px;font-weight:900;letter-spacing:.2px;box-shadow:0 6px 16px rgba(59,130,246,.25)}
#garchBacktestPanel #gbRun:hover{transform:translateY(-1px);box-shadow:0 8px 20px rgba(59,130,246,.30)}
#garchBacktestPanel #gbExport{background:#fff;border:1px solid #e5e7eb;color:#0f172a;border-radius:12px;padding:12px 14px;font-weight:800;white-space:nowrap}
#garchBacktestPanel #gbExport:disabled{opacity:.5;cursor:not-allowed}
/* Resumo e tabela */
#garchBacktestPanel .gb-summary{background:#f1f5f9;border:1px dashed #cbd5e1;border-radius:12px;padding:10px 12px;font-size:13px;color:#334155}
#garchBacktestPanel .gb-table-wrap{max-height:340px;overflow:auto;border:1px solid #e5e7eb;border-radius:12px;background:#fff}
#garchBacktestPanel .gb-table{width:100%;border-collapse:separate;border-spacing:0}
#garchBacktestPanel .gb-table thead th{position:sticky;top:0;z-index:1;background:#fff;border-bottom:1px solid #e5e7eb;font-weight:900;font-size:12px;color:#334155;padding:10px 12px}
#garchBacktestPanel .gb-table td{padding:10px 12px;font-size:12px;color:#0f172a}
#garchBacktestPanel .gb-table tbody tr:nth-child(odd){background:#f9fafb}
#garchBacktestPanel .gb-table tbody tr:hover{background:#eef2ff}
/* Badges */
.gb-badge{display:inline-block;padding:3px 8px;border-radius:999px;font-weight:900;font-size:11px}
.gb-badge.buy{background:#dcfce7;color:#065f46}.gb-badge.sell{background:#fee2e2;color:#991b1b}.gb-badge.win{background:#e0f2fe;color:#075985}.gb-badge.loss{background:#fee2e2;color:#991b1b}
/* Responsivo */
@media (max-width:760px){#garchBacktestPanel .gb-row{grid-template-columns:1fr}#garchBacktestPanel .gb-buttons{flex-direction:row}#garchBacktestPanel #gbRun{height:auto}}
</style>

<script>
(() => {
  // evita duplicar
  if (window.__GB_BACKTEST_V2__) return; window.__GB_BACKTEST_V2__ = true;

  // instala quando o app existir
  const boot = setInterval(() => { const ts = window.tradingSystem; if (!ts) return; clearInterval(boot); install(ts); }, 100);

  function install(ts){
    const anchor = document.getElementById("aiStrategyPanel") || document.getElementById("ai-analysis-panel") || document.getElementById("proj-panel") || document.body;

    // limpa vers√µes antigas do painel
    document.querySelectorAll("#garchBacktestPanel").forEach(n => n.remove());

    const wrap = document.createElement("div");
    wrap.id = "garchBacktestPanel";
    wrap.className = "panel";
    wrap.innerHTML = `
      <h2 class="section-title">Backtest (GARCH)</h2>
      <div class="gb-row">
        <div class="gb-col-controls">
          <div class="gb-control"><label>Janela (barras)</label><input id="gbWindow" type="number" min="20" step="10" placeholder="ex.: 60 (vazio = tudo)" /></div>
          <div class="gb-control"><label>Look-ahead (barras)</label><input id="gbLook" type="number" min="1" step="1" value="5" /></div>
          <div class="gb-control"><label>Usar alvo final (Just√≠ssimo)</label>
            <select id="gbUseFair"><option value="no" selected>N√£o (s√≥ alvo curto)</option><option value="yes">Sim (se favorecer)</option></select>
          </div>
        </div>
        <div class="gb-buttons">
          <button class="btn ai" id="gbRun">‚ñ∂Ô∏è Rodar Backtest</button>
          <button class="btn" id="gbExport" disabled>‚¨áÔ∏è Exportar CSV</button>
        </div>
      </div>
      <div class="gb-summary" id="gbSummary">Aguardando execu√ß√£o‚Ä¶</div>
      <div class="gb-table-wrap">
        <table class="gb-table">
          <thead><tr><th>#</th><th>Data/Idx</th><th>Lado</th><th>Entrada</th><th>Alvo</th><th>Stop</th><th>Resultado</th><th>P/L (pts)</th></tr></thead>
          <tbody id="gbTbody"></tbody>
        </table>
      </div>`;
    anchor.insertAdjacentElement("afterend", wrap);

    // defaults UX
    const w = document.getElementById("gbWindow"), l = document.getElementById("gbLook"), s = document.getElementById("gbUseFair");
    if (w && (!w.value || Number(w.value)<=0)) w.value = "60";
    if (l && (!l.value || Number(l.value)<=0)) l.value = "5";
    if (s && !s.value) s.value = "no";

    document.getElementById("gbRun").addEventListener("click", () => runGarchBacktest(ts));
    document.getElementById("gbExport").addEventListener("click", exportCSV);
  }

  /* ===== C√°lculo ===== */
  const F2 = x => Number.isFinite(x) ? Number(x).toFixed(2) : "--";
  const PTSI = x => Number.isFinite(x) ? Math.round(x) : 0;
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }
  function vol18At(ts,start,idx){ const run = ts.linearReturns.slice(start, idx); if (run.length<18) return 2.0;
    const s = run.slice(-18), m = s.reduce((a,b)=>a+b,0)/s.length, v = s.reduce((q,r)=>q+Math.pow(r-m,2),0)/s.length; return Math.sqrt(v)*100; }
  function expLevels(ts,i){ const out={min:[],max:[]}, lc = ts.priceData[i];
    for (const p of [9,18,27]){ if (ts.linearReturns.length < p || i < p) continue;
      const sl = ts.linearReturns.slice(i-p,i), m=sl.reduce((a,b)=>a+b,0)/sl.length, v=sl.reduce((q,r)=>q+Math.pow(r-m,2),0)/sl.length, sd=Math.sqrt(v);
      const ef = ts.getExpFor ? ts.getExpFor(p) : 2.718, ex = Math.pow(ef, sd); out.max.push(lc*ex); out.min.push(lc/ex); } return out; }
  function distToRange(px,a,b){ const lo=Math.min(a,b), hi=Math.max(a,b); if(px<lo) return lo-px; if(px>hi) return px-hi; return 0; }
  function clusterRegion(levels,spread,px){ const lv=(levels||[]).filter(Number.isFinite).slice().sort((a,b)=>a-b); if(!lv.length) return null;
    const min=lv[0], max=lv[lv.length-1]; if(lv.length>=2 && (max-min)<=spread) return {min,max,ref:(min+max)/2,isCluster:true};
    const nearest=lv.reduce((best,cur)=>Math.abs(px-cur)<Math.abs(px-best)?cur:best,lv[0]); return {min:nearest,max:nearest,ref:nearest,isCluster:false}; }
  function fairCombined(ts,price){ const g=id=>document.getElementById(id);
    const pppRate=parseFloat(g('ppp_rate')?.value||5.30), infBR=parseFloat(g('inflation_br')?.value||4.5)/100, infUS=parseFloat(g('inflation_us')?.value||3.2)/100,
          selic=parseFloat(g('selic_rate')?.value||13.75)/100, fed=parseFloat(g('fed_rate')?.value||5.50)/100, risk=parseFloat(g('risk_premium')?.value||2.5)/100;
    let ppp=pppRate; if(price>100) ppp=pppRate*1000; const fairPPP=ppp*((1+infBR)/(1+infUS)), net=(selic-fed)-risk, uip=1+(net*0.15), fairUIP=price*uip;
    const bounded=Math.max(price*0.8,Math.min(price*1.2,fairUIP)), comb=0.4*fairPPP+0.6*bounded; return Math.max(price*0.75,Math.min(price*1.25,comb)); }

  function runGarchBacktest(ts){
    const sum = document.getElementById("gbSummary"), tb = document.getElementById("gbTbody"), btn = document.getElementById("gbExport");
    if (!ts.priceData || ts.priceData.length<30){ sum.textContent="Carregue ‚â• 30 pre√ßos (Excel/Simulado) e rode An√°lise."; return; }
    ts.calculateLinearReturns();

    const N = parseInt(document.getElementById("gbWindow")?.value||0,10);
    const LH = Math.max(1, parseInt(document.getElementById("gbLook")?.value||5,10));
    const USE_FAIR = (document.getElementById("gbUseFair")?.value==="yes");
    const start = (N>0 && N<ts.priceData.length) ? (ts.priceData.length - N) : 0;

    const spread=10, log=[], res={BUY:{win:0,loss:0,pl:0,trades:0}, SELL:{win:0,loss:0,pl:0,trades:0}};
    let cNoLv=0, cNoIn=0;

    for (let i=start+27; i<ts.priceData.length-1; i++){
      const px=ts.priceData[i], vol=vol18At(ts,start,i), pts=choosePts(vol), lv=expLevels(ts,i);
      if (!lv.min.length && !lv.max.length){ cNoLv++; continue; }

      const rB=clusterRegion(lv.min,spread,px), rS=clusterRegion(lv.max,spread,px);
      const cand=[];
      if (rB){ const d=distToRange(px, rB.min-pts, rB.max+pts); if (d<=pts){ let tgt=rB.ref+pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j>rB.ref) tgt=j; }
        cand.push({dir:"BUY",idx:i,entry:rB.ref,stop:rB.min-10,tgt,pts}); } }
      if (rS){ const d=distToRange(px, rS.min-pts, rS.max+pts); if (d<=pts){ let tgt=rS.ref-pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j<rS.ref) tgt=j; }
        cand.push({dir:"SELL",idx:i,entry:rS.ref,stop:rS.max+10,tgt,pts}); } }
      if (!cand.length){ cNoIn++; continue; }

      for (const tr of cand){
        let outcome="NEUTRO", pl=0;
        for (let k=1; k<=LH && (i+k)<ts.priceData.length; k++){
          const pN=ts.priceData[i+k];
          if (tr.dir==="BUY"){ if (pN>=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.tgt-tr.entry); break; }
                               if (pN<=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.entry-tr.stop); break; } }
          else               { if (pN<=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.entry-tr.tgt); break; }
                               if (pN>=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.stop-tr.entry); break; } }
        }
        if (outcome==="NEUTRO"){ const last=ts.priceData[i+LH] ?? ts.priceData[ts.priceData.length-1]; pl=(tr.dir==="BUY")?(last-tr.entry):(tr.entry-last); }
        if (outcome==="WIN") res[tr.dir].win++; if (outcome==="LOSS") res[tr.dir].loss++; res[tr.dir].trades++; res[tr.dir].pl+=pl;
        log.push({n:log.length+1,idx:tr.idx,side:tr.dir,entry:tr.entry,tgt:tr.tgt,stop:tr.stop,outcome,pl});
      }
    }
    renderResult(res, log, cNoLv, cNoIn);
  }

  function renderResult(res,log,cNoLv,cNoIn){
    const sum=document.getElementById("gbSummary"), tb=document.getElementById("gbTbody"), btn=document.getElementById("gbExport"); tb.innerHTML="";
    const met = d => { const hit=d.trades? (d.win/d.trades)*100 : 0; const avg=d.trades? (d.pl/d.trades) : 0; const rr=Math.abs(avg)/12 || 0;
      return {trades:d.trades, win:d.win, loss:d.loss, hit:hit.toFixed(1)+"%", pl:PTSI(d.pl), rr:rr.toFixed(2)+"x"}; };
    const B=met(res.BUY), S=met(res.SELL);
    sum.innerHTML = `<b>Resultado:</b>
      <br>üü¢ BUY ‚Üí trades: <b>${B.trades}</b> | win: <b>${B.win}</b> | loss: <b>${B.loss}</b> | hit: <b>${B.hit}</b> | P/L: <b>${B.pl} pts</b> | R/R efetivo: <b>${B.rr}</b>
      <br>üî¥ SELL ‚Üí trades: <b>${S.trades}</b> | win: <b>${S.win}</b> | loss: <b>${S.loss}</b> | hit: <b>${S.hit}</b> | P/L: <b>${S.pl} pts</b> | R/R efetivo: <b>${S.rr}</b>
      ${(B.trades+S.trades===0)?`<div style="margin-top:8px;font-size:12px;color:#334155"><b>Diagn√≥stico</b>: sem n√≠veis em ${cNoLv} barras; fora da regi√£o em ${cNoIn} barras. Tente Janela=60, Look-ahead=5.</div>`:""}`;
    for (const r of log){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${r.n}</td><td>${r.idx}</td>
        <td><span class="gb-badge ${r.side==='BUY'?'buy':'sell'}">${r.side}</span></td>
        <td>${F2(r.entry)}</td><td>${F2(r.tgt)}</td><td>${F2(r.stop)}</td>
        <td><span class="gb-badge ${r.outcome==='WIN'?'win':(r.outcome==='LOSS'?'loss':'')}">${r.outcome}</span></td>
        <td>${PTSI(r.pl)}</td>`;
      tb.appendChild(tr);
    }
    btn.disabled = (log.length===0); btn.dataset.csv = JSON.stringify(log);
  }

  function exportCSV(e){
    const data = JSON.parse(e.currentTarget.dataset.csv || "[]"); if (!data.length) return;
    const header=["n","idx","side","entry","tgt","stop","outcome","pl"];
    const lines=[header.join(",")].concat(data.map(r=>[r.n,r.idx,r.side,F2(r.entry),F2(r.tgt),F2(r.stop),r.outcome,PTSI(r.pl)].join(",")));
    const blob=new Blob([lines.join("\n")],{type:"text/csv;charset=utf-8;"}), url=URL.createObjectURL(blob), a=document.createElement("a");
    a.href=url; a.download="backtest_garch.csv"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }
})();
</script>
<script>
(() => {
  // S√≥ roda se o V2 estiver instalado
  if (!window.__GB_BACKTEST_V2__) return;

  // Sobrescreve apenas o executor para usar tol/spread ‚Äúamig√°veis‚Äù
  const ts = window.tradingSystem;
  if (!ts) return;

  // === Helpers (mesmos do V2) ===
  const F2 = x => Number.isFinite(x) ? Number(x).toFixed(2) : "--";
  const PTSI = x => Number.isFinite(x) ? Math.round(x) : 0;
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }
  function vol18At(ts,start,idx){ const run=ts.linearReturns.slice(start,idx); if(run.length<18) return 2.0;
    const s=run.slice(-18), m=s.reduce((a,b)=>a+b,0)/s.length, v=s.reduce((q,r)=>q+Math.pow(r-m,2),0)/s.length; return Math.sqrt(v)*100; }
  function expLevels(ts,i){ const out={min:[],max:[]}, lc=ts.priceData[i];
    for(const p of [9,18,27]){ if(ts.linearReturns.length<p||i<p) continue;
      const sl=ts.linearReturns.slice(i-p,i), m=sl.reduce((a,b)=>a+b,0)/sl.length, v=sl.reduce((q,r)=>q+Math.pow(r-m,2),0)/sl.length, sd=Math.sqrt(v);
      const ef=ts.getExpFor?ts.getExpFor(p):2.718, ex=Math.pow(ef,sd); out.max.push(lc*ex); out.min.push(lc/ex); } return out; }
  function distToRange(px,a,b){ const lo=Math.min(a,b), hi=Math.max(a,b); if(px<lo) return lo-px; if(px>hi) return px-hi; return 0; }
  function clusterRegion(levels,spread,px){ const lv=(levels||[]).filter(Number.isFinite).slice().sort((a,b)=>a-b); if(!lv.length) return null;
    const min=lv[0], max=lv[lv.length-1]; if(lv.length>=2&&(max-min)<=spread) return {min,max,ref:(min+max)/2,isCluster:true};
    const nearest=lv.reduce((best,cur)=> Math.abs(px-cur)<Math.abs(px-best)?cur:best, lv[0]); return {min:nearest,max:nearest,ref:nearest,isCluster:false}; }
  function fairCombined(ts,price){ const g=id=>document.getElementById(id);
    const pppRate=parseFloat(g('ppp_rate')?.value||5.30), infBR=parseFloat(g('inflation_br')?.value||4.5)/100, infUS=parseFloat(g('inflation_us')?.value||3.2)/100,
          selic=parseFloat(g('selic_rate')?.value||13.75)/100, fed=parseFloat(g('fed_rate')?.value||5.50)/100, risk=parseFloat(g('risk_premium')?.value||2.5)/100;
    let ppp=pppRate; if(price>100) ppp=pppRate*1000; const fairPPP=ppp*((1+infBR)/(1+infUS)), net=(selic-fed)-risk, uip=1+(net*0.15), fairUIP=price*uip;
    const bounded=Math.max(price*0.8,Math.min(price*1.2,fairUIP)), comb=0.4*fairPPP+0.6*bounded; return Math.max(price*0.75,Math.min(price*1.25,comb)); }

  // Novo runner ‚Äúamig√°vel‚Äù
  function runGarchBacktestSoft(ts){
    const sum=document.getElementById("gbSummary"), tb=document.getElementById("gbTbody"), btn=document.getElementById("gbExport");
    if(!ts.priceData || ts.priceData.length<30){ sum.textContent="Carregue ‚â• 30 pre√ßos (Excel/Simulado) e rode An√°lise."; return; }
    ts.calculateLinearReturns();

    const N=parseInt(document.getElementById("gbWindow")?.value||0,10);
    const LH=Math.max(1,parseInt(document.getElementById("gbLook")?.value||5,10));
    const USE_FAIR=(document.getElementById("gbUseFair")?.value==="yes");

    const start=(N>0 && N<ts.priceData.length)? (ts.priceData.length-N) : 0;
    const usedBars = ts.priceData.length - start;

    const spread=12; // (antes 10)
    const log=[], res={BUY:{win:0,loss:0,pl:0,trades:0}, SELL:{win:0,loss:0,pl:0,trades:0}};
    let cNoLv=0, cNoIn=0;

    for(let i=start+27;i<ts.priceData.length-1;i++){
      const px=ts.priceData[i], vol=vol18At(ts,start,i), pts=choosePts(vol), tol=15; // (antes tol=pts)
      const lv=expLevels(ts,i); if(!lv.min.length && !lv.max.length){ cNoLv++; continue; }

      const rB=clusterRegion(lv.min,spread,px), rS=clusterRegion(lv.max,spread,px);
      const cand=[];

      if(rB){
        const d=distToRange(px, rB.min - tol, rB.max + tol);
        if(d<=tol){
          const stop=rB.min-10; let tgt=rB.ref+pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j>rB.ref) tgt=j; }
          cand.push({dir:"BUY",idx:i,entry:rB.ref,stop,tgt});
        }
      }
      if(rS){
        const d=distToRange(px, rS.min - tol, rS.max + tol);
        if(d<=tol){
          const stop=rS.max+10; let tgt=rS.ref-pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j<rS.ref) tgt=j; }
          cand.push({dir:"SELL",idx:i,entry:rS.ref,stop,tgt});
        }
      }
      if(!cand.length){ cNoIn++; continue; }

      for(const tr of cand){
        let outcome="NEUTRO", pl=0;
        for(let k=1;k<=LH && (i+k)<ts.priceData.length;k++){
          const p=ts.priceData[i+k];
          if(tr.dir==="BUY"){ if(p>=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.tgt-tr.entry); break; }
                              if(p<=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.entry-tr.stop); break; } }
          else              { if(p<=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.entry-tr.tgt); break; }
                              if(p>=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.stop-tr.entry); break; } }
        }
        if(outcome==="NEUTRO"){ const last=ts.priceData[i+LH] ?? ts.priceData[ts.priceData.length-1]; pl=(tr.dir==="BUY")?(last-tr.entry):(tr.entry-last); }
        if(outcome==="WIN") res[tr.dir].win++; if(outcome==="LOSS") res[tr.dir].loss++; res[tr.dir].trades++; res[tr.dir].pl+=pl;
        log.push({n:log.length+1,idx:tr.idx,side:tr.dir,entry:tr.entry,tgt:tr.tgt,stop:tr.stop,outcome,pl});
      }
    }

    // resumo + barras usadas
    const met=d=>{const hit=d.trades?(d.win/d.trades)*100:0, avg=d.trades?(d.pl/d.trades):0, rr=Math.abs(avg)/12||0;
      return {trades:d.trades, win:d.win, loss:d.loss, hit:hit.toFixed(1)+"%", pl:PTSI(d.pl), rr:rr.toFixed(2)+"x"};};
    const B=met(res.BUY), S=met(res.SELL);
    sum.innerHTML = `<b>Resultado (barras usadas: ${usedBars})</b>
      <br>üü¢ BUY ‚Üí trades: <b>${B.trades}</b> | win: <b>${B.win}</b> | loss: <b>${B.loss}</b> | hit: <b>${B.hit}</b> | P/L: <b>${B.pl} pts</b> | R/R efetivo: <b>${B.rr}</b>
      <br>üî¥ SELL ‚Üí trades: <b>${S.trades}</b> | win: <b>${S.win}</b> | loss: <b>${S.loss}</b> | hit: <b>${S.hit}</b> | P/L: <b>${S.pl} pts</b> | R/R efetivo: <b>${S.rr}</b>
      ${(B.trades+S.trades===0)?`<div style="margin-top:8px;font-size:12px;color:#334155"><b>Diagn√≥stico</b>: sem n√≠veis em ${cNoLv} barras; fora da regi√£o em ${cNoIn} barras.</div>`:""}`;

    const tb=document.getElementById("gbTbody"); tb.innerHTML="";
    for(const r of log){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${r.n}</td><td>${r.idx}</td>
        <td><span class="gb-badge ${r.side==='BUY'?'buy':'sell'}">${r.side}</span></td>
        <td>${F2(r.entry)}</td><td>${F2(r.tgt)}</td><td>${F2(r.stop)}</td>
        <td><span class="gb-badge ${r.outcome==='WIN'?'win':(r.outcome==='LOSS'?'loss':'')}">${r.outcome}</span></td>
        <td>${PTSI(r.pl)}</td>`;
      tb.appendChild(tr);
    }
    const btn=document.getElementById("gbExport"); btn.disabled=(log.length===0); btn.dataset.csv=JSON.stringify(log);
  }

  // pluga o bot√£o no runner ‚Äúsoft‚Äù
  const runBtn=document.getElementById("gbRun"); if(runBtn){ runBtn.onclick=()=>runGarchBacktestSoft(ts); }
})();
</script>


<!-- ===== FIM BACKTEST GARCH ‚Äî CONSOLIDADO (V2) ===== -->

<!-- ===== NORMALIZADOR DE LAYOUT ‚Äî BACKTEST (apenas 1x) ===== -->
<script>
(() => {
  // 1) Desativa estilos antigos que conflitam
  const badIds = [
    "gbStyles","gbStyles-polish","gbStyles-unified","gbStyles-unified-v2",
    "gbStyles-compact","gbStyles-stack","gbStyles-clean",
    "gbStyles-hotfix","gbStyles-hotfix-final","final-ui-fix","gbStyles-v2-tune"
  ];
  badIds.forEach(id => document.getElementById(id)?.remove());

  // Remove qualquer <style> inline que contenha regras antigas de '.level-col'
  Array.from(document.querySelectorAll("style")).forEach(st => {
    const txt = (st.textContent || "").toLowerCase();
    if (txt.includes(".level-col ")) st.remove();
  });

  // 2) Normaliza a estrutura do painel (coluna de controles + coluna do bot√£o)
  const panel = document.getElementById("garchBacktestPanel");
  if (panel){
    const row = panel.querySelector(".gb-row") || panel.querySelector(".gbRow");
    if (row){
      // cria/garante a coluna de controles
      let col = row.querySelector(".gb-col-controls");
      if (!col){
        col = document.createElement("div");
        col.className = "gb-col-controls";
        row.insertBefore(col, row.firstChild);
      }
      // move todos os .gb-control para a coluna (deixa .gb-buttons de fora)
      Array.from(row.querySelectorAll(".gb-control")).forEach(ctrl => {
        if (ctrl.parentElement !== col) col.appendChild(ctrl);
      });

      // afrouxa qualquer sticky/altura da coluna de bot√µes
      const buttons = row.querySelector(".gb-buttons");
      if (buttons){
        buttons.style.position = "static";
        buttons.style.height   = "auto";
        buttons.style.display  = "flex";
        buttons.style.flexDirection = "column";
        buttons.style.gap = "10px";
        // bot√£o em altura natural
        const run = buttons.querySelector("#gbRun");
        if (run){ run.style.height = "auto"; run.textContent = "‚ñ∂Ô∏è Rodar Backtest"; }
      }
    }
  }
})();
</script>

<style id="gbStyles-final">
/* === Grid est√°vel: controles (esq) + bot√£o (dir) === */
#garchBacktestPanel .gb-row{
  display:grid !important;
  grid-template-columns: minmax(0,1fr) 230px !important;
  gap:16px !important;
  align-items:start !important;
}
#garchBacktestPanel .gb-col-controls{
  display:grid !important;
  grid-template-columns: 1fr !important; /* um embaixo do outro */
  gap:10px !important;
}

/* === P√≠lulas de controle (compactas) === */
#garchBacktestPanel .gb-control{
  background:#fff !important;
  border:1px solid #e5e7eb !important;
  border-radius:12px !important;
  padding:10px 12px !important;
  box-shadow:0 1px 0 rgba(0,0,0,.03) !important;
}
#garchBacktestPanel .gb-control label{
  display:block !important;
  margin:0 0 6px !important;
  font-size:11px !important;
  letter-spacing:.3px !important;
  text-transform:uppercase !important;
  font-weight:900 !important;
  color:#475569 !important;
}
#garchBacktestPanel .gb-control input,
#garchBacktestPanel .gb-control select{
  width:100% !important;
  height:40px !important; line-height:40px !important;
  border:1px solid #e2e8f0 !important;
  border-radius:10px !important;
  padding:0 12px !important;
  background:#fff !important; color:#0f172a !important;
  font-weight:800 !important; outline:none !important; appearance:auto !important;
}
#garchBacktestPanel .gb-control input::placeholder{ color:#94a3b8; font-weight:600; }

/* === Coluna de bot√µes (direita) ‚Äî sem sticky nem 100% de altura === */
#garchBacktestPanel .gb-buttons{
  position: static !important;
  display:flex !important; flex-direction:column !important;
  gap:10px !important; align-items:stretch !important;
  height:auto !important;
}
#garchBacktestPanel #gbRun{
  height:auto !important;
  background:linear-gradient(135deg,#3b82f6,#6366f1) !important;
  color:#fff !important; border:none !important; border-radius:12px !important;
  padding:12px 14px !important; font-weight:900 !important;
  box-shadow:0 6px 16px rgba(59,130,246,.25) !important;
}

/* === Tipos dentro dos pain√©is (fontes contidas) === */
#aiStrategyPanel .card, #aiStrategyPanel .insight-card { font-size:13px !important; }
#aiStrategyPanel h4 { font-size:14px !important; margin:0 0 6px !important; }
#aiStrategyPanel .value { font-size:16px !important; }

/* N√≠veis de Decis√£o (nd-*) */
.nd-label { font-size:12px !important; }
.nd-value { font-size:16px !important; }

/* Tabela do backtest */
#garchBacktestPanel .gb-table td,
#garchBacktestPanel .gb-table thead th { font-size:12px !important; }

/* Responsivo */
@media (max-width:760px){
  #garchBacktestPanel .gb-row{ grid-template-columns:1fr !important; }
  #garchBacktestPanel .gb-buttons{ flex-direction:row !important; }
  #garchBacktestPanel #gbRun{ height:auto !important; }
}
</style>
<script>
/* Force o bot√£o a usar o runner soft assim que o painel existir */
(() => {
  function attachSoftRunner(){
    const ts  = window.tradingSystem;
    const btn = document.getElementById("gbRun");
    if (!ts || !btn){ setTimeout(attachSoftRunner, 150); return; }

    // === helpers iguais aos do bloco soft j√° existente ===
    const F2 = x => Number.isFinite(x) ? Number(x).toFixed(2) : "--";
    const PTSI = x => Number.isFinite(x) ? Math.round(x) : 0;
    function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }
    function vol18At(ts,start,idx){ const run=ts.linearReturns.slice(start,idx); if(run.length<18) return 2.0;
      const s=run.slice(-18), m=s.reduce((a,b)=>a+b,0)/s.length, v=s.reduce((q,r)=>q+Math.pow(r-m,2),0)/s.length; return Math.sqrt(v)*100; }
    function expLevels(ts,i){ const out={min:[],max:[]}, lc=ts.priceData[i];
      for(const p of [9,18,27]){ if(ts.linearReturns.length<p||i<p) continue;
        const sl=ts.linearReturns.slice(i-p,i), m=sl.reduce((a,b)=>a+b,0)/sl.length, v=sl.reduce((q,r)=>q+Math.pow(r-m,2),0)/sl.length, sd=Math.sqrt(v);
        const ef=ts.getExpFor?ts.getExpFor(p):2.718, ex=Math.pow(ef,sd); out.max.push(lc*ex); out.min.push(lc/ex); } return out; }
    function distToRange(px,a,b){ const lo=Math.min(a,b), hi=Math.max(a,b); if(px<lo) return lo-px; if(px>hi) return px-hi; return 0; }
    function clusterRegion(levels,spread,px){ const lv=(levels||[]).filter(Number.isFinite).slice().sort((a,b)=>a-b); if(!lv.length) return null;
      const min=lv[0], max=lv[lv.length-1]; if(lv.length>=2&&(max-min)<=spread) return {min,max,ref:(min+max)/2,isCluster:true};
      const nearest=lv.reduce((best,cur)=> Math.abs(px-cur)<Math.abs(px-best)?cur:best, lv[0]); return {min:nearest,max:nearest,ref:nearest,isCluster:false}; }
    function fairCombined(ts,price){ const g=id=>document.getElementById(id);
      const pppRate=parseFloat(g('ppp_rate')?.value||5.30), infBR=parseFloat(g('inflation_br')?.value||4.5)/100, infUS=parseFloat(g('inflation_us')?.value||3.2)/100,
            selic=parseFloat(g('selic_rate')?.value||13.75)/100, fed=parseFloat(g('fed_rate')?.value||5.50)/100, risk=parseFloat(g('risk_premium')?.value||2.5)/100;
      let ppp=pppRate; if(price>100) ppp=pppRate*1000; const fairPPP=ppp*((1+infBR)/(1+infUS)), net=(selic-fed)-risk, uip=1+(net*0.15), fairUIP=price*uip;
      const bounded=Math.max(price*0.8,Math.min(price*1.2,fairUIP)), comb=0.4*fairPPP+0.6*bounded; return Math.max(price*0.75,Math.min(price*1.25,comb)); }

    function runSoft(){
      const sum=document.getElementById("gbSummary"), tb=document.getElementById("gbTbody"), csv=document.getElementById("gbExport");
      if(!ts.priceData || ts.priceData.length<30){ sum.textContent="Carregue ‚â• 30 pre√ßos (Excel/Simulado) e rode An√°lise."; return; }
      ts.calculateLinearReturns();

      const N = parseInt(document.getElementById("gbWindow")?.value||0,10);
      const LH = Math.max(1, parseInt(document.getElementById("gbLook")?.value||5,10));
      const USE_FAIR = (document.getElementById("gbUseFair")?.value==="yes");
      const start = (N>0 && N<ts.priceData.length)? (ts.priceData.length-N) : 0;
      const usedBars = ts.priceData.length - start;

      const spread=12, tol=15; // mais ‚Äúamig√°veis‚Äù p/ janelas grandes
      const log=[], res={BUY:{win:0,loss:0,pl:0,trades:0}, SELL:{win:0,loss:0,pl:0,trades:0}};
      let cNoLv=0, cNoIn=0;

      for(let i=start+27;i<ts.priceData.length-1;i++){
        const px=ts.priceData[i], vol=vol18At(ts,start,i), pts=choosePts(vol), lv=expLevels(ts,i);
        if(!lv.min.length && !lv.max.length){ cNoLv++; continue; }
        const rB=clusterRegion(lv.min,spread,px), rS=clusterRegion(lv.max,spread,px);
        const cand=[];
        if(rB){ const d=distToRange(px, rB.min-tol, rB.max+tol); if(d<=tol){ let tgt=rB.ref+pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j>rB.ref) tgt=j; }
          cand.push({dir:"BUY",idx:i,entry:rB.ref,stop:rB.min-10,tgt}); } }
        if(rS){ const d=distToRange(px, rS.min-tol, rS.max+tol); if(d<=tol){ let tgt=rS.ref-pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j<rS.ref) tgt=j; }
          cand.push({dir:"SELL",idx:i,entry:rS.ref,stop:rS.max+10,tgt}); } }
        if(!cand.length){ cNoIn++; continue; }

        for(const tr of cand){
          let outcome="NEUTRO", pl=0;
          for(let k=1;k<=LH && (i+k)<ts.priceData.length;k++){
            const p=ts.priceData[i+k];
            if(tr.dir==="BUY"){ if(p>=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.tgt-tr.entry); break; }
                                if(p<=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.entry-tr.stop); break; } }
            else              { if(p<=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.entry-tr.tgt); break; }
                                if(p>=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.stop-tr.entry); break; } }
          }
          if(outcome==="NEUTRO"){ const last=ts.priceData[i+LH] ?? ts.priceData[ts.priceData.length-1]; pl=(tr.dir==="BUY")?(last-tr.entry):(tr.entry-last); }
          if(outcome==="WIN") res[tr.dir].win++; if(outcome==="LOSS") res[tr.dir].loss++; res[tr.dir].trades++; res[tr.dir].pl+=pl;
          log.push({n:log.length+1,idx:tr.idx,side:tr.dir,entry:tr.entry,tgt:tr.tgt,stop:tr.stop,outcome,pl});
        }
      }

      const met=d=>{const hit=d.trades?(d.win/d.trades)*100:0, avg=d.trades?(d.pl/d.trades):0, rr=Math.abs(avg)/12||0;
        return {trades:d.trades, win:d.win, loss:d.loss, hit:hit.toFixed(1)+"%", pl:PTSI(d.pl), rr:rr.toFixed(2)+"x"};};
      const B=met(res.BUY), S=met(res.SELL);
      sum.innerHTML = `<b>Resultado (barras usadas: ${usedBars})</b>
        <br>üü¢ BUY ‚Üí trades: <b>${B.trades}</b> | win: <b>${B.win}</b> | loss: <b>${B.loss}</b> | hit: <b>${B.hit}</b> | P/L: <b>${B.pl} pts</b> | R/R efetivo: <b>${B.rr}</b>
        <br>üî¥ SELL ‚Üí trades: <b>${S.trades}</b> | win: <b>${S.win}</b> | loss: <b>${S.loss}</b> | hit: <b>${S.hit}</b> | P/L: <b>${S.pl} pts</b> | R/R efetivo: <b>${S.rr}</b>`;
      tb.innerHTML="";
      for(const r of log){
        const tr=document.createElement("tr");
        tr.innerHTML = `<td>${r.n}</td><td>${r.idx}</td>
          <td><span class="gb-badge ${r.side==='BUY'?'buy':'sell'}">${r.side}</span></td>
          <td>${F2(r.entry)}</td><td>${F2(r.tgt)}</td><td>${F2(r.stop)}</td>
          <td><span class="gb-badge ${r.outcome==='WIN'?'win':(r.outcome==='LOSS'?'loss':'')}">${r.outcome}</span></td>
          <td>${PTSI(r.pl)}</td>`;
        tb.appendChild(tr);
      }
      csv.disabled = (log.length===0);
      csv.dataset.csv = JSON.stringify(log);
    }

    btn.onclick = runSoft; // agora substitui com certeza
  }
  attachSoftRunner();
})();
</script>

<style id="gbLayout-final">
#garchBacktestPanel .gb-row{display:grid !important;grid-template-columns:minmax(0,1fr) 230px !important;gap:16px !important;align-items:start !important;}
#garchBacktestPanel .gb-col-controls{display:grid !important;grid-template-columns:1fr !important;gap:10px !important;}
#garchBacktestPanel .gb-buttons{position:static !important;display:flex !important;flex-direction:column !important;gap:10px !important;align-items:stretch !important;height:auto !important;}
#garchBacktestPanel #gbRun{height:auto !important;}
/* Tipografia contida dentro dos pain√©is */
#aiStrategyPanel .card, #aiStrategyPanel .insight-card{font-size:13px !important;}
#aiStrategyPanel h4{font-size:14px !important;margin:0 0 6px !important;}
#aiStrategyPanel .value{font-size:16px !important;}
.nd-label{font-size:12px !important;}
.nd-value{font-size:16px !important;}
#garchBacktestPanel .gb-table td, #garchBacktestPanel .gb-table thead th{font-size:12px !important;}
@media (max-width:760px){#garchBacktestPanel .gb-row{grid-template-columns:1fr !important}#garchBacktestPanel .gb-buttons{flex-direction:row !important}}
</style>
<script>
/* Backtest Layout ‚Äì normaliza DOM e coloca bot√µes onde voc√™ preferir */
(() => {
  const panel = document.getElementById("garchBacktestPanel");
  if (!panel) return;
  const row = panel.querySelector(".gb-row");
  if (!row) return;

  // 1) Garante a coluna de controles
  let col = row.querySelector(".gb-col-controls");
  if (!col) {
    col = document.createElement("div");
    col.className = "gb-col-controls";
    row.insertBefore(col, row.firstChild);
  }
  // move todos os .gb-control para a coluna (independente da posi√ß√£o atual)
  Array.from(row.querySelectorAll(".gb-control")).forEach(ctrl => {
    if (ctrl.parentElement !== col) col.appendChild(ctrl);
  });

  // 2) Garante o bloco de bot√µes e move para a posi√ß√£o desejada
  const buttons = row.querySelector(".gb-buttons");
  if (buttons) {
    // üëâ Op√ß√£o A: bot√µes ABAIXO dos controles (recomendado pela estabilidade visual)
    if (buttons.parentElement !== col) col.appendChild(buttons);

    // üëâ Op√ß√£o B: se quiser manter os bot√µes √† DIREITA,
    // comente a linha acima e descomente a linha abaixo:
    // if (buttons.parentElement !== row) row.appendChild(buttons);
  }
})();
</script>

<style id="backtest-layout-final">
/* ====== Grade principal ====== */
/* Op√ß√£o A (padr√£o): 1 coluna (controles + bot√µes embaixo) */
#garchBacktestPanel .gb-row{
  display:grid !important;
  grid-template-columns: 1fr !important;
  gap:14px !important;
  align-items:start !important;
}

/* Coluna de controles empilhados */
#garchBacktestPanel .gb-col-controls{
  display:grid !important;
  grid-template-columns: 1fr !important;
  gap:10px !important;
}

/* Bot√µes logo abaixo dos controles, largura total */
#garchBacktestPanel .gb-buttons{
  display:flex !important;
  flex-direction:row !important;
  gap:10px !important;
  align-items:stretch !important;
}

/* Bot√£o com altura do conte√∫do (sem tentar ocupar ‚Äútoda a coluna‚Äù) */
#garchBacktestPanel #gbRun{
  height:auto !important;
  background:linear-gradient(135deg,#3b82f6,#6366f1) !important;
  color:#fff !important; border:none !important;
  border-radius:12px !important; padding:12px 14px !important;
  font-weight:900 !important; box-shadow:0 6px 16px rgba(59,130,246,.25) !important;
}

/* P√≠lulas de controle (compactas) */
#garchBacktestPanel .gb-control{
  background:#fff !important;
  border:1px solid #e5e7eb !important;
  border-radius:12px !important;
  padding:10px 12px !important;
  box-shadow:0 1px 0 rgba(0,0,0,.03) !important;
}
#garchBacktestPanel .gb-control label{
  display:block !important; margin:0 0 6px !important;
  font-size:11px !important; letter-spacing:.3px !important;
  text-transform:uppercase !important; font-weight:900 !important; color:#475569 !important;
}
#garchBacktestPanel .gb-control input,
#garchBacktestPanel .gb-control select{
  width:100% !important; height:40px !important; line-height:40px !important;
  border:1px solid #e2e8f0 !important; border-radius:10px !important;
  padding:0 12px !important; background:#fff !important; color:#0f172a !important;
  font-weight:800 !important; outline:none !important; appearance:auto !important;
}
#garchBacktestPanel .gb-control input::placeholder{ color:#94a3b8; font-weight:600; }

/* Tipografia mais contida dentro dos pain√©is */
#aiStrategyPanel .card, #aiStrategyPanel .insight-card { font-size:13px !important; }
#aiStrategyPanel h4 { font-size:14px !important; margin:0 0 6px !important; }
#aiStrategyPanel .value { font-size:16px !important; }

/* N√≠veis (nd-*) */
.nd-label { font-size:12px !important; }
.nd-value { font-size:16px !important; }

/* Tabela do backtest */
#garchBacktestPanel .gb-table td,
#garchBacktestPanel .gb-table thead th { font-size:12px !important; }

/* ===== Se preferir os bot√µes √† DIREITA (modo 2 colunas), troque as 3 regras abaixo =====
#garchBacktestPanel .gb-row{ grid-template-columns:minmax(0,1fr) 230px !important; }
#garchBacktestPanel .gb-buttons{ flex-direction:column !important; }
@media (max-width:760px){ #garchBacktestPanel .gb-row{ grid-template-columns:1fr !important; } .gb-buttons{ flex-direction:row !important; } }
==================================================================== */
</style>
<script>
/* ===== Tiers de Entrada (N√≠vel 1 - Zona Principal: cluster; N√≠vel 2 - Extens√£o 18P/3: ¬±2œÉ 18P/27P) ===== */
(() => {
  const ts = window.tradingSystem;
  if (!ts) return;

  // ‚Äî helpers: usa os c√°lculos reais do seu sistema
  function garch(){ return ts.analyzeSystemGARCH() || {}; }
  function vol18(){ const v = ts.analyzeSystemVolatility(); return v?.p18?.volatilityPercent || 2.0; }
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }
  const F2 = v => Number.isFinite(v) ? Number(v).toFixed(2) : "--";

  // Constroi n√≠veis de 3 tiers por LADO
  function buildTiers(side){
    const ga = garch(); const p9 = ga.p9||{}, p18=ga.p18||{}, p27=ga.p27||{};

    // N√≠vel 1 - Zona Principal: regi√£o (voc√™ j√° cria no generateTradingStrategy de 2 cards)
    // Vamos reaproveitar os valores calculados l√°:
    const last = ts.generateTradingStrategy();  // retorna { long, short, ... }
    const seed = (side==="BUY") ? last.long : last.short;

    // Se ainda n√£o houver regi√£o, n√£o montamos tiers
    if (!seed || !Number.isFinite(seed.entryRange?.min) || !Number.isFinite(seed.entryRange?.max)) return null;

    // N√≠vel 2 - Extens√£o 18P/N√≠vel 3 - Extremo 27P: ¬±2œÉ da 2a/3a proje√ß√£o
    const twoSigma18 = (side==="BUY") ? p18.down2sigma : p18.up2sigma;
    const twoSigma27 = (side==="BUY") ? p27.down2sigma : p27.up2sigma;

    const v18 = vol18(); const pts = choosePts(v18);

    // Constru√ß√£o dos degraus (com stops e alvos por tier)
    const tiers = [];

    // N√≠vel 1 - Zona Principal (regi√£o cluster)
    const ref1 = (seed.entryRange.min + seed.entryRange.max)/2;
    tiers.push({
      label: "N√≠vel 1 - Zona Principal (Regi√£o)",
      entry: ref1,
      stop:  (side==="BUY") ? (seed.entryRange.min - 10) : (seed.entryRange.max + 10),
      tgt:   (side==="BUY") ? (ref1 + pts) : (ref1 - pts),
      note:  `Regi√£o: ${F2(seed.entryRange.min)}‚Äì${F2(seed.entryRange.max)}`
    });

    // N√≠vel 2 - Extens√£o 18P (¬±2œÉ 18P)
    if (Number.isFinite(twoSigma18)){
      const e2 = twoSigma18;
      tiers.push({
        label: "N√≠vel 2 - Extens√£o M√©dia (¬±2œÉ 18P)",
        entry: e2,
        stop:  (side==="BUY") ? (e2 - 10) : (e2 + 10),
        tgt:   (side==="BUY") ? (e2 + pts) : (e2 - pts),
        note:  `18P ${side==="BUY"?"‚àí2œÉ":"+2œÉ"}`
      });
    }

    // N√≠vel 3 - Extremo 27P (¬±2œÉ 27P)
    if (Number.isFinite(twoSigma27)){
      const e3 = twoSigma27;
      tiers.push({
        label: "N√≠vel 3 - Extremidade (¬±2œÉ 27P)",
        entry: e3,
        stop:  (side==="BUY") ? (e3 - 10) : (e3 + 10),
        tgt:   (side==="BUY") ? (e3 + pts) : (e3 - pts),
        note:  `27P ${side==="BUY"?"‚àí2œÉ":"+2œÉ"}`
      });
    }

    // Ordena (BUY: de cima p/ baixo / SELL: de baixo p/ cima) s√≥ pra visual
    tiers.sort((a,b)=> (side==="BUY") ? b.entry - a.entry : a.entry - b.entry);

    return { tiers, pts };
  }

  // Renderiza uma caixinha de tiers dentro do card j√° existente
  function injectTiers(side, container){
    const pack = buildTiers(side);
    if (!pack) return;
    const { tiers, pts } = pack;

    const list = tiers.map(t => `
      <div style="margin:6px 0; padding:8px 10px; border:1px solid #e5e7eb; border-radius:10px; background:#fff;">
        <div style="font-weight:900; font-size:12px;">${t.label}</div>
        <div style="font-size:12px; margin-top:4px;">
          üéØ Entrada: <b>${F2(t.entry)}</b> &nbsp;|&nbsp;
          üõë Stop: <b>${F2(t.stop)}</b> &nbsp;|&nbsp;
          ‚úÖ Alvo curto: <b>${F2(t.tgt)}</b> <span style="opacity:.7">(+/‚àí ${pts} pts)</span><br>
          <span style="opacity:.7">${t.note}</span>
        </div>
      </div>
    `).join("");

    const box = document.createElement("div");
    box.innerHTML = `
      <div style="margin-top:8px; border:1px dashed #cbd5e1; border-radius:12px; padding:8px 10px; background:#f8fafc;">
        <div style="font-weight:800; font-size:12px; color:#334155; margin-bottom:4px;">
          Plano em 3 Tiers (${side==="BUY"?"compra":"venda"})
        </div>
        ${list}
        <div style="font-size:11px; color:#64748b; margin-top:6px;">
          Alvo final: manter parcial at√© o <b>Just√≠ssimo</b> se a dire√ß√£o favorecer.
        </div>
      </div>
    `;
    container.appendChild(box);
  }

  // Pluga no painel assim que ele renderizar
  const hook = setInterval(() => {
    const op = document.getElementById("aiOperation");
    if (!op) return;
    clearInterval(hook);

    // localiza os dois cards (Compra e Venda) dentro do aiOperation
    const cards = op.querySelectorAll(".card.card-success, .card.card-danger");
    if (!cards.length){
      // fallback: injeta abaixo de todo o bloco
      injectTiers("BUY", op);
      injectTiers("SELL", op);
      return;
    }

    // 1¬∫ card: compra | 2¬∫ card: venda (como no seu layout atual)
    const buyCard  = cards[0];
    const sellCard = cards[1] || cards[0].nextElementSibling || op;

    injectTiers("BUY",  buyCard);
    injectTiers("SELL", sellCard);
  }, 150);
})();
</script>


<script>
/* ====== Seletor de Tiers nos cards (BUY/SELL) ====== */
(() => {
  const ts = window.tradingSystem;
  if (!ts) return;

  // helpers
  const F2 = v => Number.isFinite(v) ? Number(v).toFixed(2) : "--";
  function vol18(){ const v = ts.analyzeSystemVolatility(); return v?.p18?.volatilityPercent || 2.0; }
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }

  function buildTiers(side){
    const ga = ts.analyzeSystemGARCH() || {};
    const p18= ga.p18 || {}, p27 = ga.p27 || {};
    const last = ts.generateTradingStrategy?.() || {};
    const seed = side==="BUY" ? last.long : last.short;

    if (!seed || !Number.isFinite(seed?.entryRange?.min) || !Number.isFinite(seed?.entryRange?.max)) return null;

    const v18 = vol18(); const pts = choosePts(v18);
    const ref1 = (seed.entryRange.min + seed.entryRange.max)/2;

    const t1 = {
      key:"t1",
      label:"N√≠vel 1 - Zona Principal (Regi√£o)",
      entry:ref1,
      stop: (side==="BUY") ? (seed.entryRange.min - 10) : (seed.entryRange.max + 10),
      tgt:  (side==="BUY") ? (ref1 + pts) : (ref1 - pts),
      note:`Regi√£o: ${F2(seed.entryRange.min)}‚Äì${F2(seed.entryRange.max)}`
    };

    const sigma18 = (side==="BUY") ? p18.down2sigma : p18.up2sigma;
    const sigma27 = (side==="BUY") ? p27.down2sigma : p27.up2sigma;

    const tiers = [t1];
    if (Number.isFinite(sigma18)){
      tiers.push({
        key:"t2",
        label:"N√≠vel 2 - Extens√£o M√©dia (¬±2œÉ 18P)",
        entry:sigma18,
        stop:(side==="BUY") ? (sigma18 - 10) : (sigma18 + 10),
        tgt: (side==="BUY") ? (sigma18 + pts) : (sigma18 - pts),
        note:`18P ${side==="BUY"?"‚àí2œÉ":"+2œÉ"}`
      });
    }
    if (Number.isFinite(sigma27)){
      tiers.push({
        key:"t3",
        label:"N√≠vel 3 - Extremidade (¬±2œÉ 27P)",
        entry:sigma27,
        stop:(side==="BUY") ? (sigma27 - 10) : (sigma27 + 10),
        tgt: (side==="BUY") ? (sigma27 + pts) : (sigma27 - pts),
        note:`27P ${side==="BUY"?"‚àí2œÉ":"+2œÉ"}`
      });
    }

    // ordena visualmente (BUY: alto‚Üíbaixo; SELL: baixo‚Üíalto)
    tiers.sort((a,b)=> side==="BUY" ? b.entry - a.entry : a.entry - b.entry);
    return { tiers, pts };
  }

  // monta UI de tabs + conte√∫do
  function mountTierUI(side, host){
    const pack = buildTiers(side);
    if (!pack || !pack.tiers.length) return;
    const { tiers, pts } = pack;

    const wrap = document.createElement("div");
    // tabs
    const tabs = document.createElement("div");
    tabs.className = "tier-tabs";
    // content
    const box  = document.createElement("div");
    box.className = "tier-box";

    function renderTier(t){
      box.innerHTML = `
        <div class="tier-line">üéØ <b>${t.label}</b></div>
        <div class="tier-line">Entrada: <b class="tier-mono">${F2(t.entry)}</b>
          &nbsp;|&nbsp; üõë Stop: <b class="tier-mono">${F2(t.stop)}</b>
          &nbsp;|&nbsp; ‚úÖ Alvo curto: <b class="tier-mono">${F2(t.tgt)}</b>
          &nbsp;<span class="tier-note">(¬± ${pts} pts)</span>
        </div>
        <div class="tier-note">${t.note}</div>
        <div class="tier-note">Alvo final: manter parcial at√© o <b>Just√≠ssimo</b> se a dire√ß√£o favorecer.</div>
      `;
    }

    // cria bot√µes de tab
    tiers.forEach((t,idx) => {
      const b = document.createElement("button");
      b.type="button";
      b.className = "tier-tab" + (idx===0 ? " active" : "");
      b.textContent = t.label.replace("Tier-","T");
      b.onclick = () => {
        // ativa tab
        tabs.querySelectorAll(".tier-tab").forEach(x=>x.classList.remove("active"));
        b.classList.add("active");
        // troca conte√∫do
        renderTier(t);
      };
      tabs.appendChild(b);
    });

    // render inicial = primeiro tier
    renderTier(tiers[0]);

    // injeta no card
    wrap.appendChild(tabs);
    wrap.appendChild(box);
    host.appendChild(wrap);
  }

  // posiciona dentro dos cards quando o painel de estrat√©gia estiver pronto
  function attach(){
    const op = document.getElementById("aiOperation");
    if (!op){ setTimeout(attach, 150); return; }

    // evita duplicar
    if (op.dataset.tiersMounted === "1") return;
    op.dataset.tiersMounted = "1";

    // tenta pegar os dois cards (verde e vermelho) como j√° est√£o
    const cards = op.querySelectorAll(".card.card-success, .card.card-danger, .insight-card");
    // fallback seguro: monta em sequ√™ncia
    let buyHost  = cards[0] || op;
    let sellHost = cards[1] || cards[0] || op;

    mountTierUI("BUY",  buyHost);
    mountTierUI("SELL", sellHost);
  }

  // roda ao abrir e ap√≥s re-renderiza√ß√µes comuns do painel
  attach();
  const obs = new MutationObserver(()=>attach());
  obs.observe(document.getElementById("aiStrategyPanel") || document.body, {childList:true, subtree:true});
})();
</script>

<script>
/* ====== Seletor de Tiers nos cards (BUY/SELL) ‚Äì robusto ====== */
(() => {
  const ts = window.tradingSystem;
  if (!ts) return;

  // helpers
  const F2 = v => Number.isFinite(v) ? Number(v).toFixed(2) : "--";
  function vol18(){ const v = ts.analyzeSystemVolatility?.(); return v?.p18?.volatilityPercent || 2.0; }
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }

  function buildTiers(side){
    const ga = ts.analyzeSystemGARCH?.() || {};
    const p18 = ga.p18 || {}, p27 = ga.p27 || {};
    const strat = ts.generateTradingStrategy?.() || {};
    const seed  = side==="BUY" ? strat.long : strat.short;

    if (!seed || !Number.isFinite(seed?.entryRange?.min) || !Number.isFinite(seed?.entryRange?.max)) return null;

    const pts  = choosePts(vol18());
    const ref1 = (seed.entryRange.min + seed.entryRange.max)/2;

    const tiers = [{
      key:"t1",
      label:"N√≠vel 1 - Zona Principal (Regi√£o)",
      entry: ref1,
      stop:  (side==="BUY") ? (seed.entryRange.min - 10) : (seed.entryRange.max + 10),
      tgt:   (side==="BUY") ? (ref1 + pts) : (ref1 - pts),
      note:  `Regi√£o: ${F2(seed.entryRange.min)}‚Äì${F2(seed.entryRange.max)}`
    }];

    const sigma18 = (side==="BUY") ? p18.down2sigma : p18.up2sigma;
    const sigma27 = (side==="BUY") ? p27.down2sigma : p27.up2sigma;

    if (Number.isFinite(sigma18)){
      tiers.push({
        key:"t2",
        label:"N√≠vel 2 - Extens√£o M√©dia (¬±2œÉ 18P)",
        entry:sigma18,
        stop:(side==="BUY") ? (sigma18 - 10) : (sigma18 + 10),
        tgt:(side==="BUY") ? (sigma18 + pts) : (sigma18 - pts),
        note:`18P ${side==="BUY"?"‚àí2œÉ":"+2œÉ"}`
      });
    }
    if (Number.isFinite(sigma27)){
      tiers.push({
        key:"t3",
        label:"N√≠vel 3 - Extremidade (¬±2œÉ 27P)",
        entry:sigma27,
        stop:(side==="BUY") ? (sigma27 - 10) : (sigma27 + 10),
        tgt:(side==="BUY") ? (sigma27 + pts) : (sigma27 - pts),
        note:`27P ${side==="BUY"?"‚àí2œÉ":"+2œÉ"}`
      });
    }

    // ordena√ß√£o visual (BUY: alto‚Üíbaixo; SELL: baixo‚Üíalto)
    tiers.sort((a,b)=> side==="BUY" ? b.entry - a.entry : a.entry - b.entry);
    return { tiers, pts };
  }

  // monta UI de tabs + conte√∫do (BUY/SELL)
  function mountTierUI(side, host){
    // evita duplicar
    const markerId = side==="BUY" ? "tiersBuy" : "tiersSell";
    if (host.querySelector(`#${markerId}`)) return;

    const pack = buildTiers(side);
    if (!pack || !pack.tiers.length) return;
    const { tiers, pts } = pack;

    const wrap = document.createElement("div");
    wrap.className = "tier-wrap";
    wrap.id = markerId;

    const tabs = document.createElement("div");
    tabs.className = "tier-tabs " + (side==="BUY" ? "buy" : "sell");

    const box  = document.createElement("div");
    box.className  = "tier-box";

    function renderTier(t){
      box.innerHTML = `
        <div class="tier-line"><b>${t.label}</b></div>
        <div class="tier-line">
          üéØ Entrada: <b class="tier-mono">${F2(t.entry)}</b>
          &nbsp;|&nbsp; üõë Stop: <b class="tier-mono">${F2(t.stop)}</b>
          &nbsp;|&nbsp; ‚úÖ Alvo curto: <b class="tier-mono">${F2(t.tgt)}</b>
          &nbsp;<span class="tier-note">(¬± ${pts} pts)</span>
        </div>
        <div class="tier-note">${t.note}</div>
        <div class="tier-note">Alvo final: manter parcial at√© o <b>Just√≠ssimo</b> se a dire√ß√£o favorecer.</div>
      `;
    }

    tiers.forEach((t, i) => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "tier-tab" + (i===0 ? " active" : "");
      b.textContent = t.label.replace("Tier-","T");
      b.addEventListener("click", () => {
        tabs.querySelectorAll(".tier-tab").forEach(x=>x.classList.remove("active"));
        b.classList.add("active");
        renderTier(t);
      });
      tabs.appendChild(b);
    });

    renderTier(tiers[0]);
    wrap.appendChild(tabs);
    wrap.appendChild(box);
    host.appendChild(wrap);
  }

  function attach(){
    const op = document.getElementById("aiOperation");
    if (!op){ setTimeout(attach, 200); return; }

    // Tenta achar 2 cards (compra / venda). No seu layout s√£o .insight-card.
    const cards = op.querySelectorAll(".insight-card, .card");
    if (!cards.length){
      // sem cards: injeta tudo no pr√≥prio container
      mountTierUI("BUY",  op);
      mountTierUI("SELL", op);
      return;
    }

    // 1¬∫ card = compra, 2¬∫ = venda (como nas suas capturas)
    const buyHost  = cards[0] || op;
    const sellHost = cards[1] || op;

    mountTierUI("BUY",  buyHost);
    mountTierUI("SELL", sellHost);
  }

  // roda ao carregar e quando o painel re-renderizar
  attach();
  const obs = new MutationObserver(()=>attach());
  obs.observe(document.getElementById("aiStrategyPanel") || document.body, {childList:true, subtree:true});
})();
</script>


<script>
/* ===== Tabs T1/T2/T3 ‚Äì patch m√≠nimo, sem observer ===== */
(function(){
  function F2(v){ return (Number.isFinite(v) ? Number(v).toFixed(2) : "--"); }
  function ptsByVol(v){ return v>=3.0 ? 15 : (v<=1.5 ? 10 : 12); }

  function buildTiers(side, ts){
    const ga = ts.analyzeSystemGARCH?.() || {};
    const p18= ga.p18 || {}, p27= ga.p27 || {};
    const strat = ts.generateTradingStrategy?.() || {};
    const seed  = side==='BUY' ? strat.long : strat.short;

    const tiers = [];
    const v18 = ts.analyzeSystemVolatility?.().p18?.volatilityPercent || 2.0;
    const pts = ptsByVol(v18);

    if (seed && Number.isFinite(seed?.entryRange?.min) && Number.isFinite(seed?.entryRange?.max)){
      const ref1 = (seed.entryRange.min + seed.entryRange.max)/2;
      tiers.push({ key:'t1', label:'N√≠vel 1 - Zona Principal (Regi√£o)',
        entry:ref1, stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
        tgt:(side==='BUY')?(ref1+pts):(ref1-pts),
        note:`Regi√£o: ${F2(seed.entryRange.min)}‚Äì${F2(seed.entryRange.max)}` });
    }
    const s18 = (side==='BUY') ? p18.down2sigma : p18.up2sigma;
    const s27 = (side==='BUY') ? p27.down2sigma : p27.up2sigma;
    if (Number.isFinite(s18)) tiers.push({ key:'t2', label:'N√≠vel 2 - Extens√£o 18P (¬±2œÉ 18P)', entry:s18,
      stop:(side==='BUY')?s18-10:s18+10, tgt:(side==='BUY')?s18+pts:s18-pts, note:`18P ${side==='BUY'?'‚àí2œÉ':'+2œÉ'}` });
    if (Number.isFinite(s27)) tiers.push({ key:'t3', label:'N√≠vel 3 - Extremo 27P (¬±2œÉ 27P)', entry:s27,
      stop:(side==='BUY')?s27-10:s27+10, tgt:(side==='BUY')?s27+pts:s27-pts, note:`27P ${side==='BUY'?'‚àí2œÉ':'+2œÉ'}` });

    if (!tiers.length) return null;
    tiers.sort((a,b)=> side==='BUY' ? b.entry-a.entry : a.entry-b.entry);
    return { tiers, pts };
  }

  function mountTierTabs(side, host, ts){
    if (!host) return;
    const id = side==='BUY' ? 'tiersBuy' : 'tiersSell';
    if (host.querySelector('#'+id)) return; // j√° existe

    const pack = buildTiers(side, ts);
    if (!pack) return;
    const { tiers, pts } = pack;

    const wrap = document.createElement('div'); wrap.className='tier-wrap'; wrap.id=id;
    const tabs = document.createElement('div'); tabs.className='tier-tabs ' + (side==='BUY'?'buy':'sell');
    const box  = document.createElement('div'); box.className='tier-box';

    function render(t){
      box.innerHTML = `
        <div class="tier-line"><b>${t.label}</b></div>
        <div class="tier-line">
          üéØ Entrada: <b class="tier-mono">${F2(t.entry)}</b>
          &nbsp;|&nbsp; üõë Stop: <b class="tier-mono">${F2(t.stop)}</b>
          &nbsp;|&nbsp; ‚úÖ Alvo curto: <b class="tier-mono">${F2(t.tgt)}</b>
          &nbsp;<span class="tier-note">(¬± ${pts} pts)</span>
        </div>
        <div class="tier-note">${t.note}</div>
        <div class="tier-note">Alvo final: manter parcial at√© o <b>Just√≠ssimo</b> se a dire√ß√£o favorecer.</div>`;
    }

    tiers.forEach((t,i)=>{
      const b = document.createElement('button');
      b.type='button';
      b.className='tier-tab' + (i===0 ? ' active' : '');
      b.textContent = t.label.replace('Tier-','T');
      b.addEventListener('click', ()=>{
        tabs.querySelectorAll('.tier-tab').forEach(x=>x.classList.remove('active'));
        b.classList.add('active'); render(t);
      });
      tabs.appendChild(b);
    });
    render(tiers[0]);
    wrap.appendChild(tabs);
    wrap.appendChild(box);
    host.appendChild(wrap);
  }

  // --- ENVOLVE a SUA fun√ß√£o renderStrategyPanel (sem mudar sua l√≥gica) ---
  function install(){
    const ts = window.tradingSystem;
    if (!ts || typeof ts.renderStrategyPanel !== 'function') { setTimeout(install, 150); return; }

    const original = ts.renderStrategyPanel.bind(ts);
    ts.renderStrategyPanel = function(){
      const r = original();  // chama sua renderiza√ß√£o original
      try{
        const op = document.getElementById('aiOperation');
        if (!op) return r;

        // tenta achar exatamente os dois cards gerados por voc√™
        const cards = op.querySelectorAll('.card-grid > .card');
        const buyHost  = cards[0] || op;
        const sellHost = cards[1] || op;

        mountTierTabs('BUY',  buyHost,  ts);
        mountTierTabs('SELL', sellHost, ts);
      }catch(e){ /* silencia para n√£o travar */ }
      return r;
    };
  }
  install();
})();
</script>
<style id="tier-card-colors">
/* fundo suave dos cards de compra/venda */
#aiOperation .card.card-success{
  background: linear-gradient(180deg,#ecfdf5,#ffffff);
  border-color:#86efac;
}
#aiOperation .card.card-danger{
  background: linear-gradient(180deg,#fef2f2,#ffffff);
  border-color:#fca5a5;
}

/* Tabs T1/T2/T3 ‚Äî mant√©m as cores nas abas ativas */
#aiStrategyPanel .tier-wrap{margin-top:8px}
#aiStrategyPanel .tier-tabs{display:flex;gap:6px;margin:8px 0}
#aiStrategyPanel .tier-tab{
  cursor:pointer; user-select:none; padding:6px 10px;
  border:1px solid #e5e7eb; background:#fff; border-radius:999px;
  font-size:12px; font-weight:800; color:#334155
}
#aiStrategyPanel .tier-tab.active{color:#fff; border-color:transparent}
#aiStrategyPanel .tier-tabs.buy  .tier-tab.active{background:#10b981}  /* verde */
#aiStrategyPanel .tier-tabs.sell .tier-tab.active{background:#ef4444}  /* vermelho */
#aiStrategyPanel .tier-box{border:1px dashed #cbd5e1;border-radius:12px;padding:8px 10px;background:#f8fafc}
#aiStrategyPanel .tier-line{font-size:12px;margin:4px 0;color:#0f172a}
#aiStrategyPanel .tier-note{font-size:11px;color:#64748b}
#aiStrategyPanel .tier-mono{font-variant-numeric:tabular-nums}

/* headline din√¢mica: ocupa o lugar do ‚Äúpreparar compra/venda‚Äù */
#aiStrategyPanel .tier-headline{
  margin:6px 0 8px; padding:8px 10px; border:1px solid #e5e7eb;
  border-radius:10px; background:#f9fafb; font-size:12px;
}
#aiStrategyPanel .tier-headline .k{color:#64748b}
#aiStrategyPanel .tier-headline .v{font-weight:900}
</style>

<script id="tier-headline-sync">
(function(){
  // Utilit√°rios (leem os c√°lculos do seu pr√≥prio sistema)
  const ts = window.tradingSystem;
  if (!ts) return;

  const F2 = v => (Number.isFinite(v)? Number(v).toFixed(2) : "--");
  const vol18 = () => (ts.analyzeSystemVolatility?.().p18?.volatilityPercent || 2.0);
  const ptsByVol = v => (v>=3 ? 15 : (v<=1.5 ? 10 : 12));

  function computeTiers(side){
    const ga = ts.analyzeSystemGARCH?.() || {}; const p18=ga.p18||{}, p27=ga.p27||{};
    const s  = ts.generateTradingStrategy?.() || {}; const seed = side==='BUY'? s.long : s.short;
    const pts = ptsByVol(vol18());
    const tiers = [];
    if (seed && Number.isFinite(seed?.entryRange?.min) && Number.isFinite(seed?.entryRange?.max)){
      const ref1=(seed.entryRange.min+seed.entryRange.max)/2;
      tiers.push({key:'t1', label:'N√≠vel 1 - Zona Principal (Regi√£o)', entry:ref1,
                  stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
                  tgt:(side==='BUY')?(ref1+pts):(ref1-pts)});
    }
    const s18=(side==='BUY')?p18.down2sigma:p18.up2sigma;
    const s27=(side==='BUY')?p27.down2sigma:p27.up2sigma;
    if (Number.isFinite(s18)) tiers.push({key:'t2', label:'N√≠vel 2 - Extens√£o M√©dia (¬±2œÉ 18P)', entry:s18, stop:(side==='BUY')?s18-10:s18+10, tgt:(side==='BUY')?s18+pts:s18-pts});
    if (Number.isFinite(s27)) tiers.push({key:'t3', label:'N√≠vel 3 - Extremidade (¬±2œÉ 27P)', entry:s27, stop:(side==='BUY')?s27-10:s27+10, tgt:(side==='BUY')?s27+pts:s27-pts});
    if (!tiers.length) return null;
    tiers.sort((a,b)=> side==='BUY' ? b.entry-a.entry : a.entry-b.entry);
    return {tiers, pts};
  }

  // Gera (se faltar) um bloco de headline logo abaixo do <h4> do card
  function ensureHeadlineHost(card, side){
    let head = card.querySelector('.tier-headline');
    if (!head){
      head = document.createElement('div');
      head.className = 'tier-headline';
      // insere depois do h4
      const h = card.querySelector('h4') || card.firstChild;
      h && h.parentNode.insertBefore(head, h.nextSibling);
    }
    // pinta o fundo do headline conforme o lado
    head.style.background = (side==='BUY') ? '#ecfdf5' : '#fef2f2';
    head.style.borderColor = (side==='BUY') ? '#86efac' : '#fca5a5';
    return head;
  }

  // Atualiza a linha ‚Äúsinal‚Äù (texto acima) e mant√©m o resumo do tier
  function renderTierIntoCard(card, side, tier){
    // Headline din√¢mico (sinal vis√≠vel)
    const head = ensureHeadlineHost(card, side);
    head.innerHTML = `
      <span class="k">An√°lise (</span><b>${tier.label}</b><span class="k">):</span>
      <span class="k"> Gatilho</span> <span class="v">${F2(tier.entry)}</span> ¬∑
      <span class="k">Stop</span> <span class="v">${F2(tier.stop)}</span> ¬∑
      <span class="k">Alvo</span> <span class="v">${F2(tier.tgt)}</span>
    `;

    // Bloco explicativo (se existe tier-box sob as abas, atualizamos tamb√©m)
    const box = card.querySelector('.tier-box');
    if (box){
      const pts = ptsByVol(vol18());
      box.innerHTML = `
        <div class="tier-line"><b>${tier.label}</b></div>
        <div class="tier-line">
          üéØ Entrada: <b class="tier-mono">${F2(tier.entry)}</b> ¬∑
          üõë Stop: <b class="tier-mono">${F2(tier.stop)}</b> ¬∑
          ‚úÖ Alvo curto: <b class="tier-mono">${F2(tier.tgt)}</b>
          <span class="tier-note">(¬± ${pts} pts)</span>
        </div>
        <div class="tier-note">Alvo final: manter parcial at√© o <b>Just√≠ssimo</b> se a dire√ß√£o favorecer.</div>
      `;
    }
  }

  // Liga as abas existentes (T1/T2/T3) para mudar a headline e a box
  function wireTabs(card, side){
    const tabs = card.querySelectorAll('.tier-tabs .tier-tab');
    if (!tabs.length) return;

    // Pr√©-calcula tiers
    const pack = computeTiers(side); if (!pack) return;
    const {tiers} = pack;
    // Map simples por texto (T1/T2/T3)
    const map = { 'T1': tiers.find(t=>t.key==='t1'),
                  'T2': tiers.find(t=>t.key==='t2'),
                  'T3': tiers.find(t=>t.key==='t3') };

    // Render inicial conforme aba ativa
    const active = Array.from(tabs).find(b=>b.classList.contains('active')) || tabs[0];
    const key = active.textContent.trim(); if (map[key]) renderTierIntoCard(card, side, map[key]);

    tabs.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        tabs.forEach(x=>x.classList.remove('active'));
        btn.classList.add('active');
        const k = btn.textContent.trim();
        const t = map[k];
        if (t) renderTierIntoCard(card, side, t);
      }, {once:false});
    });
  }

  // Envolve sua renderiza√ß√£o para religar as abas sempre que o painel for redesenhado
  function install(){
    const ts = window.tradingSystem;
    if (!ts || typeof ts.renderStrategyPanel !== 'function'){ setTimeout(install,150); return; }
    const orig = ts.renderStrategyPanel.bind(ts);
    ts.renderStrategyPanel = function(){
      const r = orig();
      try{
        const op = document.getElementById('aiOperation');
        if (!op) return r;
        const cards = op.querySelectorAll('.card-grid > .card');
        const buy  = cards[0] || null;
        const sell = cards[1] || null;

        // se os blocos de tabs j√° existem (montados por patch anterior), apenas ‚Äúliga‚Äù as mudan√ßas
        if (buy)  wireTabs(buy,  'BUY');
        if (sell) wireTabs(sell, 'SELL');
      }catch(_){}
      return r;
    };
  }
  install();
})();
</script>
<!-- === TIER PRO: an√°lise completa dentro das tabs (substitui bloco antigo) === -->
<style id="tier-pro-css">
/* Fundo suave dos cards (mant√©m) */
#aiOperation .card.card-success{background:linear-gradient(180deg,#ecfdf5,#ffffff);border-color:#86efac;}
#aiOperation .card.card-danger{background:linear-gradient(180deg,#fef2f2,#ffffff);border-color:#fca5a5;}

/* Tabs */
#aiStrategyPanel .tier-wrap{margin-top:8px}
#aiStrategyPanel .tier-tabs{display:flex;gap:8px;margin:10px 0}
#aiStrategyPanel .tier-tab{cursor:pointer;user-select:none;padding:8px 12px;border:1px solid #e5e7eb;background:#fff;border-radius:999px;font-size:12px;font-weight:900;color:#334155}
#aiStrategyPanel .tier-tab.active{color:#fff;border-color:transparent}
#aiStrategyPanel .tier-tabs.buy  .tier-tab.active{background:#10b981}
#aiStrategyPanel .tier-tabs.sell .tier-tab.active{background:#ef4444}

/* Painel PRO dentro do Tier (grande) */
.tier-pro{
  border:1px solid #e5e7eb;border-radius:12px;background:#fff;
  padding:12px 14px;margin-top:6px;
}
.tier-pro h5{
  margin:0 0 8px 0;font-size:14px;font-weight:900;color:#0f172a;
  display:flex;align-items:center;gap:8px;
}
.tier-grid{
  display:grid;grid-template-columns:1fr;gap:6px;
}
.tline{font-size:13px;color:#0f172a}
.tkey{color:#64748b;font-weight:800}
.tval{font-weight:900;font-variant-numeric:tabular-nums}

/* Notas menores */
.tnote{font-size:12px;color:#475569;margin-top:6px}
</style>

<script id="tier-pro-js">
(function(){
  const ts = window.tradingSystem; if(!ts) return;

  const F2 = v => (Number.isFinite(v)? Number(v).toFixed(2) : "--");
  const vol18 = () => (ts.analyzeSystemVolatility?.().p18?.volatilityPercent || 2.0);
  const ptsByVol = v => (v>=3 ? 15 : (v<=1.5 ? 10 : 12));

  function computeTiers(side){
    const ga = ts.analyzeSystemGARCH?.()||{};
    const p18=ga.p18||{}, p27=ga.p27||{};
    const s  = ts.generateTradingStrategy?.()||{};
    const seed = side==='BUY' ? s.long : s.short;
    const pts = ptsByVol(vol18());
    const tiers = [];

    // T1 (Regi√£o)
    if (seed && Number.isFinite(seed?.entryRange?.min) && Number.isFinite(seed?.entryRange?.max)){
      const ref=(seed.entryRange.min+seed.entryRange.max)/2;
      tiers.push({
        key:'T1', label:'N√≠vel 1 - Zona Principal (Regi√£o)',
        entry:ref,
        stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
        tgt:(side==='BUY')?(ref+pts):(ref-pts),
        note:`Regi√£o ${F2(seed.entryRange.min)}‚Äì${F2(seed.entryRange.max)}`
      });
    }
    // T2 (¬±2œÉ 18P)
    const s18=(side==='BUY')?p18.down2sigma:p18.up2sigma;
    if (Number.isFinite(s18)){
      tiers.push({
        key:'T2', label:'N√≠vel 2 - Extens√£o M√©dia (¬±2œÉ 18P)',
        entry:s18,
        stop:(side==='BUY')?s18-10:s18+10,
        tgt:(side==='BUY')?s18+pts:s18-pts,
        note:`18P ${side==='BUY'?'‚àí2œÉ':'+2œÉ'}`
      });
    }
    // T3 (¬±2œÉ 27P)
    const s27=(side==='BUY')?p27.down2sigma:p27.up2sigma;
    if (Number.isFinite(s27)){
      tiers.push({
        key:'T3', label:'N√≠vel 3 - Extremidade (¬±2œÉ 27P)',
        entry:s27,
        stop:(side==='BUY')?s27-10:s27+10,
        tgt:(side==='BUY')?s27+pts:s27-pts,
        note:`27P ${side==='BUY'?'‚àí2œÉ':'+2œÉ'}`
      });
    }
    if (!tiers.length) return null;

    // ordena para visual (BUY: alto‚Üíbaixo; SELL: baixo‚Üíalto)
    tiers.sort((a,b)=> side==='BUY' ? b.entry-a.entry : a.entry-b.entry);
    return {tiers, pts, p18};
  }

  // Apaga o bloco antigo ‚Äúcircundado‚Äù: tudo entre <h4> e a √°rea de tiers
  function wipeLegacyBlock(card){
    // Se ainda n√£o foi limpo, mova tudo para um holder e esconda
    if (!card.querySelector('.legacy-block')){
      const legacy = document.createElement('div');
      legacy.className='legacy-block'; legacy.style.display='none';
      const h = card.querySelector('h4');
      // move nodos entre o h4 e a tier-wrap (se existir)
      const until = card.querySelector('.tier-wrap');
      const toMove = [];
      let n = h ? h.nextSibling : card.firstChild;
      while(n && n!==until){ const next=n.nextSibling; toMove.push(n); n=next; }
      toMove.forEach(node=> legacy.appendChild(node));
      card.insertBefore(legacy, until || null);
    }
  }

  // Constr√≥i o painel PRO (dentro do Tier selecionado)
  function renderTierPro(card, side, tier, refs){
    wipeLegacyBlock(card);

    // cria/garante a caixa onde vai a an√°lise PRO
    let pro = card.querySelector('.tier-pro');
    if (!pro){
      pro = document.createElement('div'); pro.className='tier-pro';
      // injeta logo ap√≥s a barra de tabs (ou no final do card)
      const afterTabs = card.querySelector('.tier-wrap') || card;
      afterTabs.appendChild(pro);
    }

    // calcula R/R do tier
    const rr = (Math.abs(tier.tgt - tier.entry) / Math.abs(tier.entry - tier.stop)) || 0;

    // referencias de bandas (usamos p18 para +1œÉ / ‚àí1œÉ)
    const up1 = refs?.p18?.up1sigma, dn1 = refs?.p18?.down1sigma;

    pro.innerHTML = `
      <h5>${side==='BUY'?'üü¢ Compra':'üî¥ Venda'} ‚Äî <span>${tier.label}</span></h5>
      <div class="tier-grid">
        <div class="tline"><span class="tkey">Gatilho:</span> <span class="tval">${F2(tier.entry)}</span></div>
        <div class="tline"><span class="tkey">Stop:</span>    <span class="tval">${F2(tier.stop)}</span></div>
        <div class="tline"><span class="tkey">Alvo curto:</span> <span class="tval">${F2(tier.tgt)}</span>  ¬∑  <span class="tkey">R/R:</span> <span class="tval">1:${rr.toFixed(2)}</span></div>
        ${Number.isFinite(up1)&&Number.isFinite(dn1) ? `<div class="tline"><span class="tkey">Bandas 18P:</span> +1œÉ ${F2(up1)}  ¬∑  ‚àí1œÉ ${F2(dn1)}</div>` : ``}
        <div class="tnote">${tier.note || ''}</div>
        <div class="tnote">Alvo final: manter parcial at√© o <b>Just√≠ssimo</b> se a dire√ß√£o favorecer.</div>
      </div>
    `;
  }

  // Liga as abas j√° existentes; quando trocar, reescreve a an√°lise PRO e mant√©m topo limpo
  function wireCard(card){
    // identifique lado pelo CSS/t√≠tulo
    const isBuy  = card.classList.contains('card-success') || /compra/i.test(card.textContent);
    const side   = isBuy ? 'BUY' : 'SELL';

    const pack = computeTiers(side); if (!pack) return;
    const {tiers, p18} = pack;
    const tabs = card.querySelectorAll('.tier-tabs .tier-tab');

    // mapeia T1/T2/T3
    const map = { T1: tiers.find(t=>t.key==='T1'),
                  T2: tiers.find(t=>t.key==='T2'),
                  T3: tiers.find(t=>t.key==='T3') };

    // render inicial conforme aba ativa; se n√£o houver, T1
    const active = Array.from(tabs).find(b=>b.classList.contains('active')) || tabs[0];
    const key0   = (active?.textContent||'T1').trim();
    const first  = map[key0] || map.T1 || tiers[0];
    if (first) renderTierPro(card, side, first, {p18});

    // liga cliques
    tabs.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        tabs.forEach(x=>x.classList.remove('active'));
        btn.classList.add('active');
        const k = (btn.textContent||'').trim();
        const t = map[k] || map.T1 || tiers[0];
        if (t) renderTierPro(card, side, t, {p18});
      }, {once:false});
    });
  }

  // Hook na sua renderiza√ß√£o para rodar SEM alterar sua l√≥gica
  function install(){
    if (!ts || typeof ts.renderStrategyPanel !== 'function'){ setTimeout(install,150); return; }
    const orig = ts.renderStrategyPanel.bind(ts);
    ts.renderStrategyPanel = function(){
      const r = orig();
      try{
        const op = document.getElementById('aiOperation'); if (!op) return r;
        const cards = op.querySelectorAll('.card-grid > .card'); // [0]=compra, [1]=venda
        if (cards[0]) wireCard(cards[0]);
        if (cards[1]) wireCard(cards[1]);
      }catch(_){}
      return r;
    };
  }
  install();
})();
</script>
<!-- === /FINAL PATCH === -->









<!-- ===== FINAL TIER SYNC ‚Äî SINGLE CONTROL (no duplicates) ===== -->
<style id="final-tier-sync-one-css">
  #aiOperation .card { position: relative; }
  .tier-tabs { display:flex; gap:8px; margin:10px 0; }
  .tier-tab { cursor:pointer; user-select:none; padding:8px 12px; border:1px solid #e5e7eb; background:#fff; border-radius:999px; font-size:12px; font-weight:900; color:#334155 }
  .tier-tab.active { color:#fff; border-color:transparent }
  .tier-tabs.buy  .tier-tab.active{ background:#10b981 }
  .tier-tabs.sell .tier-tab.active{ background:#ef4444 }
  .tier-box{ border:1px dashed #cbd5e1; border-radius:12px; padding:8px 10px; background:#f8fafc }
  .headline{ margin:6px 0 8px; padding:8px 10px; border:1px solid #e5e7eb; border-radius:10px; background:#f9fafb; font-size:12px; }
  .headline .k{ color:#64748b } .headline .v{ font-weight:900 }
  .mono{ font-variant-numeric: tabular-nums; }

  /* Hide any legacy tier blocks injected by older patches */
  /* (auto-removed by tier-fix) legacy hide rules deleted */
</style>
<script id="final-tier-sync-one-js">
(function(){
  function ready(fn){ if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn); else fn(); }
  ready(function waitTS(){
    var tries=0, h=setInterval(function(){
      var ts = window.tradingSystem;
      if(ts && typeof ts.analyzeSystemGARCH==='function' && typeof ts.generateTradingStrategy==='function'){
        clearInterval(h); install(ts);
      }
      if(++tries>200) clearInterval(h);
    },100);
  });

  function F2(v){ return (Number.isFinite(v)? Number(v).toFixed(2) : '--'); }
  function rr(entry, tgt, stop){ var g=Math.abs(tgt-entry), l=Math.abs(entry-stop); return l>0? g/l : 0; }
  function vol18(ts){ var v = ts.analyzeSystemVolatility(); return v && v.p18 ? (v.p18.volatilityPercent||2.0) : 2.0; }
  function ptsByVol(v){ return v>=3.0?15:(v<=1.5?10:12); }

  function buildTiers(ts, side){
    var ga = ts.analyzeSystemGARCH() || {}, p18 = ga.p18||{}, p27 = ga.p27||{};
    var strat = ts.generateTradingStrategy() || {}; 
    var seed  = side==='BUY' ? strat.long : strat.short;
    var pts = ptsByVol(vol18(ts));
    var tiers = [];

    if(seed && Number.isFinite(seed.entryRange?.min) && Number.isFinite(seed.entryRange?.max)){
      var ref = (seed.entryRange.min + seed.entryRange.max)/2;
      tiers.push({ key:'T1', label:'N√≠vel 1 - Zona Principal (Regi√£o)', entry:ref,
        stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
        tgt:(side==='BUY')?(ref+pts):(ref-pts),
        note:'Regi√£o '+F2(seed.entryRange.min)+'‚Äì'+F2(seed.entryRange.max) });
    }
    var s18 = (side==='BUY')? p18.down2sigma : p18.up2sigma;
    var s27 = (side==='BUY')? p27.down2sigma : p27.up2sigma;
    if(Number.isFinite(s18)){
      tiers.push({ key:'T2', label:'N√≠vel 2 - Extens√£o 18P (¬±2œÉ 18P)', entry:s18,
        stop:(side==='BUY')? (s18-10) : (s18+10),
        tgt:(side==='BUY')? (s18+pts) : (s18-pts),
        note:'18P '+ (side==='BUY'?'‚àí2œÉ':'+2œÉ') });
    }
    if(Number.isFinite(s27)){
      tiers.push({ key:'T3', label:'N√≠vel 3 - Extremo 27P (¬±2œÉ 27P)', entry:s27,
        stop:(side==='BUY')? (s27-10) : (s27+10),
        tgt:(side==='BUY')? (s27+pts) : (s27-pts),
        note:'27P '+ (side==='BUY'?'‚àí2œÉ':'+2œÉ') });
    }
    if(!tiers.length) return null;
    tiers.sort(function(a,b){ return side==='BUY' ? (b.entry-a.entry) : (a.entry-b.entry); });
    return { tiers: tiers, pts: pts, p18: p18 };
  }

  function removeLegacy(op){
    var bad = op.querySelectorAll('.tier-wrap, #tiersBuy, #tiersSell, .tier-pro, .tier-headline');
    bad.forEach(function(n){ n.remove(); });
  }

  function renderCard(ts, side, host){
    var pack = buildTiers(ts, side);
    host.innerHTML = ''; // limpa qualquer conte√∫do antigo
    if(!pack){ host.innerHTML = '<p style="font-size:12px;color:#64748b">Sem dados suficientes para '+(side==='BUY'?'compra':'venda')+'.</p>'; return; }
    var tiers = pack.tiers, pts = pack.pts;

    var tabs = document.createElement('div'); tabs.className = 'tier-tabs ' + (side==='BUY'?'buy':'sell');
    var box  = document.createElement('div'); box.className  = 'tier-box';
    var head = document.createElement('div'); head.className = 'headline';

    var storeKey = side==='BUY' ? 'tierBuySelected' : 'tierSellSelected';
    var selectedKey = localStorage.getItem(storeKey) || (tiers[0].key);

    function apply(t){
      localStorage.setItem(storeKey, t.key);
      head.innerHTML = ''
        + '<span class="k">An√°lise (</span><b>'+t.label+'</b><span class="k">):</span> '
        + '<span class="k">Gatilho</span> <span class="v mono">'+F2(t.entry)+'</span> ¬∑ '
        + '<span class="k">Stop</span> <span class="v mono">'+F2(t.stop)+'</span> ¬∑ '
        + '<span class="k">Alvo</span> <span class="v mono">'+F2(t.tgt)+'</span> ¬∑ '
        + '<span class="k">R/R</span> <span class="v">1:'+rr(t.entry,t.tgt,t.stop).toFixed(2)+'</span>';

      box.innerHTML = ''
        + '<div style="font-size:12px;margin:4px 0">üéØ Entrada: <b class="mono">'+F2(t.entry)+'</b> '
        + ' | üõë Stop: <b class="mono">'+F2(t.stop)+'</b> '
        + ' | ‚úÖ Alvo curto: <b class="mono">'+F2(t.tgt)+'</b> '
        + ' <span style="opacity:.7">(¬± '+pts+' pts)</span></div>'
        + (t.note ? '<div style="font-size:11px;color:#64748b">'+t.note+'</div>' : '')
        + '<div style="font-size:11px;color:#64748b">Alvo final: manter parcial at√© o <b>Just√≠ssimo</b> se a dire√ß√£o favorecer.</div>';
    }

    tiers.forEach(function(t){
      var b = document.createElement('button');
      b.type='button'; b.className = 'tier-tab' + (t.key===selectedKey?' active':'');
      b.textContent = t.key;
      b.addEventListener('click', function(){
        tabs.querySelectorAll('.tier-tab').forEach(function(x){ x.classList.remove('active'); });
        b.classList.add('active'); apply(t);
      });
      tabs.appendChild(b);
      if (t.key===selectedKey) apply(t);
    });

    host.appendChild(head);
    host.appendChild(tabs);
    host.appendChild(box);
  }

  function install(ts){
    ts.renderStrategyPanel = function(){
      try{
        var op  = document.getElementById('aiOperation');
        var rk  = document.getElementById('aiRisk');
        var lv  = document.getElementById('aiLevels');
        if(!op) return;

        // limpa duplicatas antigas
        removeLegacy(op);

        // cards base
        op.innerHTML = ''
          + '<div class="card-grid">'
          + '  <div class="card card-success" id="cardBUY">'
          + '    <h4>üü¢ COMPRA ‚Äî 3 M√çNIMAS</h4>'
          + '  </div>'
          + '  <div class="card card-danger" id="cardSELL">'
          + '    <h4>üî¥ VENDA ‚Äî 3 M√ÅXIMAS</h4>'
          + '  </div>'
          + '</div>';

        renderCard(ts, 'BUY',  document.getElementById('cardBUY'));
        renderCard(ts, 'SELL', document.getElementById('cardSELL'));

        // Gest√£o de risco + n√≠veis (resumo)
        if(rk){
          rk.innerHTML = '<div class="card card-info" style="border-color:#fca5a5; background:linear-gradient(180deg,#fef2f2,#ffffff);">'
            + '<h4>‚ö†Ô∏è GEST√ÉO DE RISCO</h4>'
            + '<p>Stop: 10 pts al√©m da √∫ltima m√°xima/m√≠nima do lado da opera√ß√£o.</p>'
            + '<p>Alvo curto: 10‚Äì15 pts (vol 18P). Alvo final: Just√≠ssimo se favorecer.</p>'
            + '<p>Break-even a +8 pts; reduzir lote se vol 18P > 3.0%.</p>'
            + '</div>';
        }
        if(lv){
          var g = (ts.analyzeSystemGARCH()||{}).p18 || {};
          lv.innerHTML = '<div class="nd-wrap">'
            + '<h4 class="nd-title">üß∑ N√≠veis de Decis√£o</h4>'
            + '<div class="nd-row">'
            + '  <div class="nd-pill"><div class="nd-label red">RESIST√äNCIA FORTE</div><div class="nd-value">'+F2(g.up1sigma)+'</div></div>'
            + '  <div class="nd-pill"><div class="nd-label green">SUPORTE FORTE</div><div class="nd-value">'+F2(g.down1sigma)+'</div></div>'
            + '</div></div>';
        }
      }catch(e){ console.warn('renderStrategyPanel override error', e); }
    };

    // remove qualquer inje√ß√£o de tiers que aparecer depois
    var scrubber = new MutationObserver(function(muts){
      var op = document.getElementById('aiOperation'); if(!op) return;
      removeLegacy(op);
    });
    scrubber.observe(document.getElementById('aiStrategyPanel')||document.body, {childList:true, subtree:true});

    function hookAfter(name){
      if(typeof ts[name] !== 'function') return;
      var orig = ts[name].bind(ts);
      ts[name] = function(){ var r=orig.apply(ts, arguments); try{ ts.renderStrategyPanel(); }catch(_){ } return r; };
    }
    hookAfter('performAIAnalysis');
    hookAfter('updateAIDisplay');

    setTimeout(function(){ try{ ts.renderStrategyPanel(); }catch(_){ } }, 300);
  }
})();
</script>
<!-- ===== /FINAL TIER SYNC ‚Äî SINGLE CONTROL ===== -->


<style id="tier-fix-force-display">
  /* === tier-fix: garante que os blocos de tier ficam vis√≠veis === */
  #aiOperation .tier-wrap,
  #aiOperation #tiersBuy,
  #aiOperation #tiersSell,
  #aiOperation .tier-pro,
  #aiOperation .tier-headline { display: block !important; }
</style>

<script id="tier-fix-sync-2025-09">
(function(){
  function ready(fn){ if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn); else fn(); }
  function F2(v){ return (Number.isFinite(v)? Number(v).toFixed(2) : '--'); }
  function RR(entry, tgt, stop){ var g=Math.abs(tgt-entry), l=Math.abs(entry-stop); return l>0? (g/l) : 0; }
  function vol18(ts){ var v = ts.analyzeSystemVolatility?.(); return v && v.p18 ? (v.p18.volatilityPercent||2.0) : 2.0; }
  function ptsByVol(v){ return v>=3.0 ? 15 : (v<=1.5 ? 10 : 12); }

  function computeTiers(ts, side){
    var ga = ts.analyzeSystemGARCH?.() || {}; var p18 = ga.p18||{}, p27=ga.p27||{};
    var s  = ts.generateTradingStrategy?.() || {}; var seed = side==='BUY' ? s.long : s.short;
    var tiers = []; var pts = ptsByVol(vol18(ts));

    if (seed && Number.isFinite(seed.entryRange?.min) && Number.isFinite(seed.entryRange?.max)){
      var ref = (seed.entryRange.min + seed.entryRange.max)/2;
      tiers.push({ key:'T1', label:'N√≠vel 1 - Zona Principal (Regi√£o)', entry:ref,
        stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
        tgt:(side==='BUY')?(ref+pts):(ref-pts),
        note:'Regi√£o '+F2(seed.entryRange.min)+'‚Äì'+F2(seed.entryRange.max) });
    }
    var s18 = (side==='BUY')? p18.down2sigma : p18.up2sigma;
    var s27 = (side==='BUY')? p27.down2sigma : p27.up2sigma;
    if (Number.isFinite(s18)) tiers.push({ key:'T2', label:'N√≠vel 2 - Extens√£o 18P (¬±2œÉ 18P)', entry:s18,
      stop:(side==='BUY')? (s18-10) : (s18+10), tgt:(side==='BUY')? (s18+pts) : (s18-pts),
      note:'18P '+(side==='BUY'?'‚àí2œÉ':'+2œÉ') });
    if (Number.isFinite(s27)) tiers.push({ key:'T3', label:'N√≠vel 3 - Extremo 27P (¬±2œÉ 27P)', entry:s27,
      stop:(side==='BUY')? (s27-10) : (s27+10), tgt:(side==='BUY')? (s27+pts) : (s27-pts),
      note:'27P '+(side==='BUY'?'‚àí2œÉ':'+2œÉ') });

    if (!tiers.length) return null;
    tiers.sort(function(a,b){ return side==='BUY' ? b.entry-a.entry : a.entry-b.entry; });
    return {tiers:tiers};
  }

  function ensureHeadlineHost(card, side){
    var head = card.querySelector('.tier-headline');
    if(!head){
      head = document.createElement('div');
      head.className = 'tier-headline';
      var h = card.querySelector('h4') || card.firstChild;
      if (h && h.parentNode) h.parentNode.insertBefore(head, h.nextSibling);
      else card.insertBefore(head, card.firstChild);
    }
    head.style.background   = (side==='BUY') ? '#ecfdf5' : '#fef2f2';
    head.style.borderColor  = (side==='BUY') ? '#86efac' : '#fca5a5';
    return head;
  }

  function renderInto(card, side, tier){
    var head = ensureHeadlineHost(card, side);
    var rr   = RR(tier.entry, tier.tgt, tier.stop);
    head.innerHTML =
      '<span class=\"k\">An√°lise (</span><b>'+ tier.label +'</b><span class=\"k\">):</span> ' +
      '<span class=\"k\">Gatilho</span> <span class=\"v\">'+ F2(tier.entry) +'</span> ¬∑ ' +
      '<span class=\"k\">Stop</span> <span class=\"v\">'+ F2(tier.stop) +'</span> ¬∑ ' +
      '<span class=\"k\">Alvo</span> <span class=\"v\">'+ F2(tier.tgt) +'</span> ¬∑ ' +
      '<span class=\"k\">R/R</span> <span class=\"v\">1:'+ rr.toFixed(2) +'</span>';

    var box = card.querySelector('.tier-box');
    if (box){
      var pts = ptsByVol(vol18(window.tradingSystem||{}));
      box.innerHTML =
        '<div class=\"tier-line\"><b>'+ tier.label +'</b></div>' +
        '<div class=\"tier-line\">üéØ Entrada: <b class=\"tier-mono\">'+ F2(tier.entry) +'</b> ' +
        '&nbsp;|&nbsp; üõë Stop: <b class=\"tier-mono\">'+ F2(tier.stop) +'</b> ' +
        '&nbsp;|&nbsp; ‚úÖ Alvo curto: <b class=\"tier-mono\">'+ F2(tier.tgt) +'</b> ' +
        '&nbsp;<span class=\"tier-note\">(¬± '+ pts +' pts)</span></div>' +
        (tier.note ? '<div class=\"tier-note\">'+ tier.note +'</div>' : '') +
        '<div class=\"tier-note\">Alvo final: manter parcial at√© o <b>Just√≠ssimo</b> se a dire√ß√£o favorecer.</div>';
    }
  }

  function wireCard(card){
    var isBuy = card.classList.contains('card-success') || /compra/i.test(card.textContent);
    var side  = isBuy ? 'BUY' : 'SELL';
    var pack  = computeTiers(window.tradingSystem||{}, side);
    if(!pack) return;
    var tabs = card.querySelectorAll('.tier-tabs .tier-tab');
    if(!tabs.length) return;
    var map = {};
    pack.tiers.forEach(function(t){ map[t.key] = t; });

    function activeKey(btn){
      var txt = (btn.textContent||'').trim().toUpperCase();
      return txt==='T1' ? 'T1' : (txt==='T2' ? 'T2' : 'T3');
    }

    // initial render
    var active = Array.prototype.find.call(tabs, function(b){return b.classList.contains('active');}) || tabs[0];
    var key0   = activeKey(active);
    renderInto(card, side, map[key0] || pack.tiers[0]);

    // clicks
    tabs.forEach(function(btn){
      btn.addEventListener('click', function(){
        tabs.forEach(function(x){ x.classList.remove('active'); });
        btn.classList.add('active');
        var k = activeKey(btn);
        renderInto(card, side, map[k] || pack.tiers[0]);
      }, {once:false});
    });
  }

  function install(){
    var ts = window.tradingSystem;
    if (!ts || typeof ts.renderStrategyPanel !== 'function'){
      setTimeout(install, 120);
      return;
    }
    var original = ts.renderStrategyPanel.bind(ts);
    ts.renderStrategyPanel = function(){
      var r = original();
      try{
        var op = document.getElementById('aiOperation');
        if(!op) return r;
        var cards = op.querySelectorAll('.card-grid > .card');
        if(cards[0]) wireCard(cards[0]);
        if(cards[1]) wireCard(cards[1]);
      }catch(e){ /* silent */ }
      return r;
    };
  }
  ready(install);
})();
</script>







<script id="fix-a2-daily-final">
(function(){
  // -------- helpers (locale-safe) --------
  function numBR(v){
    if (v==null || v==='') return NaN;
    if (typeof v === 'number') return v;
    var s = (''+v).trim();
    if (!s) return NaN;
    if (s.indexOf(',')>-1 && s.indexOf('.')>-1){ s = s.replace(/\./g,'').replace(',', '.'); return parseFloat(s); }
    if (s.indexOf(',')>-1){ return parseFloat(s.replace(',', '.')); }
    return parseFloat(s);
  }
  function fmtMoneyBR(x){
    var s = Number(x).toFixed(2);
    var p = s.split('.'); p[0] = p[0].replace(/\B(?=(\d{3})+(?!\d))/g,'.');
    return p[0] + ',' + p[1];
  }
  function fmtPts(x){ return Number(x).toFixed(2).replace('.', ','); } // sem milhar

  function readVWAPD(){ return numBR(document.getElementById('vwapD')?.value); }

  function parseTier(box){
    var txt = box.textContent || '';
    var mE = txt.match(/Entrada:\s*([\d\.,]+)/);
    var mS = txt.match(/Stop:\s*([\d\.,]+)/);
    var mT = txt.match(/Alvo curto:\s*([\d\.,]+)/);
    return { entry: numBR(mE && mE[1]), stop: numBR(mS && mS[1]), tgt: numBR(mT && mT[1]) };
  }

  function detectSide(vals){
    if (!isFinite(vals.entry) || !isFinite(vals.tgt)) return null;
    return (vals.tgt >= vals.entry) ? 'BUY' : 'SELL';
  }

  function cleanHeadline(card){
    var h = card.querySelector('.tier-headline'); if (!h) return;
    var s = h.innerHTML || '';
    s = s.replace(/Extens[a√£]o\s*18P/gi, 'Extens√£o M√©dia')
         .replace(/Extremo\s*27P/gi, 'Extremidade')
         .replace(/\s*\([^)]*\)/g, '');  // remove tudo entre par√™nteses
    h.innerHTML = s;
  }

  function colorSigmaAlert(box, side){
    var color = side==='BUY' ? '#065f46' : '#991b1b';
    box.querySelectorAll('.tier-note').forEach(function(n){
      var t=(n.textContent||'').trim();
      if (/\b(18P|27P)\b.*œÉ/.test(t) || /Zona de sobre(venda|compra) estat√≠stica/i.test(t)){
        var msg = side==='BUY' ? 'Zona de sobrevenda estat√≠stica' : 'Zona de sobrecompra estat√≠stica';
        n.innerHTML = '<span style="display:inline-flex;align-items:center;gap:6px;color:'+color+'"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M1 21h22L12 2 1 21zm11-3h-2v-2h2v2zm0-4h-2V8h2v6z"/></svg><span>'+msg+'</span></span>';
      }
    });
  }

  function enforceA2Daily(box, side, vals, vwapD){
    if (!isFinite(vwapD) || !isFinite(vals.entry) || !isFinite(vals.stop)) return;
    if (side==='BUY' && vwapD < vals.entry) return;
    if (side==='SELL' && vwapD > vals.entry) return;

    // remove qualquer A2 existente (Mensal/Semanal antigos)
    Array.from(box.querySelectorAll('.tier-note.a2')).forEach(n=>n.remove());

    var rr = Math.abs((vwapD - vals.entry) / (vals.entry - vals.stop)) || 0;
    var delta = vwapD - vals.entry;
    var sign = delta>=0 ? '+' : '';
    var div = document.createElement('div');
    div.className = 'tier-note a2';
    div.innerHTML = 'üéØ Alvo VWAP (A2 ‚Äì Di√°ria): <b class="tier-mono">'+ fmtMoneyBR(vwapD) +'</b> ¬∑ Œî='+sign+ fmtPts(Math.abs(delta)) +' pts ¬∑ R/R=1:'+ rr.toFixed(2);
    var after = box.querySelector('.tier-note');
    (after && after.parentNode) ? after.parentNode.insertBefore(div, after.nextSibling) : box.appendChild(div);
  }

  function apply(){
    var op = document.getElementById('aiOperation'); if(!op) return;
    var cards = op.querySelectorAll('.card, .card-grid > .card');
    var vD = readVWAPD();
    cards.forEach(function(card){
      var box = card.querySelector('.tier-box') || card; if(!box) return;
      var vals = parseTier(box);
      var side = detectSide(vals) || 'BUY';
      var fp = [vals.entry, vals.stop, vals.tgt, vD, side, (card.querySelector('.tier-tabs .active, .tier-tabs .is-active')||{}).textContent].join('|');
      if (card.dataset._a2fp === fp) return;
      cleanHeadline(card);
      colorSigmaAlert(box, side);
      enforceA2Daily(box, side, vals, vD);
      card.dataset._a2fp = fp;
    });
  }

  // run stably
  var scheduled=false;
  function schedule(){ if(scheduled) return; scheduled=true; requestAnimationFrame(function(){ scheduled=false; apply(); }); }
  document.addEventListener('click', function(e){
    if (e.target?.classList?.contains('tier-tab') || e.target?.closest('.tier-tab')) schedule();
  }, {passive:true});
  new MutationObserver(function(){ schedule(); }).observe(document.getElementById('aiStrategyPanel')||document.body, {childList:true, subtree:true});
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', schedule); else schedule();
})();
</script>


<!-- ===== Intraday Enhancements Patch v2 ===== -->
<script>
(function(){
  if (window.__intradayEnhancementsPatchedV2__) return;
  window.__intradayEnhancementsPatchedV2__ = true;
  try { console.log("[Intraday Patch] v2 loaded"); } catch(e){}

  // ---- Polyfills ----
  if (typeof Math.erf !== "function"){
    // Abramowitz & Stegun approximation
    Math.erf = function(x){
      const sign = (x>=0)?1:-1; x=Math.abs(x);
      const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
      const t=1/(1+p*x);
      const y=1-((((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t)*Math.exp(-x*x);
      return sign*y;
    };
  }

  // ---- Helpers ----
  function _phi(x){ return 0.5*(1+Math.erf(x/Math.SQRT2)); }
  function _z(level, ref, sigmaPct){ 
    if(!isFinite(level)||!isFinite(ref)||!isFinite(sigmaPct)||sigmaPct<=0) return NaN;
    return (level/ref - 1) / (sigmaPct/100);
  }
  function _pTouch(level, ref, sigmaPct, side){
    const z = _z(level, ref, sigmaPct);
    if(!isFinite(z)) return 0;
    return (side==='BUY') ? (1 - _phi(z)) : _phi(z);
  }
  function _evPoints(entry, tgt, stop, pWin){
    if(![entry,tgt,stop,pWin].every(isFinite)) return 0;
    const reward = Math.abs(tgt - entry);
    const risk   = Math.abs(entry - stop);
    const p      = Math.max(0, Math.min(1, pWin));
    return p*reward - (1-p)*risk;
  }
  function _regionQuality(levels, vwapD, vwapS, vwapM){
    const lv = (levels||[]).filter(isFinite);
    if(lv.length<2) return 40;
    const spread = Math.max(...lv) - Math.min(...lv);
    const tight   = Math.max(0, 1 - spread/20);
    const vwapRef = [vwapD, vwapS, vwapM].filter(isFinite);
    let vCons = 0;
    if (vwapRef.length){
      const ref = vwapRef.reduce((a,b)=>a+b,0)/vwapRef.length;
      const dist = Math.abs(((ref - (lv[0]+lv[lv.length-1])/2) / ref))*100;
      vCons = Math.max(0, 1 - dist/0.6);
    }
    return Math.round(100 * (0.65*tight + 0.35*vCons));
  }
  function _num(v){
    if(v==null) return NaN;
    if(typeof v === 'number') return v;
    const t = String(v).replace(/\s+/g,'').replace(/\./g,'').replace(',', '.');
    const n = parseFloat(t);
    return isFinite(n)?n:NaN;
  }
  function _getVWAP(id){
    try{
      const el = document.getElementById(id);
      if(!el) return NaN;
      return _num(el.value ?? el.textContent);
    }catch(e){ return NaN; }
  }

  function findCards(){
    const buy = document.getElementById('cardBUY')  || document.querySelector('#aiOperation .card.card-success') || document.querySelector('.card.buy') || document.querySelector('.card-success');
    const sell= document.getElementById('cardSELL') || document.querySelector('#aiOperation .card.card-danger')  || document.querySelector('.card.sell')|| document.querySelector('.card-danger');
    return {buy, sell};
  }

  function getSystem(){
    const sys = window.system || window.tradingSystem || window.aiSystem || window.TradingSystem || window.app || null;
    return sys;
  }

  function calcSigmaPct(sys){
    const p = (sys && sys.currentIntradayP) || 18;
    let s = NaN;
    if(sys && typeof sys.calculateStdDevReturns === 'function'){
      s = sys.calculateStdDevReturns(p);
    } else if (typeof window.calculateStdDevReturns === 'function'){
      s = window.calculateStdDevReturns(p);
    }
    return {period: p, sigmaPct: isFinite(s)?(s*100):NaN};
  }

  function lastClose(sys){
    if(sys && typeof sys.lastClose === 'function') return sys.lastClose();
    if(typeof window.lastClose === 'function') return window.lastClose();
    const el = document.querySelector('[data-last-close], #lastClose, .last-close');
    if(el) return _num(el.textContent||el.value);
    return NaN;
  }

  function renderCardStats(card, side, entry, target, stop, opts){
    if(!card) return;
    card.querySelectorAll('[data-block="intraday-stats"]').forEach(n=>n.remove());
    const {period, sigmaPct} = opts;
    const px = opts.priceRef;

    const pEntry = _pTouch(entry, px, sigmaPct, side);
    const pTgt   = _pTouch(target, entry, sigmaPct, side);
    const pStop  = _pTouch(stop,   entry, sigmaPct, side==='BUY'?'SELL':'BUY');
    const pWin   = Math.max(0, Math.min(1, pTgt / (pTgt + pStop + 1e-9)));
    const ev     = _evPoints(entry, target, stop, pWin);

    const box   = document.createElement('div');
    box.setAttribute('data-block','intraday-stats');
    box.style.marginTop = '8px';
    box.style.border = '1px solid #e5e7eb';
    box.style.borderRadius = '10px';
    box.style.padding = '8px 10px';
    box.style.background = '#fff';
    box.innerHTML = `
      <div style="font-size:12px; font-weight:900; margin-bottom:6px;">üìä Probabilidades (intraday ${period}P)</div>
      <div style="font-size:12px; display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:6px;">
        <div>ü™ô <b>P(Entrada)</b>: ${(pEntry*100).toFixed(0)}%</div>
        <div>üéØ <b>P(Alvo)</b>: ${(pTgt*100).toFixed(0)}%</div>
        <div>üõë <b>P(Stop)</b>: ${(pStop*100).toFixed(0)}%</div>
        <div>‚úÖ <b>P(Win)</b>: ${(pWin*100).toFixed(0)}%</div>
      </div>
      <div style="font-size:12px; margin-top:6px;">
        üí∞ <b>EV</b>: ${ev>=0?'+':''}${Math.round(ev)} pts
        &nbsp;|&nbsp; œÉ${period} = ${isFinite(sigmaPct)?sigmaPct.toFixed(2):'‚Äì'}%
      </div>
    `;
    card.appendChild(box);
  }

  function parseCardNumbers(card){
    // tenta achar entrada/alvo/stop no texto do card
    const txt = (card && card.textContent || '').toLowerCase();
    const mEntry = /entrada[:\s]*([0-9\.,]+)/i.exec(txt);
    const mMeta  = /(meta|alvo)[:\s]*([0-9\.,]+)/i.exec(txt);
    const mStop  = /(stop|stoploss|stop loss)[:\s]*([0-9\.,]+)/i.exec(txt);
    return {
      entry: _num(mEntry && mEntry[1]),
      target: _num(mMeta && mMeta[2]),
      stop: _num(mStop && mStop[2])
    };
  }

  function attachQualityTag(card, levels, vD, vS, vM){
    const qs = _regionQuality(levels, vD, vS, vM);
    const head = card.querySelector('.headline') || card.querySelector('h4, h3, .card-title') || card;
    const tag = document.createElement('span');
    tag.style.fontSize = '11px'; tag.style.color = '#334155'; tag.setAttribute('data-block','intraday-stats');
    tag.innerHTML = ` &nbsp;¬∑&nbsp; ‚≠ê <b>${qs}</b> qualidade`;
    head.appendChild(tag);
  }

  function runOnce(){
    const {buy, sell} = findCards();
    if(!buy && !sell) return false;
    const sys = getSystem();
    const sigmaInfo = calcSigmaPct(sys);
    const priceRef = lastClose(sys);
    if(!isFinite(priceRef)) return false;
    const vD = _getVWAP('vwapD'), vS=_getVWAP('vwapS'), vM=_getVWAP('vwapM');

    if (buy){
      const {entry, target, stop} = parseCardNumbers(buy);
      if([entry,target,stop].every(isFinite)){
        renderCardStats(buy, 'BUY', entry, target, stop, {period:sigmaInfo.period, sigmaPct:sigmaInfo.sigmaPct, priceRef});
        attachQualityTag(buy, [entry, entry], vD, vS, vM);
      }
    }
    if (sell){
      const {entry, target, stop} = parseCardNumbers(sell);
      if([entry,target,stop].every(isFinite)){
        renderCardStats(sell, 'SELL', entry, target, stop, {period:sigmaInfo.period, sigmaPct:sigmaInfo.sigmaPct, priceRef});
        attachQualityTag(sell, [entry, entry], vD, vS, vM);
      }
    }
    return true;
  }

  // Try immediately and re-try a few times (for SPA hydration)
  function schedule(){
    setTimeout(runOnce, 500);
    setTimeout(runOnce, 1500);
    setTimeout(runOnce, 3000);
    setTimeout(runOnce, 6000);
  }

  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    schedule();
  }else{
    document.addEventListener('DOMContentLoaded', schedule);
  }

  // Also re-run when the user clicks in the AI operation area (likely after recompute)
  document.addEventListener('click', function(ev){
    const el = ev.target;
    if(!el) return;
    if(el.closest && el.closest('#aiOperation, .ai-operation, .recompute, .apply, button')){
      setTimeout(runOnce, 300);
      setTimeout(runOnce, 1200);
    }
  });
})();
</script>
<!-- ===== /Intraday Enhancements Patch v2 ===== -->


<!-- ===== Intraday Bars Visualization Patch (v3b: inside stats box) ===== -->
<script>
(function(){
  if(window.__intradayBarsV3b__) return; window.__intradayBarsV3b__=true;

  function _num(v){ if(v==null) return NaN; if(typeof v==='number') return v; const t=String(v).replace(/\s+/g,'').replace(/\./g,'').replace(',', '.'); const n=parseFloat(t); return isFinite(n)?n:NaN; }
  if (typeof Math.erf !== "function"){
    Math.erf = function(x){
      const sign = (x>=0)?1:-1; x=Math.abs(x);
      const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
      const t=1/(1+p*x);
      const y=1-((((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t)*Math.exp(-x*x);
      return sign*y;
    };
  }
  function _phi(x){ return 0.5*(1+Math.erf(x/Math.SQRT2)); }
  function _z(level, ref, sigmaPct){ if(!isFinite(level)||!isFinite(ref)||!isFinite(sigmaPct)||sigmaPct<=0) return NaN; return (level/ref - 1) / (sigmaPct/100); }
  function _pTouch(level, ref, sigmaPct, side){ const z=_z(level,ref,sigmaPct); if(!isFinite(z)) return 0; return (side==='BUY') ? (1-_phi(z)) : _phi(z); }
  function _evPoints(entry, tgt, stop, pWin){ const reward=Math.abs(tgt-entry), risk=Math.abs(entry-stop); const p=Math.max(0,Math.min(1,pWin)); return p*reward-(1-p)*risk; }

  function findCards(){
    const buy = document.getElementById('cardBUY')  || document.querySelector('#aiOperation .card.card-success') || document.querySelector('.card.buy') || document.querySelector('.card-success');
    const sell= document.getElementById('cardSELL') || document.querySelector('#aiOperation .card.card-danger')  || document.querySelector('.card.sell')|| document.querySelector('.card-danger');
    return {buy, sell};
  }
  function parseCardNumbers(card){
    const txt = (card && card.textContent || '');
    const mEntry = /Entrada[:\s]*([0-9\.,]+)/i.exec(txt);
    const mMeta  = /(Meta|Alvo)[:\s]*([0-9\.,]+)/i.exec(txt);
    const mStop  = /(Stop(?:\s*Loss)?)[:\s]*([0-9\.,]+)/i.exec(txt);
    return { entry:_num(mEntry && mEntry[1]), target:_num(mMeta && mMeta[2]), stop:_num(mStop && mStop[2]) };
  }
  function lastClose(){
    if(typeof window.lastClose==='function') return window.lastClose();
    const el = document.querySelector('[data-last-close], #lastClose, .last-close');
    if(el) return _num(el.textContent||el.value);
    return NaN;
  }
  function calcSigmaPct(){
    const p = (window.system && window.system.currentIntradayP) || 18;
    let s = NaN;
    if(window.system && typeof window.system.calculateStdDevReturns==='function'){
      s = window.system.calculateStdDevReturns(p);
    }else if(typeof window.calculateStdDevReturns==='function'){
      s = window.calculateStdDevReturns(p);
    }
    return {period:p, sigmaPct: isFinite(s)?(s*100):NaN};
  }

  function ensureBars(container, stats){
    if(!container) return;
    // render DENTRO do bloco intraday-stats, logo abaixo do texto de EV
    // se n√£o existir intraday-stats, usa o card inteiro
    const host = container.querySelector('[data-block="intraday-stats"]') || container;
    // remove antigos
    host.querySelectorAll('[data-block="intraday-bars"]').forEach(n=>n.remove());

    const wrap = document.createElement('div');
    wrap.setAttribute('data-block','intraday-bars');
    wrap.style.marginTop = '6px';

    function bar(label, val, color){
      const outer = document.createElement('div');
      outer.style.fontSize = '11px';
      outer.style.margin = '2px 0 8px 0';
      const row  = document.createElement('div');
      row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center';
      const lab  = document.createElement('span'); lab.textContent = label;
      const pct  = document.createElement('span'); pct.textContent = (val*100).toFixed(0)+'%';
      row.appendChild(lab); row.appendChild(pct);
      const inner = document.createElement('div');
      inner.style.height = '10px'; inner.style.background = '#e2e8f0'; inner.style.borderRadius = '4px'; inner.style.overflow='hidden';
      const fill = document.createElement('div');
      fill.style.height='100%'; fill.style.width=(val*100).toFixed(0)+'%'; fill.style.background = color;
      inner.appendChild(fill);
      outer.appendChild(row);
      outer.appendChild(inner);
      return outer;
    }

    wrap.appendChild(bar("üéØ P(Alvo)", stats.pTgt, stats.ev>=0?"#10b981":"#22c55e"));
    wrap.appendChild(bar("üõë P(Stop)", stats.pStop, "#ef4444"));
    wrap.appendChild(bar("‚úÖ P(Win)",  stats.pWin, stats.ev>=0?"#10b981":"#ef4444"));

    const evLine = document.createElement('div');
    evLine.style.fontSize = '11px'; evLine.style.marginTop = '4px';
    evLine.innerHTML = "üí∞ EV: "+(stats.ev>=0?'+':'')+Math.round(stats.ev)+" pts";
    wrap.appendChild(evLine);

    host.appendChild(wrap);
  }

  function computeAndRender(){
    const {buy, sell} = findCards();
    if(!buy && !sell) return false;
    const px = lastClose();
    const {period, sigmaPct} = calcSigmaPct();
    if(!isFinite(px) || !isFinite(sigmaPct) || sigmaPct<=0) return false;

    function run(card, side){
      const {entry, target, stop} = parseCardNumbers(card);
      if([entry,target,stop].every(isFinite)){
        const pTgt=_pTouch(target, entry, sigmaPct, side);
        const pStop=_pTouch(stop,   entry, sigmaPct, side==='BUY'?'SELL':'BUY');
        const pWin=Math.max(0,Math.min(1,pTgt/(pTgt+pStop+1e-9)));
        const ev=_evPoints(entry, target, stop, pWin);
        ensureBars(card, {pTgt, pStop, pWin, ev});
      }
    }
    if(buy) run(buy, 'BUY');
    if(sell) run(sell, 'SELL');
    return true;
  }

  function schedule(){
    setTimeout(computeAndRender, 800);
    setTimeout(computeAndRender, 1800);
    setTimeout(computeAndRender, 3800);
    setTimeout(computeAndRender, 6800);
  }
  if(document.readyState==='complete' || document.readyState==='interactive'){ schedule(); }
  else { document.addEventListener('DOMContentLoaded', schedule); }

  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.closest && ev.target.closest('#aiOperation, .ai-operation, .recompute, .apply, button')){
      setTimeout(computeAndRender, 500);
      setTimeout(computeAndRender, 1500);
    }
  });
})();
</script>
<!-- ===== /Intraday Bars Visualization Patch (v3b) ===== -->


<script>
(function(){
  function autoloadNow(){
    try {
      const TENANT = (sessionStorage.getItem('tenantId') || 'genesis-trading');
      const VERS = (window.VERSION_TAG || sessionStorage.getItem('versionTag') || 'default');
      if (window.supabase && typeof window.supabase.from === 'function') {
        supabase.from('dol_fechamentos')
          .select('data, rows, imported_at')
          .eq('tenant_id', TENANT).eq('version_tag', VERS)
          .order('imported_at', { ascending:false })
          .limit(1)
          .then(({data,error})=>{
            if(!error && data && data.length){
              const rows = data[0].rows || (data[0].data ? data[0].data.length : 0);
              try { document.getElementById('dataCount').textContent = String(rows); } catch(_){}
              try { window.dispatchEvent(new CustomEvent('dataset:loaded',{ detail:{ tenant:TENANT, version:VERS, length:rows }})); } catch(_){ }
              console.log('Autoload dashboard:', TENANT, VERS, rows);
              // Se a app existir, pe√ßa para recalcular/renderizar
              const app = window.__appInstance || window._lastAppInstance;
              if (app && typeof app.loadFromDB === 'function') { app.loadFromDB(); }
            } else {
              console.log('Autoload: sem dados para tenant atual.');
            }
          });
      } else {
        console.warn('Autoload: supabase client n√£o encontrado.');
      }
    } catch(e){ console.warn('Autoload falhou:', e); }
  }
  if (document.readyState === 'complete' || document.readyState === 'interactive') autoloadNow();
  else document.addEventListener('DOMContentLoaded', autoloadNow);
})();
</script>

</body>
<!-- Indicadores de Proximidade (Pre√ßo Atual) -->
<script>
function getProximityStatus(currentPrice, entryPrice) {
  const distance = Math.abs(currentPrice - entryPrice);
  if (distance <= 5) return "üéØ MUITO PR√ìXIMO";
  if (distance <= 10) return "‚ö†Ô∏è PR√ìXIMO";
  if (distance <= 20) return "üìç DISTANTE";
  return "üîç MUITO DISTANTE";
}
</script>

<!-- Estilos adicionais para a visualiza√ß√£o -->
<style>
  .proximity-badge {
    font-size: 12px;
    padding: 6px 10px;
    border-radius: 12px;
    background: #f3f4f6;
    color: #374151;
    font-weight: 700;
  }
  .tier-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid #e5e7eb;
  }
  .tier-levels {
    display: grid;
    gap: 8px;
    margin-bottom: 12px;
  }
  .level-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 10px;
    border-radius: 8px;
    background: #f9fafb;
  }
  .level-item.entry { border-left: 3px solid #3b82f6; }
  .level-item.stop { border-left: 3px solid #ef4444; }
  .level-item.target { border-left: 3px solid #10b981; }
  .level-label { font-size: 12px; color: #6b7280; font-weight: 600; }
  .level-value { font-weight: 900; font-variant-numeric: tabular-nums; }
  .level-detail {
    font-size: 10px;
    color: #9ca3af;
    margin-left: 8px;
  }
  .tier-explanation, .tier-action {
    font-size: 12px;
    padding: 8px;
    border-radius: 6px;
    margin-top: 8px;
  }
  .tier-explanation {
    background: #eff6ff;
    border: 1px solid #dbeafe;
    color: #1e40af;
  }
  .tier-action {
    background: #f0fdf4;
    border: 1px solid #bbf7d0;
    color: #166534;
  }
  .proximity {
    font-weight: 700;
    font-size: 14px;
  }
  .tier-pro {
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    background: #fff;
    padding: 12px 14px;
    margin-top: 6px;
  }
  .tier-pro h5 {
    margin: 0 0 8px 0;
    font-size: 14px;
    font-weight: 900;
    color: #0f172a;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .tier-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 6px;
  }
  .tline {
    font-size: 13px;
    color: #0f172a;
  }
  .tkey {
    color: #64748b;
    font-weight: 800;
  }
  .tval {
    font-weight: 900;
    font-variant-numeric: tabular-nums;
  }
  .tnote {
    font-size: 12px;
    color: #475569;
    margin-top: 6px;
  }
</style>
