<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sistema Quant Pro - GÃªnesis Trading</title>
  <style>
    :root{
      --primary-gradient: linear-gradient(135deg, #4f46e5, #7c3aed, #06b6d4);
      --bg: #f8fafc;
      --panel: #ffffff;
      --panel-2: #f1f5f9;
      --text: #1e293b;
      --muted: #64748b;
      --accent: #3b82f6;
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
      --border: #e2e8f0;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --ai-gradient: linear-gradient(135deg, #8b5cf6, #06b6d4);
      --ai-bg: linear-gradient(145deg, #f0f9ff, #e0f2fe);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
    }
    
    header {
      padding: 16px 20px;
      background: var(--primary-gradient);
      color: white;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: var(--shadow-lg);
    }
    
    @media(min-width:768px){header{padding:24px;}}
    
    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .title {
      font-size: 18px;
      font-weight: 800;
      letter-spacing: -.5px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    @media(min-width:768px){.title{font-size:24px;gap:12px;}}
    
    .sub {
      color: rgba(255,255,255,0.9);
      font-size: 12px;
      margin-top: 6px;
      font-weight: 400;
      line-height: 1.4;
    }
    
    @media(min-width:768px){.sub{font-size:14px;}}
    
    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .user-name {
      font-weight: 600;
      font-size: 14px;
    }
    
    .status-badge {
      background: rgba(255,255,255,0.2);
      color: white;
      padding: 4px 8px;
      border-radius: 20px;
      font-size: 10px;
      font-weight: 600;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    @media(min-width:768px){.status-badge{padding:4px 12px;font-size:11px;}}
    
    .logout-btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .logout-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-1px);
    }
    
    main {
      padding: 16px;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    @media(min-width:768px){main{padding:32px 24px;}}
    
    .main-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    @media(min-width:1024px){
      .main-grid{
        grid-template-columns: 1fr 300px;
        gap: 24px;
      }
    }
    
    .content-area {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    @media(min-width:1200px){
      .content-area{
        grid-template-columns: 1.2fr 0.8fr;
        gap: 24px;
      }
    }
    
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    
    @media(min-width:768px){.panel{border-radius:20px;padding:24px;}}
    
    .ai-panel {
      background: var(--ai-bg);
      border: 2px solid #06b6d4;
      position: relative;
      overflow: hidden;
    }
    
    .ai-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--ai-gradient);
    }
    
    h2.section-title {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ai-title {
      background: var(--ai-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .muted {
      color: var(--muted);
    }
    
    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    
    @media(min-width:480px){.toolbar{gap:12px;}}
    
    .btn {
      background: var(--panel-2);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 12px 16px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: var(--shadow);
    }
    
    .btn:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }
    
    .btn.primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    
    .btn.ai {
      background: var(--ai-gradient);
      color: white;
      border: none;
    }
    
    .btn.success {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .periods {
      display: flex;
      gap: 6px;
      margin: 8px 0 16px;
      flex-wrap: wrap;
    }
    
    @media(min-width:480px){.periods{gap:8px;}}
    
    .tab {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      background: var(--panel-2);
      font-size: 12px;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: var(--shadow);
    }
    
    @media(min-width:480px){.tab{padding:10px 16px;font-size:13px;}}
    
    .tab.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    
    .cards {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    @media(min-width:480px){.cards{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media(min-width:768px){.cards{grid-template-columns:repeat(3,minmax(0,1fr));}}
    @media(min-width:1024px){.cards{grid-template-columns:repeat(4,minmax(0,1fr));}}
    
    .fair-price-cards {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    @media(min-width:480px){.fair-price-cards{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media(min-width:768px){.fair-price-cards{grid-template-columns:repeat(4,minmax(0,1fr));}}
    
    .card {
      background: linear-gradient(145deg, #ffffff, #f8fafc);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--accent), var(--success));
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .card:hover::before {
      opacity: 1;
    }
    
    .card.up-card {
      background: linear-gradient(145deg, #f0fdf4, #dcfce7);
      border-color: #bbf7d0;
    }
    
    .card.down-card {
      background: linear-gradient(145deg, #fef2f2, #fee2e2);
      border-color: #fecaca;
    }
    
    .card.neutral-card {
      background: linear-gradient(145deg, #f1f5f9, #e2e8f0);
      border-color: #cbd5e1;
    }
    
    .label {
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .5px;
      margin-bottom: 8px;
      line-height: 1.3;
    }
    
    .value {
      font-size: 18px;
      font-weight: 900;
      letter-spacing: -.5px;
      line-height: 1.2;
    }
    
    @media(min-width:480px){.value{font-size:20px;}}
    @media(min-width:768px){.value{font-size:22px;}}
    
    .value.up {
      color: var(--success);
    }
    
    .value.down {
      color: var(--error);
    }
    
    .inputs {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 12px;
      margin: 12px 0 16px;
    }
    
    @media(min-width:480px){.inputs{grid-template-columns:repeat(3,minmax(0,1fr));}}
    
    .input {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      box-shadow: var(--shadow);
    }
    
    .input label {
      display: block;
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: .5px;
    }
    
    .input input, .input select {
      width: 100%;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      padding: 10px;
      font-weight: 600;
    }
    
    .hint {
      font-size: 12px;
      color: var(--muted);
      font-weight: 500;
    }
    
    .api-config {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin: 16px 0;
    }
    
    .api-status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }
    
    .api-status.connected {
      background: #dcfce7;
      color: #166534;
    }
    
    .api-status.disconnected {
      background: #fee2e2;
      color: #991b1b;
    }
    
    .api-status.testing {
      background: #fef3c7;
      color: #92400e;
    }
    
    .sep {
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--border), transparent);
      margin: 24px 0;
    }
    
    textarea {
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      resize: vertical;
      box-shadow: var(--shadow);
    }
    
    input[type="file"] {
      color: var(--text);
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      width: 100%;
      box-shadow: var(--shadow);
    }
    
    .debug {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin: 12px 0;
      font-size: 11px;
      color: var(--muted);
      font-family: monospace;
      box-shadow: var(--shadow);
    }
    
    .maxmin-grid {
      display: grid;
      grid-template-columns: repeat(1,minmax(0,1fr));
      gap: 12px;
    }
    
    @media(min-width:480px){.maxmin-grid{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media(min-width:768px){.maxmin-grid{grid-template-columns:repeat(3,minmax(0,1fr));gap:16px;}}
    
    footer {
      color: var(--muted);
      text-align: center;
      padding: 32px;
      font-size: 12px;
      font-weight: 600;
      margin-top: 40px;
      border-top: 1px solid var(--border);
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(248, 250, 252, 0.8);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid var(--border);
      border-top: 4px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .welcome-banner {
      background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
      border: 1px solid #7dd3fc;
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 24px;
      text-align: center;
    }
    
    .welcome-banner h3 {
      color: var(--accent);
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    .welcome-banner p {
      color: var(--muted);
      font-size: 14px;
    }
    
    .api-info {
      background: var(--panel-2);
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
      font-size: 11px;
      line-height: 1.4;
    }
    
    .provider-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin: 12px 0;
    }
    
    .provider-card {
      background: var(--panel);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }
    
    .provider-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .provider-card.active {
      border-color: var(--accent);
      background: linear-gradient(145deg, #f0f9ff, #dbeafe);
    }
    
    .provider-card h4 {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 4px;
      color: var(--text);
    }
    
    .provider-card p {
      font-size: 11px;
      color: var(--muted);
    }

    .frp-highlight {
      background: #fff3cd !important;
      border-color: #f59e0b !important;
    }

    .frp-disabled {
      background: #f8f9fa !important;
      opacity: 0.7;
    }
    
    /* AI-specific styles */
    .ai-insights {
      display: grid;
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .insight-card {
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #06b6d4;
      border-radius: 12px;
      padding: 16px;
      transition: all 0.3s;
    }
    
    .insight-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .insight-title {
      font-weight: 700;
      color: #0369a1;
      margin-bottom: 8px;
      font-size: 14px;
    }
    
    .insight-content {
      font-size: 13px;
      line-height: 1.5;
      color: var(--text);
    }
    
    .opportunity-score {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 16px 0;
    }
    
    .score-circle {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--ai-gradient);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      box-shadow: var(--shadow-lg);
      transition: all 0.5s ease;
    }
    
    .score-circle.buy-signal {
      background: linear-gradient(135deg, #10b981, #059669, #047857);
      box-shadow: 0 10px 15px -3px rgba(16, 185, 129, 0.3);
    }
    
    .score-circle.sell-signal {
      background: linear-gradient(135deg, #ef4444, #dc2626, #b91c1c);
      box-shadow: 0 10px 15px -3px rgba(239, 68, 68, 0.3);
    }
    
    .score-circle.neutral-signal {
      background: linear-gradient(135deg, #3b82f6, #2563eb, #1d4ed8);
      box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3);
    }
    
    .score-circle.wait-signal {
      background: linear-gradient(135deg, #f59e0b, #d97706, #b45309);
      box-shadow: 0 10px 15px -3px rgba(245, 158, 11, 0.3);
    }
    
    .score-value {
      font-size: 24px;
      font-weight: 900;
    }
    
    .score-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .scenario-bars {
      display: grid;
      gap: 12px;
    }
    
    .scenario {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .scenario-label {
      flex: 0 0 140px;
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
    }
    
    .probability-bar {
      flex: 1;
      height: 20px;
      background: var(--panel-2);
      border-radius: 10px;
      position: relative;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: var(--ai-gradient);
      border-radius: 10px;
      transition: width 0.5s ease;
    }
    
    .percentage {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 11px;
      font-weight: 600;
      color: var(--text);
    }
    
    .alerts-container {
      display: grid;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .alert-item {
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.4;
      border-left: 4px solid;
      margin-bottom: 4px;
    }
    
    .alert-item strong {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
    }
    
    .alert-item em {
      font-size: 11px;
      opacity: 0.8;
      display: block;
      margin-top: 4px;
    }
    
    .alert-item.warning {
      background: #fef3c7;
      border-color: #f59e0b;
      color: #92400e;
    }
    
    .alert-item.success {
      background: #dcfce7;
      border-color: #10b981;
      color: #166534;
    }
    
    .alert-item.info {
      background: #e0f2fe;
      border-color: #06b6d4;
      color: #0369a1;
    }
    
    .ai-narrative {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #06b6d4;
      border-radius: 12px;
      padding: 16px;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text);
    }
    
    .ai-narrative h4 {
      color: #0369a1;
      margin-bottom: 12px;
      font-size: 14px;
    }
    
    .ai-narrative p {
      margin-bottom: 10px;
    }
    
    .ai-narrative strong {
      color: var(--text);
    }
    
    /* Advanced metrics styles */
    .advanced-metrics {
	display: grid;
	grid-template-columns: repeat(2, 1fr); /* Sempre 2 colunas */
	gap: 12px;
	margin: 16px 0;
	}

	/* Para telas muito pequenas, usar 1 coluna */
	@media(max-width: 480px){
	.advanced-metrics{
    grid-template-columns: repeat(1, 1fr);
	}
	}
    
    .metric-card-advanced {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .metric-value-advanced {
      font-size: 18px;
      font-weight: 900;
      margin-bottom: 4px;
      color: var(--accent);
    }
    
    .metric-label-advanced {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    #apiConfigInputs {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    
    #apiConfigInputs .input input,
    #apiConfigInputs .input select {
      width: 100%;
      font-size: 14px;
      padding: 12px 14px;
    }
    
    @media (max-width: 480px) {
      .cards, .fair-price-cards {
        grid-template-columns: 1fr;
      }
      
      .maxmin-grid {
        grid-template-columns: 1fr;
      }
      
      .inputs {
        grid-template-columns: 1fr;
      }
      
      .toolbar {
        flex-direction: column;
        align-items: stretch;
      }
      
      .btn {
        text-align: center;
      }
      
      .provider-grid {
        grid-template-columns: 1fr;
      }
      
      .main-grid {
        grid-template-columns: 1fr;
      }
      
      .content-area {
        grid-template-columns: 1fr;
      }
      
      .advanced-metrics {
        grid-template-columns: 1fr;
      }
    }
  </style>

<style id="vwap-card-css">
  #aiStrategyPanel .vwap-card{ background:#eef6ff; border:1px solid var(--border); border-radius:16px; padding:14px; margin:8px 0 14px; }
  .vwap-head{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .vwap-title{ font-weight:900; font-size:15px; }
  .vwap-sub{ color: var(--muted); font-size:12px; font-weight:700; }
  .vwap-grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(190px,1fr)); gap:12px; margin-top:10px; }
  .vwap-field{ display:flex; flex-direction:column; gap:6px; }
  .vwap-label{ font-size:12px; color: var(--muted); font-weight:800; }
  .vwap-box{ display:flex; align-items:center; gap:8px; border:1px solid var(--border); background:#fff; border-radius:12px; padding:8px 10px; box-shadow:0 1px 0 rgba(0,0,0,.02); }
  .vwap-chip{ width:24px; height:24px; border-radius:9999px; display:inline-flex; align-items:center; justify-content:center; font-weight:900; background:var(--panel-2); color:var(--text); border:1px solid var(--border); font-size:12px; }
  .vwap-box input[disabled]{ background:transparent; border:0; outline:0; font-weight:900; font-variant-numeric: tabular-nums; color:#0f172a; }
</style>

</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
  </div>
  
  <header>
    <div class="header-content">
      <div>
        <div class="title">Sistema Quant Pro</div>
        <div class="sub">AnÃ¡lise AvanÃ§ada de Contratos Futuros DOL com IA Multidimensional</div>
      </div>
      <div class="user-info">
        <div class="user-name" id="userName">Carregando...</div>
        <div class="status-badge">CONECTADO</div>
        <button class="logout-btn" id="logoutBtn">Sair</button>
      </div>
    </div>
  </header>

  <main>
    <div class="welcome-banner">
      <h3>Sistema IA AvanÃ§ado Inicializado com Sucesso!</h3>
      <p>Configure sua API ou use dados simulados para anÃ¡lise multidimensional com detecÃ§Ã£o de regime de mercado.</p>
    </div>
    
    <div class="main-grid">
      <div class="content-area">
        <section class="panel" id="proj-panel">
          <h2 class="section-title">ProjeÃ§Ãµes para Contratos Futuros</h2>
          <div class="toolbar">
            <button class="btn primary" id="btnFetchAPI">Dados via API</button>
            <button class="btn" id="btnFetch">Dados Simulados</button>
            <button class="btn" id="btnAnalyze">AnÃ¡lise AvanÃ§ada</button>
            <button class="btn ai" id="btnAIAnalysis">AnÃ¡lise IA Multidimensional</button>
            <span class="hint" id="dataStatus">aguardando dadosâ¦</span>
            <span class="api-status disconnected" id="apiStatus">API: Desconectado</span>
          </div>

          <div class="periods" id="forecastTabs">
            <div class="tab active" data-period="9">1Âª ProjeÃ§Ã£o (9P)</div>
            <div class="tab" data-period="18">2Âª ProjeÃ§Ã£o (18P)</div>
            <div class="tab" data-period="27">3Âª ProjeÃ§Ã£o (27P)</div>
          </div>

          <div class="cards" id="forecastCards">
            <div class="card up-card"><div class="label">ProjeÃ§Ã£o +1Ï</div><div class="value up" id="f_up1">--</div></div>
            <div class="card down-card"><div class="label">ProjeÃ§Ã£o -1Ï</div><div class="value down" id="f_dn1">--</div></div>
            <div class="card up-card"><div class="label">ProjeÃ§Ã£o +2Ï</div><div class="value up" id="f_up2">--</div></div>
            <div class="card down-card"><div class="label">ProjeÃ§Ã£o -2Ï</div><div class="value down" id="f_dn2">--</div></div>
          </div>

          <div class="sep"></div>

          <h2 class="section-title">MÃ¡ximas e MÃ­nimas Intraday</h2>
          <div class="inputs">
            <div class="input">
              <label for="frp">FRP - Forward Rate Premium (%)</label>
              <input id="frp" type="number" step="0.01" value="15.50" placeholder="Ex: 15.50 para Selic" />
              <div class="hint">Juros implÃ­citos para converter Spot â Futuro</div>
            </div>
            <div class="input">
              <label for="dataType">Tipo de Dados</label>
              <select id="dataType">
                <option value="spot">Spot USD/BRL (API)</option>
                <option value="future">Futuro DOL (Excel)</option>
              </select>
            </div>
            <div class="input">
              <label for="maturityDays">Vencimento (dias)</label>
              <input id="maturityDays" type="number" value="30" min="1" max="365" />
              <div class="hint">Para cÃ¡lculo preciso do FRP</div>
            </div>
          </div>

          <div class="inputs">
            <div class="input">
              <label for="exp9">Fator EXP 9P</label>
              <input id="exp9" type="number" step="0.1" value="2.718" />
            </div>
            <div class="input">
              <label for="exp18">Fator EXP 18P</label>
              <input id="exp18" type="number" step="0.1" value="2.718" />
            </div>
            <div class="input">
              <label for="exp27">Fator EXP 27P</label>
              <input id="exp27" type="number" step="0.1" value="2.718" />
            </div>
          </div>

          <div class="periods" id="intradayTabs">
            <div class="tab active" data-iperiod="9">1Âª ProjeÃ§Ã£o</div>
            <div class="tab" data-iperiod="18">2Âª ProjeÃ§Ã£o </div>
            <div class="tab" data-iperiod="27">3Âª ProjeÃ§Ã£o </div>
          </div>

          <div class="cards">
            <div class="card up-card"><div class="label">MÃ¡xima Intraday</div><div class="value up" id="i_max">--</div></div>
            <div class="card down-card"><div class="label">MÃ­nima Intraday</div><div class="value down" id="i_min">--</div></div>
            <div class="card neutral-card"><div class="label">Fechamento Base</div><div class="value" id="i_close">--</div></div>
            <div class="card neutral-card"><div class="label">Ï Retornos (%)</div><div class="value" id="i_sigma">--</div></div>
          </div>

          <div class="debug" id="debugInfo">
            Debug: aguardando cÃ¡lculos...
          </div>

          <div class="sep"></div>

          <h2 class="section-title">PossÃ­veis MÃ¡ximas e MÃ­nimas</h2>
          <div class="cards maxmin-grid">
            <div class="card up-card"><div class="label">MÃ¡xima 1P </div><div class="value up" id="max_9p">--</div></div>
            <div class="card up-card"><div class="label">MÃ¡xima 2P </div><div class="value up" id="max_18p">--</div></div>
            <div class="card up-card"><div class="label">MÃ¡xima 3P </div><div class="value up" id="max_27p">--</div></div>
            <div class="card down-card"><div class="label">MÃ­nima 1P </div><div class="value down" id="min_9p">--</div></div>
            <div class="card down-card"><div class="label">MÃ­nima 2P </div><div class="value down" id="min_18p">--</div></div>
            <div class="card down-card"><div class="label">MÃ­nima 3P </div><div class="value down" id="min_27p">--</div></div>
          </div>

          <div class="sep"></div>

          <h2 class="section-title">PreÃ§o Justo e JustÃ­ssimo do DÃ³lar</h2>
          
          <div class="fair-price-cards">
            <div class="card up-card"><div class="label">PreÃ§o Justo PPP</div><div class="value" id="fair_ppp">--</div></div>
            <div class="card up-card"><div class="label">PreÃ§o Justo UIP</div><div class="value" id="fair_uip">--</div></div>
            <div class="card neutral-card"><div class="label">PreÃ§o JustÃ­ssimo</div><div class="value" id="fair_combined">--</div></div>
            <div class="card down-card"><div class="label">Desvio do Justo (%)</div><div class="value" id="deviation_fair">--</div></div>
          </div>

          <div class="fair-price-cards">
            <div class="card neutral-card"><div class="label">Diferencial Juros</div><div class="value" id="interest_diff">--</div></div>
            <div class="card neutral-card"><div class="label">Diferencial InflaÃ§Ã£o</div><div class="value" id="inflation_diff">--</div></div>
            <div class="card neutral-card"><div class="label">Fator Risco Ajustado</div><div class="value" id="risk_factor">--</div></div>
            <div class="card neutral-card"><div class="label">TendÃªncia 30D</div><div class="value" id="trend_30d">--</div></div>
          </div>

          <div class="inputs">
            <div class="input">
              <label for="ppp_rate">Taxa PPP Base (R$)</label>
              <input id="ppp_rate" type="number" step="0.01" value="5.20" />
              <div class="hint">Paridade do Poder de Compra histÃ³rica</div>
            </div>
            <div class="input">
              <label for="inflation_br">InflaÃ§Ã£o Brasil (%aa)</label>
              <input id="inflation_br" type="number" step="0.1" value="4.5" />
              <div class="hint">IPCA acumulado 12 meses</div>
            </div>
            <div class="input">
              <label for="inflation_us">InflaÃ§Ã£o EUA (%aa)</label>
              <input id="inflation_us" type="number" step="0.1" value="5.2" />
              <div class="hint">CPI acumulado 12 meses</div>
            </div>
          </div>

          <div class="inputs">
            <div class="input">
              <label for="selic_rate">Taxa Selic (%aa)</label>
              <input id="selic_rate" type="number" step="0.25" value="15.50" />
            </div>
            <div class="input">
              <label for="fed_rate">Taxa Fed (%aa)</label>
              <input id="fed_rate" type="number" step="0.25" value="5.50" />
            </div>
            <div class="input">
              <label for="risk_premium">PrÃªmio de Risco (%)</label>
              <input id="risk_premium" type="number" step="0.1" value="2.5" />
              <div class="hint">Risco paÃ­s + volatilidade</div>
            </div>
          </div>

          <div class="sep"></div>

          <h2 class="section-title">Indicadores Adicionais</h2>
          <div class="cards">
            <div class="card neutral-card"><div class="label">Retorno Linear Atual</div><div class="value" id="ret_current">--</div></div>
            <div class="card neutral-card"><div class="label">Desvio 9P (%)</div><div class="value" id="std9">--</div></div>
            <div class="card neutral-card"><div class="label">Desvio 18P (%)</div><div class="value" id="std18">--</div></div>
            <div class="card neutral-card"><div class="label">Desvio 27P (%)</div><div class="value" id="std27">--</div></div>
            <div class="card neutral-card"><div class="label">Exp(Ï9) Factor</div><div class="value" id="exp_std9">--</div></div>
            <div class="card neutral-card"><div class="label">Exp(Ï18) Factor</div><div class="value" id="exp_std18">--</div></div>
            <div class="card neutral-card"><div class="label">Exp(Ï27) Factor</div><div class="value" id="exp_std27">--</div></div>
          </div>

        </section>

        <section class="panel ai-panel" id="ai-analysis-panel">
          <h2 class="section-title ai-title">AnÃ¡lise IA Multidimensional</h2>
          
          <!-- MÃ©tricas AvanÃ§adas -->
          <div class="advanced-metrics">
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="advancedConfidenceDisplay">--</div>
              <div class="metric-label-advanced">ConfianÃ§a Multi</div>
            </div>
            
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="marketRegimeDisplay">--</div>
              <div class="metric-label-advanced">Regime</div>
            </div>
            
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="confluenceDisplay">--</div>
              <div class="metric-label-advanced">ConfluÃªncia</div>
            </div>
            
            <div class="metric-card-advanced">
              <div class="metric-value-advanced" id="riskRewardDisplay">--</div>
              <div class="metric-label-advanced">Risk/Reward</div>
            </div>
          </div>
          
          <div class="ai-insights">
            <div class="insight-card">
              <div class="insight-title">SituaÃ§Ã£o Atual</div>
              <div class="insight-content" id="aiCurrentSituation">
                Execute 'AnÃ¡lise IA' para insights multidimensionais...
              </div>
            </div>
            
            <div class="opportunity-score">
              <div class="score-circle">
                <span class="score-value" id="opportunityScore">--</span>
                <span class="score-label">Score</span>
              </div>
            </div>
            
            <div class="insight-card">
              <div class="insight-title">EstratÃ©gia Operacional</div>
              <div class="insight-content" id="aiMainRecommendation">
                Aguardando anÃ¡lise de regime de mercado...
              </div>
            </div>
          </div>

          <div class="alerts-container" id="aiAlerts" style="display: none;">
            <!-- Alerts will be populated by JS -->
          </div>

          <div class="ai-narrative" id="aiNarrative" style="display: none;">
            <!-- Narrative analysis will be populated by JS -->
          </div>

          <div class="sep"></div>

          <h3 style="font-size: 14px; margin-bottom: 12px;">CenÃ¡rios ProbabilÃ­sticos (24h)</h3>
          <div class="scenario-bars" id="aiScenarios">
            <div class="scenario">
              <span class="scenario-label">Alta Forte (>+2%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Alta Moderada (+1%/+2%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Lateral (-1%/+1%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Baixa Moderada (-2%/-1%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
            <div class="scenario">
              <span class="scenario-label">Baixa Forte (<-2%)</span>
              <div class="probability-bar">
                <div class="bar-fill" style="width: 0%"></div>
                <span class="percentage">--%</span>
              </div>
            </div>
          </div>
          <div class="sep"></div>		  
		  <div class="panel" id="aiStrategyPanel">
			<div id="vwapCard" class="vwap-card">
				<div class="vwap-head">
					<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" style="opacity:.85">
						<path d="M3 13h2v-2H3v2zm4 0h14v-2H7v2zm0 6h14v-2H7v2zM3 5v2h2V5H3zm4 2h14V5H7v2z"></path>
					</svg>
					<span class="vwap-title">VWAP (D/S/M)</span>
					<span class="vwap-sub">opcional Â· auto da planilha</span>
				</div>
				<div class="vwap-grid">
					<label class="vwap-field"><span class="vwap-label">VWAP D</span><div class="vwap-box"><span class="vwap-chip">D</span><input id="vwapD" type="text" readonly disabled placeholder="â" /></div></label>
					<label class="vwap-field"><span class="vwap-label">VWAP S</span><div class="vwap-box"><span class="vwap-chip">S</span><input id="vwapS" type="text" readonly disabled placeholder="â" /></div></label>
					<label class="vwap-field"><span class="vwap-label">VWAP M</span><div class="vwap-box"><span class="vwap-chip">M</span><input id="vwapM" type="text" readonly disabled placeholder="â" /></div></label>
				</div>
				<div class="vwap-tips">Lemos as colunas <b>VWAP D</b>, <b>VWAP S</b>, <b>VWAP M</b> da Ãºltima linha da planilha.</div>
			</div>

			<h2 class="section-title">â¡ EstratÃ©gia Recomendada</h2>

			<div id="aiOperation" class="insight-card"></div>
			<div id="aiRisk" class="insight-card"></div>
			<div id="aiLevels" class="insight-card"></div>
		</div>
        </section>
      </div>

      <aside class="panel">
        <h2 class="section-title">ConfiguraÃ§Ã£o de APIs</h2>
        
        <!-- API Provider Selection -->
        <div class="api-config">
          <h3 style="font-size: 14px; margin-bottom: 12px;">Provedores de Dados:</h3>
          <div class="provider-grid">
            <div class="provider-card active" data-provider="alpha_vantage">
              <h4>Alpha Vantage</h4>
              <p><strong>RECOMENDADO</strong><br>25 calls/dia grÃ¡tis<br>USD/BRL disponÃ­vel</p>
            </div>
            <div class="provider-card" data-provider="yahoo_finance">
              <h4>Yahoo Finance</h4>
              <p>Gratuito (com limitaÃ§Ãµes)<br>Precisa de proxy CORS</p>
            </div>
            <div class="provider-card" data-provider="polygon">
              <h4>Polygon.io</h4>
              <p>5 calls/min grÃ¡tis<br>Dados profissionais</p>
            </div>
            <div class="provider-card" data-provider="tradier">
              <h4>Tradier</h4>
              <p>Sandbox gratuito<br>Live data premium</p>
            </div>
          </div>
        </div>

        <!-- API Configuration -->
        <div class="inputs" id="apiConfigInputs">
          <div class="input">
            <label for="apiKey">API Key Alpha Vantage</label>
            <input id="apiKey" type="password" placeholder="Cole sua chave aqui ou digite 'demo'" />
          </div>
          <div class="input">
            <label for="symbol">Par de Moedas</label>
            <input id="symbol" type="text" value="USD/BRL" placeholder="USD/BRL (fixo)" readonly style="background: #f8f9fa;" />
          </div>
          <div class="input">
            <label for="interval">Intervalo</label>
            <select id="interval">
              <option value="daily">DiÃ¡rio (Recomendado)</option>
              <option value="weekly">Semanal</option>
              <option value="monthly">Mensal</option>
            </select>
          </div>
        </div>

        <div class="api-info" style="margin: 12px 0; padding: 12px; background: linear-gradient(135deg, #f0fdf4, #dcfce7); border-radius: 8px;">
          <h4 style="color: #166534; margin-bottom: 8px;">Sistema FRP (Forward Rate Premium)</h4>
          <div style="font-size: 12px; line-height: 1.6; color: #374151;">
            <p><strong>Dados de Excel (DOL Futuro):</strong> JÃ¡ incorporam juros, usar "Futuro DOL"</p>
            <p><strong>Dados da API (Spot USD/BRL):</strong> Configurar FRP para converter</p>
            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; padding: 8px; margin-top: 8px; font-size: 11px;">
              ð¡ <strong>FRP Sugerido:</strong> Use ~13.75% (Selic atual) para conversÃ£o spotâfuturo
            </div>
          </div>
        </div>

        <div class="api-info" style="margin: 12px 0; padding: 12px; background: linear-gradient(135deg, #f0f9ff, #e0f2fe); border-radius: 8px;">
          <h4 style="color: #0369a1; margin-bottom: 8px;">ð§ SoluÃ§Ã£o para Problemas de CORS:</h4>
          <div style="font-size: 12px; line-height: 1.6; color: #374151;">
            <p><strong>Se der erro de "Resposta invÃ¡lida":</strong></p>
            <ol style="padding-left: 16px; margin: 8px 0;">
              <li>Use <code style="background: #f3f4f6; padding: 2px 4px; border-radius: 3px;">demo</code> como API Key</li>
              <li>Clique "ð Testar API" (vai funcionar em modo demo)</li>
              <li>Clique "ð¡ Dados via API" (carregarÃ¡ dados realÃ­sticos)</li>
            </ol>
            <p><strong>Para API Key real:</strong></p>
            <ol style="padding-left: 16px; margin: 8px 0;">
              <li><strong>Cadastre-se GRÃTIS:</strong> <a href="https://www.alphavantage.co/support/#api-key" target="_blank" style="color: #0369a1;">alphavantage.co/support/#api-key</a></li>
              <li><strong>Receba</strong> API key por email</li>
              <li><strong>Cole aqui</strong> e teste</li>
            </ol>
          </div>
          <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; padding: 8px; margin-top: 8px; font-size: 11px;">
            ð¡ <strong>IMPORTANTE:</strong> Mesmo com erro de CORS, o sistema funciona perfeitamente com dados demo realÃ­sticos!
          </div>
        </div>

        <div class="toolbar" style="margin-top: 16px;">
          <button class="btn success" id="btnTestAPI">ð Testar API</button>
          <button class="btn" id="btnSaveAPIConfig">ð¾ Salvar Config</button>
        </div>

        <div class="api-info">
          <strong>Provedor Ativo:</strong> <span id="activeProvider">Alpha Vantage</span><br>
          <strong>Status:</strong> <span id="connectionStatus">Desconectado</span><br>
          <strong>Ãltima AtualizaÃ§Ã£o:</strong> <span id="lastUpdate">Nunca</span><br>
          <strong>Dados DisponÃ­veis:</strong> <span id="dataCount">0</span> registros
        </div>

        <div class="sep"></div>

        <!-- Manual Data Input -->
        <h3 style="font-size: 14px; margin-bottom: 8px;">Dados Manuais (Backup)</h3>
        <div class="hint">Cole abaixo fechamentos (um por linha) se quiser testar manualmente:</div>
        <textarea id="manualData" rows="6" style="width:100%;margin-top:8px;" placeholder="5500.00&#10;5510.25&#10;5505.80&#10;..."></textarea>
        <div class="toolbar" style="margin-top:10px">
          <button class="btn" id="btnLoadManual">Carregar Fechamentos</button>
          <button class="btn" id="btnClear">Limpar</button>
        </div>

        <div class="sep"></div>
        
        <!-- Excel Import -->
        <div class="hint">Importar Fechamentos do Excel:</div>
        <div style="font-size:11px;color:var(--muted);margin:4px 0;">
          Aceita formatos: <br>
          â¢ Coluna Ãºnica com preÃ§os (A1: 5437, A2: 5485.5...)<br>
          â¢ Planilha completa (detecta coluna "Fechamento" automaticamente)
        </div>
        <input type="file" id="fileUpload" accept=".xlsx,.xls" />

        <div class="sep"></div>
        <div class="hint">Status:</div>
        <div class="muted" id="log">Pronto para uso - Configure uma API para dados em tempo real</div>
      </aside>
    </div>
  </main>

  <footer>Deivitti Almir - GÃªnesis Trading</footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
    class TradingSystemWithAI {
      constructor() {
        this.priceData = [];
        this.linearReturns = [];
        this.currentForecastP = 9;
        this.currentIntradayP = 9;
        this.apiConfig = {
          provider: 'alpha_vantage',
          apiKey: '',
          symbol: 'USDBRL=X',
          interval: '1d'
        };
        this.apiConnected = false;
        this.aiAnalysis = null;
        
        this.initUserSession();
        this.init();
      }
      
      initUserSession() {
        try {
          const userData = sessionStorage.getItem('currentUser');
          if (userData) {
            const user = JSON.parse(userData);
            const userNameElement = document.getElementById('userName');
            if (userNameElement) {
              userNameElement.textContent = user.name || 'UsuÃ¡rio';
            }
            
            if (user.system !== 'garch') {
              console.warn('UsuÃ¡rio nÃ£o tem acesso ao sistema GARCH');
              if (user.system === 'quant') {
                this.log('â ï¸ Redirecionando para Sistema QUANT...');
                setTimeout(() => {
                  window.location.href = 'dashboard-quant.html';
                }, 2000);
              }
            }
            
            console.log('UsuÃ¡rio logado:', user.name, 'Sistema:', user.system);
            this.log(`â Bem-vindo, ${user.name}! Sistema GARCH com IA inicializado.`);
            
          } else {
            console.warn('Nenhum usuÃ¡rio logado encontrado');
            this.log('â ï¸ SessÃ£o nÃ£o encontrada. Redirecionando...');
            setTimeout(() => {
              window.location.href = 'index.html';
            }, 3000);
          }
        } catch (error) {
          console.error('Erro ao carregar dados do usuÃ¡rio:', error);
          this.log('â Erro ao carregar sessÃ£o. Redirecionando...');
          setTimeout(() => {
            window.location.href = 'index.html';
          }, 3000);
        }
      }
      
      checkSessionValidity() {
        try {
          const userData = sessionStorage.getItem('currentUser');
          if (userData) {
            const user = JSON.parse(userData);
            const loginTime = user.loginTime || 0;
            const sessionTimeout = 4 * 60 * 60 * 1000;
            
            if (Date.now() - loginTime > sessionTimeout) {
              alert('Sua sessÃ£o expirou. FaÃ§a login novamente.');
              sessionStorage.removeItem('currentUser');
              window.location.href = 'index.html';
              return false;
            }
          } else {
            this.log('â ï¸ SessÃ£o perdida. Redirecionando para login...');
            setTimeout(() => {
              window.location.href = 'index.html';
            }, 2000);
            return false;
          }
          return true;
        } catch (error) {
          console.error('Erro ao verificar sessÃ£o:', error);
          return false;
        }
      }
      
      init() {
        this.loadAPIConfig();
        this.wireEventListeners();
        this.wireExpInputs();
        this.updateAPIInfo();
        this.updateDataTypeUI();
        this.initializeAI();
        
        setInterval(() => {
          this.checkSessionValidity();
        }, 5 * 60 * 1000);
      }
      
      // ========================================
      // NOVAS FUNÃÃES DE IA AVANÃADA
      // ========================================
      
      // 1. SCORE DE CONFIANÃA MULTIDIMENSIONAL
      calculateAdvancedConfidenceScore() {
        let totalScore = 0;
        let totalWeight = 0;
        
        // Componente GARCH (peso 30)
        const garchScore = this.calculateGARCHConfidenceComponent();
        totalScore += garchScore * 30;
        totalWeight += 30;
        
        // Componente PreÃ§o Justo (peso 25)
        const fairPriceScore = this.calculateFairPriceConfidenceComponent();
        totalScore += fairPriceScore * 25;
        totalWeight += 25;
        
        // Componente Volatilidade (peso 20)
        const volScore = this.calculateVolatilityConfidenceComponent();
        totalScore += volScore * 20;
        totalWeight += 20;
        
        // Componente Momentum (peso 15)
        const momentumScore = this.calculateMomentumConfidenceComponent();
        totalScore += momentumScore * 15;
        totalWeight += 15;
        
        // Componente ConfluÃªncia (peso 10)
        const confluenceScore = this.calculateConfluenceComponent();
        totalScore += confluenceScore * 10;
        totalWeight += 10;
        
        return Math.round(totalScore / totalWeight);
      }
      
      calculateGARCHConfidenceComponent() {
        const periods = [9, 18, 27];
        let consistency = 0;
        let validPeriods = 0;
        
        const currentPrice = this.lastClose();
        if (!isFinite(currentPrice)) return 30;
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          if (!isFinite(stdDev)) return;
          
          validPeriods++;
          const up1sigma = currentPrice * (1 + stdDev);
          const down1sigma = currentPrice * (1 - stdDev);
          
          // Maior pontuaÃ§Ã£o quando preÃ§o estÃ¡ prÃ³ximo das bandas
          if (currentPrice > up1sigma || currentPrice < down1sigma) {
            consistency += 80;
          } else {
            const distanceFromBands = Math.min(
              Math.abs(currentPrice - up1sigma) / currentPrice,
              Math.abs(currentPrice - down1sigma) / currentPrice
            );
            consistency += Math.max(20, 80 - (distanceFromBands * 1000));
          }
        });
        
        return validPeriods > 0 ? consistency / validPeriods : 30;
      }
      
      calculateFairPriceConfidenceComponent() {
        const fairAnalysis = this.analyzeSystemFairPrice();
        if (!fairAnalysis.valid) return 30;
        
        const deviation = fairAnalysis.deviationAbs;
        
        // Quanto maior o desvio, maior a confianÃ§a na direÃ§Ã£o
        if (deviation > 10) return 95;
        if (deviation > 8) return 85;
        if (deviation > 5) return 70;
        if (deviation > 3) return 50;
        if (deviation > 1) return 35;
        return 20;
      }
      
      calculateVolatilityConfidenceComponent() {
        const vol18 = this.calculateStdDevReturns(18) * 100;
        if (!isFinite(vol18)) return 50;
        
        // Volatilidade ideal entre 1.5% e 2.5%
        if (vol18 >= 1.5 && vol18 <= 2.5) return 90;
        if (vol18 < 1.0) return 60; // Muito baixa
        if (vol18 > 4.0) return 20; // Muito alta
        if (vol18 > 3.0) return 40;
        return 70;
      }
      
      calculateMomentumConfidenceComponent() {
        const mom9 = this.calculateMomentum(9);
        const mom18 = this.calculateMomentum(18);
        const mom27 = this.calculateMomentum(27);
        
        if (!isFinite(mom9) || !isFinite(mom18) || !isFinite(mom27)) return 40;
        
        // Momentum consistente em todas as janelas = alta confianÃ§a
        if ((mom9 > 0 && mom18 > 0 && mom27 > 0) || 
            (mom9 < 0 && mom18 < 0 && mom27 < 0)) {
          return 85;
        }
        
        // DivergÃªncias = menor confianÃ§a
        const directions = [mom9 > 0, mom18 > 0, mom27 > 0];
        const consistent = directions.filter(d => d === directions[0]).length;
        
        return Math.max(25, consistent * 30);
      }
      
      calculateMomentum(periods) {
        if (this.priceData.length < periods + 1) return NaN;
        
        const recent = this.priceData.slice(-periods);
        const older = this.priceData.slice(-(periods * 2), -periods);
        
        if (recent.length === 0 || older.length === 0) return NaN;
        
        const recentAvg = recent.reduce((sum, p) => sum + p, 0) / recent.length;
        const olderAvg = older.reduce((sum, p) => sum + p, 0) / older.length;
        
        return ((recentAvg - olderAvg) / olderAvg) * 100;
      }
      
      calculateConfluenceComponent() {
        const garchAnalysis = this.analyzeSystemGARCH();
        const fairAnalysis = this.analyzeSystemFairPrice();
        
        if (!fairAnalysis.valid || !garchAnalysis.p18) return 50;
        
        const currentPrice = this.lastClose();
        const fairPrice = fairAnalysis.fairPriceCombined;
        const garch18 = garchAnalysis.p18;
        
        let confluenceScore = 50;
        
        // ConfluÃªncia: preÃ§o alto + acima GARCH + acima justo
        if (currentPrice > fairPrice && currentPrice > garch18.up1sigma) {
          confluenceScore = 90;
        }
        // ConfluÃªncia: preÃ§o baixo + abaixo GARCH + abaixo justo  
        else if (currentPrice < fairPrice && currentPrice < garch18.down1sigma) {
          confluenceScore = 90;
        }
        // DivergÃªncia: sinais conflitantes
        else if ((currentPrice > fairPrice && currentPrice < garch18.down1sigma) ||
                 (currentPrice < fairPrice && currentPrice > garch18.up1sigma)) {
          confluenceScore = 25;
        }
        
        return confluenceScore;
      }
      
      // 2. DETECÃÃO DE REGIME DE MERCADO
      detectMarketRegime() {
        const fairAnalysis = this.analyzeSystemFairPrice();
        const volAnalysis = this.analyzeSystemVolatility();
        const garchAnalysis = this.analyzeSystemGARCH();
        
        if (!fairAnalysis.valid || !volAnalysis.p18 || !garchAnalysis.p18) {
          return {
            type: 'UNDEFINED',
            confidence: 'LOW',
            description: 'Dados insuficientes para determinar regime',
            probability: 50
          };
        }
        
        const deviation = fairAnalysis.deviationPercent;
        const vol18 = volAnalysis.p18.volatilityPercent;
        const currentPrice = this.lastClose();
        const garch18 = garchAnalysis.p18;
        
        // Regime de REVERSÃO Ã MÃDIA
        if (Math.abs(deviation) > 6 && vol18 < 3.0) {
          const direction = deviation > 0 ? 'BAIXISTA' : 'ALTISTA';
          const probability = Math.min(85, Math.abs(deviation) * 8 + (3.0 - vol18) * 10);
          
          return {
            type: 'MEAN_REVERSION',
            direction: direction,
            confidence: 'HIGH',
            description: `ReversÃ£o Ã  mÃ©dia ${direction.toLowerCase()} detectada. Desvio ${Math.abs(deviation).toFixed(1)}% com volatilidade controlada (${vol18.toFixed(2)}%).`,
            probability: Math.round(probability),
            expectedDuration: '2-5 pregÃµes'
          };
        }
        
        // Regime de ALTA VOLATILIDADE
        if (vol18 > 4.0) {
          return {
            type: 'HIGH_VOLATILITY',
            confidence: 'HIGH',
            description: `Volatilidade extrema (${vol18.toFixed(2)}%). Mercado imprevisÃ­vel, evitar trades direcionais.`,
            probability: 75,
            expectedDuration: 'Indefinido - aguardar normalizaÃ§Ã£o'
          };
        }
        
        // Regime de BREAKOUT
        if (garch18 && ((currentPrice > garch18.up2sigma) || (currentPrice < garch18.down2sigma))) {
          const direction = currentPrice > garch18.up2sigma ? 'ALTISTA' : 'BAIXISTA';
          return {
            type: 'BREAKOUT',
            direction: direction,
            confidence: 'MEDIUM',
            description: `PossÃ­vel breakout ${direction.toLowerCase()}. PreÃ§o alÃ©m de Â±2Ï GARCH.`,
            probability: 65,
            expectedDuration: '1-3 pregÃµes'
          };
        }
        
        // Regime LATERAL
        return {
          type: 'LATERAL',
          confidence: 'MEDIUM', 
          description: `Mercado em equilÃ­brio. Desvio: ${Math.abs(deviation).toFixed(1)}%, Vol: ${vol18.toFixed(2)}%.`,
          probability: 60,
          expectedDuration: 'Aguardar catalisador'
        };
      }
      
      // 3. ALERTAS CONTEXTUALIZADOS E HIERARQUIZADOS
      generateAdvancedAlerts() {
        const alerts = [];
        const regime = this.detectMarketRegime();
        const fairAnalysis = this.analyzeSystemFairPrice();
        const garchAnalysis = this.analyzeSystemGARCH();
        const volAnalysis = this.analyzeSystemVolatility();
        const confluence = this.calculateConfluenceComponent();
        
        // ALERTAS CRÃTICOS (AÃ§Ã£o imediata)
        if (regime.type === 'MEAN_REVERSION' && regime.confidence === 'HIGH' && confluence > 80) {
          alerts.push({
            level: 'CRITICAL',
            type: 'success',
            icon: 'ð¨',
            title: 'OPORTUNIDADE DE ALTA PROBABILIDADE',
            message: `${regime.description} ConfluÃªncia tÃ©cnica: ${confluence}%. AÃÃO RECOMENDADA: ${regime.direction === 'BAIXISTA' ? 'VENDA' : 'COMPRA'} direcional.`,
            action: 'Considerar entrada imediata',
            confidence: regime.probability
          });
        }
        
        if (volAnalysis.p18 && volAnalysis.p18.volatilityPercent > 4.5) {
          alerts.push({
            level: 'CRITICAL',
            type: 'warning',
            icon: 'â ï¸',
            title: 'VOLATILIDADE EXTREMA',
            message: `Volatilidade em ${volAnalysis.p18.volatilityPercent.toFixed(2)}% - ZONA PERIGOSA. Evitar novas posiÃ§Ãµes atÃ© normalizaÃ§Ã£o.`,
            action: 'Reduzir exposiÃ§Ã£o imediatamente',
            confidence: 90
          });
        }
        
        // ALERTAS IMPORTANTES (AtenÃ§Ã£o redobrada)
        if (garchAnalysis.p18) {
          const currentPrice = this.lastClose();
          if (currentPrice > garchAnalysis.p18.up2sigma) {
            alerts.push({
              level: 'IMPORTANT',
              type: 'warning',
              icon: 'ð',
              title: 'SOBRECOMPRA ESTATÃSTICA',
              message: `PreÃ§o ${((currentPrice/garchAnalysis.p18.up2sigma - 1) * 100).toFixed(1)}% acima de +2Ï GARCH (${this.fmt(garchAnalysis.p18.up2sigma)}). PressÃ£o de venda esperada.`,
              action: 'Monitorar reversÃ£o',
              confidence: 70
            });
          } else if (currentPrice < garchAnalysis.p18.down2sigma) {
            alerts.push({
              level: 'IMPORTANT', 
              type: 'info',
              icon: 'ð',
              title: 'SOBREVENDA ESTATÃSTICA',
              message: `PreÃ§o ${((1 - currentPrice/garchAnalysis.p18.down2sigma) * 100).toFixed(1)}% abaixo de -2Ï GARCH (${this.fmt(garchAnalysis.p18.down2sigma)}). PressÃ£o de compra esperada.`,
              action: 'Monitorar recuperaÃ§Ã£o',
              confidence: 70
            });
          }
        }
        
        if (fairAnalysis.valid && fairAnalysis.deviationAbs > 8) {
          alerts.push({
            level: 'IMPORTANT',
            type: fairAnalysis.deviationPercent > 0 ? 'warning' : 'info',
            icon: fairAnalysis.deviationPercent > 0 ? 'ð°' : 'ð¥',
            title: fairAnalysis.deviationPercent > 0 ? 'SOBREVALORIZAÃÃO SEVERA' : 'SUBVALORIZAÃÃO SEVERA',
            message: `Desvio de ${fairAnalysis.deviationAbs.toFixed(1)}% do preÃ§o justÃ­ssimo (${this.fmt(fairAnalysis.fairPriceCombined)}). ${fairAnalysis.severityLevel} probabilidade de reversÃ£o.`,
            action: `Preparar ${fairAnalysis.deviationPercent > 0 ? 'venda' : 'compra'}`,
            confidence: Math.min(85, fairAnalysis.deviationAbs * 8)
          });
        }
        
        // ALERTAS INFORMATIVOS
        if (confluence > 75) {
          alerts.push({
            level: 'INFO',
            type: 'success',
            icon: 'â',
            title: 'CONFLUÃNCIA TÃCNICA FORTE',
            message: `MÃºltiplos indicadores apontam mesma direÃ§Ã£o (${confluence}% confluÃªncia). Sinal consistente.`,
            action: 'Considerar aumento de posiÃ§Ã£o',
            confidence: confluence
          });
        } else if (confluence < 40) {
          alerts.push({
            level: 'INFO',
            type: 'info',
            icon: 'ð¤',
            title: 'SINAIS CONFLITANTES',
            message: `Indicadores divergindo (${confluence}% confluÃªncia). Aguardar definiÃ§Ã£o de direÃ§Ã£o.`,
            action: 'Aguardar confirmaÃ§Ã£o',
            confidence: 100 - confluence
          });
        }
        
        // Ordenar por prioridade
        const priority = { 'CRITICAL': 3, 'IMPORTANT': 2, 'INFO': 1 };
        alerts.sort((a, b) => priority[b.level] - priority[a.level] || b.confidence - a.confidence);
        
        return alerts.slice(0, 5); // MÃ¡ximo 5 alertas
      }
      
      // 4. ESTRATÃGIA OPERACIONAL ESPECÃFICA
      generateTradingStrategy() {
        const regime = this.detectMarketRegime();
        const fairAnalysis = this.analyzeSystemFairPrice();
        const garchAnalysis = this.analyzeSystemGARCH();
        const intradayAnalysis = this.analyzeSystemIntraday();
        const confidence = this.calculateAdvancedConfidenceScore();
        
        if (!fairAnalysis.valid || !garchAnalysis.p18 || !intradayAnalysis.p18) {
          return {
            recommendation: 'AGUARDAR',
            reason: 'Dados insuficientes para estratÃ©gia operacional',
            confidence: 30
          };
        }
        
        const currentPrice = this.lastClose();
        const garch18 = garchAnalysis.p18;
        const intraday18 = intradayAnalysis.p18;
        const vol18 = this.analyzeSystemVolatility().p18?.volatilityPercent || 2.0;
        
        let strategy = {
          recommendation: 'MONITORAR',
          direction: null,
          entryZone: { min: 0, max: 0 },
          target: 0,
          stopLoss: 0,
          positionSize: 'NORMAL',
          timeframe: '1-3 pregÃµes',
          confidence: confidence,
          riskReward: 0
        };
        
        // ESTRATÃGIA PARA REVERSÃO Ã MÃDIA
        if (regime.type === 'MEAN_REVERSION' && confidence > 70) {
          if (regime.direction === 'BAIXISTA') {
            // Entrada de VENDA
            strategy.recommendation = 'VENDA DIRECIONAL';
            strategy.direction = 'SELL';
            strategy.entryZone = { 
              min: Math.max(currentPrice * 0.998, garch18.up1sigma * 0.999),
              max: Math.min(currentPrice * 1.005, garch18.up2sigma)
            };
            strategy.target = Math.max(
              fairAnalysis.fairPriceCombined * 1.02,
              intraday18.minIntraday * 1.01
            );
            strategy.stopLoss = Math.min(
              currentPrice * 1.015,
              garch18.up2sigma * 1.005
            );
            
          } else {
            // Entrada de COMPRA
            strategy.recommendation = 'COMPRA DIRECIONAL';
            strategy.direction = 'BUY';
            strategy.entryZone = {
              min: Math.max(currentPrice * 0.995, garch18.down2sigma),
              max: Math.min(currentPrice * 1.002, garch18.down1sigma * 1.001)
            };
            strategy.target = Math.min(
              fairAnalysis.fairPriceCombined * 0.98,
              intraday18.maxIntraday * 0.99
            );
            strategy.stopLoss = Math.max(
              currentPrice * 0.985,
              garch18.down2sigma * 0.995
            );
          }
          
          strategy.timeframe = '2-5 pregÃµes';
        }
        
        // AJUSTE DE TAMANHO DE POSIÃÃO BASEADO EM VOLATILIDADE
        if (vol18 > 3.0) {
          strategy.positionSize = 'REDUZIDA (50-70%)';
        } else if (vol18 < 1.5 && confidence > 80) {
          strategy.positionSize = 'AUMENTADA (120-150%)';
        } else if (confidence > 85) {
          strategy.positionSize = 'NORMAL+ (110%)';
        }
        
        // CÃLCULO RISK/REWARD
        if (strategy.target > 0 && strategy.stopLoss > 0 && currentPrice > 0) {
          const potentialGain = Math.abs(strategy.target - currentPrice) / currentPrice;
          const potentialLoss = Math.abs(strategy.stopLoss - currentPrice) / currentPrice;
          strategy.riskReward = potentialLoss > 0 ? potentialGain / potentialLoss : 0;
        }
        
        return strategy;
      }
		renderStrategyPanel() {
		const strategy = this.generateTradingStrategy();
		const operationDiv = document.getElementById("aiOperation");
		const riskDiv = document.getElementById("aiRisk");
		const levelsDiv = document.getElementById("aiLevels");

		if (!operationDiv || !riskDiv || !levelsDiv) return;

  // 1. OperaÃ§Ã£o sugerida
  operationDiv.innerHTML = `
    <strong>OPERAÃÃO SUGERIDA</strong><br>
    ${strategy.recommendation}<br>
    <em>Entrada: ${strategy.entryZone.min.toFixed(2)} â ${strategy.entryZone.max.toFixed(2)}</em><br>
    ð¯ Meta: ${strategy.target.toFixed(2)}<br>
    ð Stop Loss: ${strategy.stopLoss.toFixed(2)}<br>
    â³ Prazo: ${strategy.timeframe}<br>
    ð ConfianÃ§a: ${strategy.confidence}%
  `;

  // 2. GestÃ£o de Risco
  riskDiv.innerHTML = `
    <strong>GESTÃO DE RISCO</strong><br>
    CenÃ¡rio adverso: rompimento pode levar a ${ (strategy.stopLoss * 1.01).toFixed(2) }<br>
    Gatilho de saÃ­da: Volatilidade > 3.5% ou perda de confluÃªncia<br>
    Hedge sugerido: Put protection se exposiÃ§Ã£o > R$ 100k
  `;

  // 3. Suporte e ResistÃªncia
  const garch = this.analyzeSystemGARCH();
  if (garch.p18) {
    levelsDiv.innerHTML = `
      <strong>NÃVEIS DE DECISÃO</strong><br>
      ResistÃªncia forte: ${garch.p18.up1sigma.toFixed(2)}<br>
      Suporte forte: ${garch.p18.down1sigma.toFixed(2)}
    `;
  }
}

      
      // FUNÃÃES AUXILIARES PARA AS MELHORIAS
      determineSignalTypeFromStrategy(strategy) {
        if (strategy.recommendation.includes('VENDA')) return 'sell';
        if (strategy.recommendation.includes('COMPRA')) return 'buy';
        if (strategy.recommendation.includes('AGUARDAR')) return 'wait';
        return 'neutral';
      }
      
      adjustScenariosForRegime(baseScenarios, regime) {
        let scenarios = { ...baseScenarios };
        
        if (regime.type === 'MEAN_REVERSION') {
          if (regime.direction === 'BAIXISTA') {
            scenarios.strongDown = Math.min(40, scenarios.strongDown + 20);
            scenarios.moderateDown = Math.min(35, scenarios.moderateDown + 15);
            scenarios.strongUp = Math.max(5, scenarios.strongUp - 15);
            scenarios.lateral = Math.max(10, scenarios.lateral - 20);
          } else if (regime.direction === 'ALTISTA') {
            scenarios.strongUp = Math.min(40, scenarios.strongUp + 20);
            scenarios.moderateUp = Math.min(35, scenarios.moderateUp + 15);
            scenarios.strongDown = Math.max(5, scenarios.strongDown - 15);
            scenarios.lateral = Math.max(10, scenarios.lateral - 20);
          }
        } else if (regime.type === 'HIGH_VOLATILITY') {
          scenarios.lateral = Math.max(50, scenarios.lateral + 20);
          scenarios.strongUp = Math.max(5, scenarios.strongUp - 10);
          scenarios.strongDown = Math.max(5, scenarios.strongDown - 10);
        }
        
        return scenarios;
      }
      
      generateEnhancedNarrativeWithRegime(regime, strategy, confidence) {
        const currentPrice = this.lastClose();
        const fairAnalysis = this.analyzeSystemFairPrice();
        
        return `
          <h4>ANÃLISE GARCH-IA AVANÃADA - ${new Date().toLocaleDateString('pt-BR')}</h4>
          
          <p><strong>REGIME IDENTIFICADO: ${regime.type}</strong><br>
          ${regime.description} Probabilidade: ${regime.probability}%</p>
          
          <p><strong>ESTRATÃGIA OPERACIONAL:</strong><br>
          ${strategy.recommendation} | ConfianÃ§a Multidimensional: ${confidence}%<br>
          ${strategy.direction ? `Zona de Entrada: ${this.fmt(strategy.entryZone.min)} - ${this.fmt(strategy.entryZone.max)}` : ''}<br>
          ${strategy.target > 0 ? `Meta PrimÃ¡ria: ${this.fmt(strategy.target)} | Stop Loss: ${this.fmt(strategy.stopLoss)}` : ''}<br>
          ${strategy.riskReward > 0 ? `Risk/Reward: 1:${strategy.riskReward.toFixed(1)} | Tamanho: ${strategy.positionSize}` : ''}</p>
          
          <p><strong>CONFLUÃNCIA TÃCNICA:</strong><br>
          PreÃ§oJusto: ${fairAnalysis.valid ? this.fmt(fairAnalysis.fairPriceCombined) : 'N/D'} | 
          Desvio: ${fairAnalysis.valid ? fairAnalysis.deviationPercent.toFixed(1) + '%' : 'N/D'}<br>
          ConfluÃªncia: ${this.calculateConfluenceComponent()}% | 
          Timeframe: ${strategy.timeframe}</p>
          
          <p><strong>GESTÃO DE RISCO:</strong><br>
          ${confidence > 80 ? 'â ALTA confianÃ§a - OperaÃ§Ã£o recomendada' : 
            confidence > 60 ? 'â ï¸ MÃDIA confianÃ§a - Aguardar confirmaÃ§Ã£o' : 
            'â BAIXA confianÃ§a - Evitar trades direcionais'}</p>
        `;
      }
      
      updateAdvancedMetricsDisplay() {
        if (!this.aiAnalysis) {
          document.getElementById('advancedConfidenceDisplay').textContent = '--';
          document.getElementById('marketRegimeDisplay').textContent = '--';
          document.getElementById('confluenceDisplay').textContent = '--';
          document.getElementById('riskRewardDisplay').textContent = '--';
          return;
        }
        
        // Atualizar displays das mÃ©tricas avanÃ§adas
        const advancedConfidence = this.calculateAdvancedConfidenceScore();
        const regime = this.detectMarketRegime();
        const confluence = this.calculateConfluenceComponent();
        const strategy = this.generateTradingStrategy();
        
        document.getElementById('advancedConfidenceDisplay').textContent = advancedConfidence + '%';
        document.getElementById('marketRegimeDisplay').textContent = regime.type;
        document.getElementById('confluenceDisplay').textContent = confluence + '%';
        document.getElementById('riskRewardDisplay').textContent = strategy.riskReward > 0 ? 
          '1:' + strategy.riskReward.toFixed(1) : '--';
      }
      
      // ========================================
      // FIM DAS NOVAS FUNÃÃES DE IA AVANÃADA  
      // ========================================
      
      // FunÃ§Ã£o para determinar o tipo de sinal baseado na recomendaÃ§Ã£o
      determineSignalType(recommendation) {
        if (!recommendation || typeof recommendation !== 'string') {
          return 'neutral';
        }
        
        const recText = recommendation.toLowerCase();
        
        // Sinais de COMPRA (Verde)
        if (recText.includes('compra') || 
            recText.includes('comprar') ||
            recText.includes('subvalorizada') ||
            recText.includes('atenÃ§Ã£o para compras') ||
            recText.includes('forte recomendaÃ§Ã£o de compra') ||
            recText.includes('recomendaÃ§Ã£o de compra') ||
            recText.includes('oportunidade de compra')) {
          return 'buy';
        }
        
        // Sinais de VENDA (Vermelho)
        if (recText.includes('venda') || 
            recText.includes('vender') ||
            recText.includes('sobrevalorizada') ||
            recText.includes('atenÃ§Ã£o para vendas') ||
            recText.includes('forte recomendaÃ§Ã£o de venda') ||
            recText.includes('recomendaÃ§Ã£o de venda') ||
            recText.includes('oportunidade de venda')) {
          return 'sell';
        }
        
        // Sinais de AGUARDAR (Laranja)
        if (recText.includes('aguardar') || 
            recText.includes('aguarde') ||
            recText.includes('volatilidade extrema') ||
            recText.includes('evitar trades') ||
            recText.includes('aguardar reduÃ§Ã£o') ||
            recText.includes('aguardar normalizaÃ§Ã£o')) {
          return 'wait';
        }
        
        // Neutro/Monitorar (Azul) - padrÃ£o
        return 'neutral';
      }
      
      // FunÃ§Ã£o para atualizar a cor do cÃ­rculo de score
      updateScoreCircleColor(signalType) {
        const scoreCircle = document.querySelector('.score-circle');
        if (!scoreCircle) {
          console.warn('Score circle element not found');
          return;
        }
        
        // Remove todas as classes de cor existentes
        scoreCircle.classList.remove('buy-signal', 'sell-signal', 'neutral-signal', 'wait-signal');
        
        // Adiciona a classe apropriada baseada no sinal
        switch(signalType) {
          case 'buy':
            scoreCircle.classList.add('buy-signal');
            console.log('Score circle: BUY signal (green)');
            break;
          case 'sell':
            scoreCircle.classList.add('sell-signal');
            console.log('Score circle: SELL signal (red)');
            break;
          case 'wait':
            scoreCircle.classList.add('wait-signal');
            console.log('Score circle: WAIT signal (orange)');
            break;
          case 'neutral':
          default:
            scoreCircle.classList.add('neutral-signal');
            console.log('Score circle: NEUTRAL signal (blue)');
            break;
        }
      }
      
      initializeAI() {
        // Initialize AI analysis display
        this.updateAIDisplay();
      }
      
      wireEventListeners() {
        document.getElementById('btnFetch').addEventListener('click', () => this.fetchSimulatedData());
        document.getElementById('btnFetchAPI').addEventListener('click', () => this.fetchAPIData());
        document.getElementById('btnAnalyze').addEventListener('click', () => this.analyze());
		document.getElementById('btnAIAnalysis').addEventListener('click', () => {
			this.performAIAnalysis();
			this.renderStrategyPanel();
		});        
		document.getElementById('btnLoadManual').addEventListener('click', () => this.loadManualData());
        document.getElementById('btnClear').addEventListener('click', () => this.clearData());
        document.getElementById('logoutBtn').addEventListener('click', () => this.logout());
        
        document.getElementById('btnTestAPI').addEventListener('click', () => this.testAPIConnection());
        document.getElementById('btnSaveAPIConfig').addEventListener('click', () => this.saveAPIConfig());
        
        document.querySelectorAll('.provider-card').forEach(card => {
          card.addEventListener('click', () => {
            const provider = card.dataset.provider;
            this.selectProvider(provider);
          });
        });
        
        document.querySelectorAll('#forecastTabs .tab').forEach(tab => {
          tab.addEventListener('click', () => {
            const period = parseInt(tab.dataset.period);
            this.switchForecastPeriod(period);
          });
        });
        
        document.querySelectorAll('#intradayTabs .tab').forEach(tab => {
          tab.addEventListener('click', () => {
            const period = parseInt(tab.dataset.iperiod);
            this.switchIntradayPeriod(period);
          });
        });
        
        document.getElementById('fileUpload').addEventListener('change', (e) => this.handleFileUpload(e));
        
        ['apiKey', 'symbol', 'interval'].forEach(id => {
          document.getElementById(id).addEventListener('input', () => {
            this.updateAPIConfigFromInputs();
          });
        });
      }
      
      wireExpInputs() {
        ['exp9', 'exp18', 'exp27', 'frp', 'maturityDays'].forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener('input', () => {
              this.calculateIntradayExtremes(this.currentIntradayP);
              this.updateExtras();
            });
          }
        });
        
        ['ppp_rate', 'inflation_br', 'inflation_us', 'selic_rate', 'fed_rate', 'risk_premium'].forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener('input', () => {
              this.calculateFairPrices();
            });
          }
        });
        
        const dataTypeSelect = document.getElementById('dataType');
        if (dataTypeSelect) {
          dataTypeSelect.addEventListener('change', () => {
            this.updateDataTypeUI();
            this.refreshAll();
          });
        }
      }
      
      // AI Analysis System - VERSÃO MELHORADA
      async performAIAnalysis() {
        if (!this.priceData.length) {
          this.log("Carregue dados primeiro para anÃ¡lise com IA");
          return;
        }
        
        this.showLoading();
        this.log("Executando anÃ¡lise inteligente multidimensional...");
        
        try {
          // Simulate AI processing time
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          // AnÃ¡lise original + melhorias
          this.aiAnalysis = this.generateAIAnalysis();
          
          // NOVA: Adicionar mÃ©tricas avanÃ§adas
          this.aiAnalysis.advancedConfidence = this.calculateAdvancedConfidenceScore();
          this.aiAnalysis.marketRegime = this.detectMarketRegime();
          this.aiAnalysis.tradingStrategy = this.generateTradingStrategy();
          this.aiAnalysis.advancedAlerts = this.generateAdvancedAlerts();
          
          this.updateAIDisplay();
          
          this.log(`â AnÃ¡lise IA avanÃ§ada concluÃ­da! Regime: ${this.aiAnalysis.marketRegime.type} | ConfianÃ§a: ${this.aiAnalysis.advancedConfidence}%`);
          
        } catch (error) {
          this.log("â Erro na anÃ¡lise IA: " + error.message);
        } finally {
          this.hideLoading();
        }
      }
      
      // VERSÃO MELHORADA da funÃ§Ã£o updateAIDisplay()
      updateAIDisplay() {
        if (!this.aiAnalysis) {
          document.getElementById('aiCurrentSituation').textContent = "Execute 'AnÃ¡lise IA' para insights multidimensionais...";
          document.getElementById('aiMainRecommendation').textContent = "Aguardando anÃ¡lise de regime de mercado...";
          document.getElementById('opportunityScore').textContent = "--";
          this.updateScoreCircleColor('neutral');
          this.updateAdvancedMetricsDisplay();
          return;
        }
        
        // Calcular mÃ©tricas avanÃ§adas
        const advancedConfidence = this.calculateAdvancedConfidenceScore();
        const regime = this.detectMarketRegime();
        const advancedAlerts = this.generateAdvancedAlerts();
        const strategy = this.generateTradingStrategy();
        
        // Update main insights com dados mais ricos
        const enhancedSituation = `${this.aiAnalysis.currentSituation} | Regime: ${regime.type} (${regime.probability}%) | ConfianÃ§a: ${advancedConfidence}%`;
        document.getElementById('aiCurrentSituation').textContent = enhancedSituation;
        
        // RecomendaÃ§Ã£o estratÃ©gica melhorada
        let enhancedRecommendation = strategy.recommendation;
        if (strategy.direction) {
          enhancedRecommendation += ` | Entrada: ${this.fmt(strategy.entryZone.min)}-${this.fmt(strategy.entryZone.max)}`;
          enhancedRecommendation += ` | Meta: ${this.fmt(strategy.target)} | Stop: ${this.fmt(strategy.stopLoss)}`;
          enhancedRecommendation += ` | R/R: ${strategy.riskReward.toFixed(1)}x`;
        }
        document.getElementById('aiMainRecommendation').textContent = enhancedRecommendation;
        
        // Score com base na confianÃ§a avanÃ§ada
        document.getElementById('opportunityScore').textContent = advancedConfidence;
        
        // Cor do cÃ­rculo baseada na estratÃ©gia
        const signalType = this.determineSignalTypeFromStrategy(strategy);
        this.updateScoreCircleColor(signalType);
        
        // Update alerts com sistema avanÃ§ado
        const alertsContainer = document.getElementById('aiAlerts');
        if (advancedAlerts && advancedAlerts.length > 0) {
          alertsContainer.innerHTML = '';
          advancedAlerts.forEach(alert => {
            const alertElement = document.createElement('div');
            alertElement.className = `alert-item ${alert.type}`;
            alertElement.innerHTML = `
              <strong>${alert.icon} ${alert.title}</strong>
              ${alert.message}
              <em>AÃ§Ã£o: ${alert.action} (ConfianÃ§a: ${alert.confidence}%)</em>
            `;
            alertsContainer.appendChild(alertElement);
          });
          alertsContainer.style.display = 'grid';
        } else {
          alertsContainer.style.display = 'none';
        }
        
        // Update scenarios com probabilidades condicionais
        if (this.aiAnalysis.scenarios) {
          // Ajustar cenÃ¡rios baseado no regime detectado
          const adjustedScenarios = this.adjustScenariosForRegime(this.aiAnalysis.scenarios, regime);
          
          const scenarios = document.querySelectorAll('#aiScenarios .scenario');
          const scenarioValues = [
            adjustedScenarios.strongUp,
            adjustedScenarios.moderateUp, 
            adjustedScenarios.lateral,
            adjustedScenarios.moderateDown,
            adjustedScenarios.strongDown
          ];
          
          scenarios.forEach((scenario, index) => {
            const barFill = scenario.querySelector('.bar-fill');
            const percentage = scenario.querySelector('.percentage');
            const value = scenarioValues[index] || 0;
            
            if (barFill && percentage) {
              barFill.style.width = `${value}%`;
              percentage.textContent = `${value}%`;
            }
          });
        }
        
        // Enhanced narrative com regime e estratÃ©gia
        const narrativeContainer = document.getElementById('aiNarrative');
        if (narrativeContainer) {
          const enhancedNarrative = this.generateEnhancedNarrativeWithRegime(regime, strategy, advancedConfidence);
          narrativeContainer.innerHTML = enhancedNarrative;
          narrativeContainer.style.display = 'block';
        }
        
        // Atualizar mÃ©tricas avanÃ§adas
        this.updateAdvancedMetricsDisplay();
      }
      
      // SUBSTITUA APENAS ESTAS FUNÃÃES NO SEU SISTEMA ORIGINAL
      // Mantenha todo o resto igual, apenas cole estas funÃ§Ãµes sobre as existentes

      // Nova anÃ¡lise de IA que usa os cÃ¡lculos reais do seu sistema
      generateAIAnalysis() {
        const currentPrice = this.lastClose();
        const garchAnalysis = this.analyzeSystemGARCH();
        const intradayAnalysis = this.analyzeSystemIntraday();
        const fairPriceAnalysis = this.analyzeSystemFairPrice();
        const volatilityAnalysis = this.analyzeSystemVolatility();
        
        const analysis = {
          opportunityScore: this.calculateEnhancedOpportunityScore(garchAnalysis, fairPriceAnalysis, volatilityAnalysis),
          currentSituation: this.generateEnhancedSituation(currentPrice, garchAnalysis, fairPriceAnalysis),
          mainRecommendation: this.generateEnhancedRecommendation(garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis),
          alerts: this.generateEnhancedAlerts(garchAnalysis, fairPriceAnalysis, volatilityAnalysis),
          scenarios: this.calculateEnhancedScenarios(garchAnalysis, fairPriceAnalysis),
          narrative: this.generateEnhancedNarrative(currentPrice, garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis)
        };
        
        return analysis;
      }
      
      // AnÃ¡lise GARCH usando os cÃ¡lculos reais do sistema
      analyzeSystemGARCH() {
        const currentPrice = this.lastClose();
        const periods = [9, 18, 27];
        const results = {};
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          if (isNaN(stdDev)) return;
          
          results[`p${period}`] = {
            stdDev: stdDev,
            stdDevPercent: stdDev * 100,
            up1sigma: currentPrice * (1 + stdDev),
            down1sigma: currentPrice * (1 - stdDev),
            up2sigma: currentPrice * (1 + 2 * stdDev),
            down2sigma: currentPrice * (1 - 2 * stdDev),
            currentInRange1: currentPrice >= (currentPrice * (1 - stdDev)) && currentPrice <= (currentPrice * (1 + stdDev)),
            distanceFromMean: Math.abs((currentPrice - currentPrice) / (currentPrice * stdDev))
          };
        });
        
        return results;
      }
      
      // AnÃ¡lise Intraday usando fatores EXP do sistema
      analyzeSystemIntraday() {
        const currentPrice = this.lastClose();
        const periods = [9, 18, 27];
        const results = {};
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          const expFactor = this.getExpFor(period);
          
          if (isNaN(stdDev)) return;
          
          const expStdDev = Math.pow(expFactor, stdDev);
          const maxIntraday = currentPrice * expStdDev;
          const minIntraday = currentPrice / expStdDev;
          
          results[`p${period}`] = {
            expFactor: expFactor,
            expStdDev: expStdDev,
            maxIntraday: maxIntraday,
            minIntraday: minIntraday,
            range: maxIntraday - minIntraday,
            rangePercent: ((maxIntraday - minIntraday) / currentPrice) * 100,
            potentialGain: ((maxIntraday - currentPrice) / currentPrice) * 100,
            potentialLoss: ((currentPrice - minIntraday) / currentPrice) * 100
          };
        });
        
        return results;
      }
      
      // AnÃ¡lise de PreÃ§o Justo usando fÃ³rmulas PPP/UIP do sistema
      analyzeSystemFairPrice() {
        const currentPrice = this.lastClose();
        if (!isFinite(currentPrice) || currentPrice <= 0) {
          return { valid: false };
        }
        
        // Usar os valores dos inputs do sistema
        let pppRate = parseFloat(document.getElementById('ppp_rate')?.value || 5.30);
        const inflationBr = parseFloat(document.getElementById('inflation_br')?.value || 4.5) / 100;
        const inflationUs = parseFloat(document.getElementById('inflation_us')?.value || 3.2) / 100;
        const selicRate = parseFloat(document.getElementById('selic_rate')?.value || 13.75) / 100;
        const fedRate = parseFloat(document.getElementById('fed_rate')?.value || 5.50) / 100;
        const riskPremium = parseFloat(document.getElementById('risk_premium')?.value || 2.5) / 100;

        // Ajuste de escala (igual ao sistema original)
        if (currentPrice > 100) {
          pppRate = pppRate * 1000;
        }

        // CÃ¡lculos PPP e UIP (igual ao sistema original)
        const inflationDifferential = inflationBr - inflationUs;
        const fairPricePPP = pppRate * ((1 + inflationBr) / (1 + inflationUs));

        const interestDifferential = selicRate - fedRate;
        const netInterestDifferential = interestDifferential - riskPremium;
        const uipAdjustmentFactor = 1 + (netInterestDifferential * 0.15);
        const fairPriceUIP = currentPrice * uipAdjustmentFactor;

        // Limites UIP (igual ao sistema original)
        const maxUIPDeviation = 0.20;
        const upperBoundUIP = currentPrice * (1 + maxUIPDeviation);
        const lowerBoundUIP = currentPrice * (1 - maxUIPDeviation);
        const boundedFairPriceUIP = Math.max(lowerBoundUIP, Math.min(upperBoundUIP, fairPriceUIP));

        // PreÃ§o combinado (igual ao sistema original)
        const weightPPP = 0.4;
        const weightUIP = 0.6;
        const fairPriceCombined = (fairPricePPP * weightPPP) + (boundedFairPriceUIP * weightUIP);

        // Limite total (igual ao sistema original)
        const maxTotalDeviation = 0.25;
        const upperBound = currentPrice * (1 + maxTotalDeviation);
        const lowerBound = currentPrice * (1 - maxTotalDeviation);
        const finalFairPrice = Math.max(lowerBound, Math.min(upperBound, fairPriceCombined));

        const deviationPercent = ((currentPrice - finalFairPrice) / finalFairPrice) * 100;
        
        return {
          valid: true,
          currentPrice: currentPrice,
          fairPricePPP: fairPricePPP,
          fairPriceUIP: boundedFairPriceUIP,
          fairPriceCombined: finalFairPrice,
          deviationPercent: deviationPercent,
          deviationAbs: Math.abs(deviationPercent),
          isOvervalued: deviationPercent > 5,
          isUndervalued: deviationPercent < -5,
          severityLevel: Math.abs(deviationPercent) > 10 ? 'EXTREMA' : 
                       Math.abs(deviationPercent) > 5 ? 'ALTA' : 'MODERADA',
          interestDifferential: interestDifferential,
          inflationDifferential: inflationDifferential,
          riskPremium: riskPremium
        };
      }
      
      // AnÃ¡lise de volatilidade por perÃ­odo
      analyzeSystemVolatility() {
        const periods = [9, 18, 27];
        const results = {};
        
        periods.forEach(period => {
          const stdDev = this.calculateStdDevReturns(period);
          if (isNaN(stdDev)) return;
          
          const volPercent = stdDev * 100;
          let regime, riskLevel, tradingAdvice;
          
          if (volPercent > 3.0) {
            regime = 'ALTA';
            riskLevel = 'EXTREMO';
            tradingAdvice = 'Evitar trades direcionais';
          } else if (volPercent > 2.0) {
            regime = 'MODERADA-ALTA';
            riskLevel = 'ALTO';
            tradingAdvice = 'Reduzir tamanho de posiÃ§Ã£o';
          } else if (volPercent > 1.0) {
            regime = 'MODERADA';
            riskLevel = 'MÃDIO';
            tradingAdvice = 'CondiÃ§Ãµes normais de trading';
          } else {
            regime = 'BAIXA';
            riskLevel = 'BAIXO';
            tradingAdvice = 'Ideal para trades direcionais';
          }
          
          results[`p${period}`] = {
            period: period,
            volatilityPercent: volPercent,
            regime: regime,
            riskLevel: riskLevel,
            tradingAdvice: tradingAdvice,
            isLowVol: volPercent < 1.5,
            isHighVol: volPercent > 3.0
          };
        });
        
        return results;
      }
      
      // Score de oportunidade melhorado usando todos os cÃ¡lculos do sistema
      calculateEnhancedOpportunityScore(garchAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        if (!fairPriceAnalysis.valid) return 30;
        
        let score = 50; // Base score
        
        // Componente: Desvio do preÃ§o justo (0-40 pontos)
        const deviation = fairPriceAnalysis.deviationAbs;
        const deviationScore = Math.min(40, deviation * 3);
        score += deviationScore;
        
        // Componente: Volatilidade (penaliza alta volatilidade)
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        if (vol18 < 1.5) {
          score += 15; // Baixa volatilidade Ã© boa
        } else if (vol18 > 3.0) {
          score -= 20; // Alta volatilidade penaliza
        }
        
        // Componente: ConsistÃªncia entre perÃ­odos GARCH
        const periods = [9, 18, 27];
        let consistentDirection = 0;
        const referencePrice = this.lastClose();
        
        periods.forEach(p => {
          const garch = garchAnalysis[`p${p}`];
          if (garch) {
            if (fairPriceAnalysis.deviationPercent > 5 && referencePrice > garch.up1sigma) {
              consistentDirection++; // PreÃ§o alto + acima de +1Ï
            } else if (fairPriceAnalysis.deviationPercent < -5 && referencePrice < garch.down1sigma) {
              consistentDirection++; // PreÃ§o baixo + abaixo de -1Ï
            }
          }
        });
        
        score += consistentDirection * 5;
        
        // Limitar entre 0-100
        return Math.max(0, Math.min(100, Math.round(score)));
      }
      
      // SituaÃ§Ã£o atual melhorada
      generateEnhancedSituation(currentPrice, garchAnalysis, fairPriceAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return "Configure os parÃ¢metros de preÃ§o justo para anÃ¡lise completa.";
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const garch18 = garchAnalysis.p18;
        
        let situation = `USD/BRL em ${this.fmt(currentPrice)}, `;
        
        // AnÃ¡lise de preÃ§o justo
        if (Math.abs(deviation) < 2) {
          situation += `prÃ³ximo ao justÃ­ssimo (${this.fmt(fairPriceAnalysis.fairPriceCombined)}). `;
        } else if (deviation > 0) {
          situation += `${deviation.toFixed(1)}% ACIMA do justÃ­ssimo (${this.fmt(fairPriceAnalysis.fairPriceCombined)}). `;
        } else {
          situation += `${Math.abs(deviation).toFixed(1)}% ABAIXO do justÃ­ssimo (${this.fmt(fairPriceAnalysis.fairPriceCombined)}). `;
        }
        
        // AnÃ¡lise GARCH 18P
        if (garch18) {
          if (currentPrice > garch18.up1sigma) {
            situation += `Acima da banda +1Ï GARCH (${this.fmt(garch18.up1sigma)}).`;
          } else if (currentPrice < garch18.down1sigma) {
            situation += `Abaixo da banda -1Ï GARCH (${this.fmt(garch18.down1sigma)}).`;
          } else {
            situation += `Dentro das bandas GARCH Â±1Ï.`;
          }
        }
        
        return situation;
      }
      
      // RecomendaÃ§Ã£o principal melhorada
      generateEnhancedRecommendation(garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return "Configure os parÃ¢metros do sistema para recomendaÃ§Ãµes precisas.";
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        const garch18 = garchAnalysis.p18;
        const intraday18 = intradayAnalysis.p18;
        const currentPrice = this.lastClose();
        
        let recommendation = "";
        
        // LÃ³gica principal baseada nos cÃ¡lculos reais do sistema
        if (Math.abs(deviation) > 8 && vol18 < 2.5) {
          // Desvio extremo + baixa volatilidade = alta confianÃ§a
          if (deviation > 8) {
            recommendation = `FORTE RECOMENDAÃÃO DE VENDA: Moeda ${deviation.toFixed(1)}% sobrevalorizada com volatilidade controlada (${vol18.toFixed(2)}%). `;
            
            if (garch18 && currentPrice > garch18.up1sigma) {
              recommendation += `GARCH confirma: preÃ§o acima de +1Ï (${this.fmt(garch18.up1sigma)}). `;
            }
            
            if (intraday18) {
              recommendation += `Meta mÃ¡xima intraday: ${this.fmt(intraday18.maxIntraday)}.`;
            }
          } else {
            recommendation = `FORTE RECOMENDAÃÃO DE COMPRA: Moeda ${Math.abs(deviation).toFixed(1)}% subvalorizada com volatilidade controlada (${vol18.toFixed(2)}%). `;
            
            if (garch18 && currentPrice < garch18.down1sigma) {
              recommendation += `GARCH confirma: preÃ§o abaixo de -1Ï (${this.fmt(garch18.down1sigma)}). `;
            }
            
            if (intraday18) {
              recommendation += `Meta mÃ­nima intraday: ${this.fmt(intraday18.minIntraday)}.`;
            }
          }
        } else if (Math.abs(deviation) > 5) {
          // Desvio moderado
          if (deviation > 5) {
            recommendation = `ATENÃÃO PARA VENDAS: ${deviation.toFixed(1)}% sobrevalorizada. `;
          } else {
            recommendation = `ATENÃÃO PARA COMPRAS: ${Math.abs(deviation).toFixed(1)}% subvalorizada. `;
          }
          
          if (vol18 > 3.0) {
            recommendation += `CUIDADO: Volatilidade alta (${vol18.toFixed(2)}%) pode causar falsos sinais. `;
          }
        } else if (vol18 > 4.0) {
          recommendation = `AGUARDAR: Volatilidade extrema (${vol18.toFixed(2)}%) domina. Aguardar normalizaÃ§Ã£o. `;
        } else {
          recommendation = `MONITORAR: SituaÃ§Ã£o equilibrada. Desvio: ${deviation.toFixed(1)}%, Vol: ${vol18.toFixed(2)}%. `;
          
          if (intraday18) {
            recommendation += `Range intraday esperado: ${this.fmt(intraday18.minIntraday)} - ${this.fmt(intraday18.maxIntraday)}.`;
          }
        }
        
        return recommendation;
      }
      
      // Alertas melhorados baseados nos cÃ¡lculos do sistema
      generateEnhancedAlerts(garchAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        const alerts = [];
        
        if (!fairPriceAnalysis.valid) {
          alerts.push({
            type: 'info',
            message: 'Configure parÃ¢metros PPP/UIP para anÃ¡lise completa do preÃ§o justo.'
          });
          return alerts;
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        const garch18 = garchAnalysis.p18;
        const currentPrice = this.lastClose();
        
        // Alertas de desvio extremo
        if (Math.abs(deviation) > 10) {
          alerts.push({
            type: 'warning',
            message: `DESVIO EXTREMO: ${Math.abs(deviation).toFixed(1)}% do preÃ§o justÃ­ssimo! ReversÃ£o altamente provÃ¡vel.`
          });
        }
        
        // Alertas GARCH
        if (garch18) {
          if (currentPrice > garch18.up2sigma) {
            alerts.push({
              type: 'warning',
              message: `PreÃ§o acima de +2Ï GARCH (${this.fmt(garch18.up2sigma)}). Zona de sobrecompra estatÃ­stica.`
            });
          } else if (currentPrice < garch18.down2sigma) {
            alerts.push({
              type: 'warning',
              message: `PreÃ§o abaixo de -2Ï GARCH (${this.fmt(garch18.down2sigma)}). Zona de sobrevenda estatÃ­stica.`
            });
          }
        }
        
        // Alertas de volatilidade
        if (vol18 > 4.0) {
          alerts.push({
            type: 'warning',
            message: `VOLATILIDADE EXTREMA: ${vol18.toFixed(2)}%! Mercado imprevisÃ­vel, evitar trades direcionais.`
          });
        } else if (vol18 < 1.0 && Math.abs(deviation) > 5) {
          alerts.push({
            type: 'success',
            message: `OPORTUNIDADE: Baixa volatilidade (${vol18.toFixed(2)}%) + desvio significativo = alta probabilidade de acerto.`
          });
        }
        
        // Alertas de confluÃªncia
        if (Math.abs(deviation) > 5 && garch18) {
          const garchConfirms = (deviation > 0 && currentPrice > garch18.up1sigma) || 
                               (deviation < 0 && currentPrice < garch18.down1sigma);
          
          if (garchConfirms) {
            alerts.push({
              type: 'success',
              message: 'CONFLUÃNCIA: PreÃ§o justo e GARCH apontam mesma direÃ§Ã£o. Alta confiabilidade.'
            });
          } else {
            alerts.push({
              type: 'info',
              message: 'DIVERGÃNCIA: PreÃ§o justo e GARCH em conflito. Aguardar confirmaÃ§Ã£o.'
            });
          }
        }
        
        return alerts;
      }
      
      // CenÃ¡rios melhorados usando GARCH e preÃ§o justo
      calculateEnhancedScenarios(garchAnalysis, fairPriceAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return {
            strongUp: 20, moderateUp: 20, lateral: 20, moderateDown: 20, strongDown: 20
          };
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const garch18 = garchAnalysis.p18;
        
        // Base probabilities
        let scenarios = {
          strongUp: 15,    // >+2%
          moderateUp: 20,  // +1% to +2%
          lateral: 30,     // -1% to +1%
          moderateDown: 20, // -2% to -1%
          strongDown: 15   // <-2%
        };
        
        // Ajuste baseado no desvio do preÃ§o justo
        if (deviation > 8) {
          // Muito sobrevalorizado - alta probabilidade de queda
          scenarios.strongDown += 25;
          scenarios.moderateDown += 15;
          scenarios.strongUp -= 15;
          scenarios.moderateUp -= 10;
          scenarios.lateral -= 15;
        } else if (deviation > 5) {
          // Moderadamente sobrevalorizado
          scenarios.strongDown += 15;
          scenarios.moderateDown += 10;
          scenarios.strongUp -= 10;
          scenarios.lateral -= 15;
        } else if (deviation < -8) {
          // Muito subvalorizado - alta probabilidade de alta
          scenarios.strongUp += 25;
          scenarios.moderateUp += 15;
          scenarios.strongDown -= 15;
          scenarios.moderateDown -= 10;
          scenarios.lateral -= 15;
        } else if (deviation < -5) {
          // Moderadamente subvalorizado
          scenarios.strongUp += 15;
          scenarios.moderateUp += 10;
          scenarios.strongDown -= 10;
          scenarios.lateral -= 15;
        }
        
        // Ajuste baseado no GARCH
        if (garch18) {
          const currentPrice = this.lastClose();
          
          if (currentPrice > garch18.up1sigma) {
            // Acima de +1Ï - maior probabilidade de correÃ§Ã£o
            scenarios.moderateDown += 10;
            scenarios.strongDown += 5;
            scenarios.strongUp -= 10;
            scenarios.lateral -= 5;
          } else if (currentPrice < garch18.down1sigma) {
            // Abaixo de -1Ï - maior probabilidade de recuperaÃ§Ã£o
            scenarios.moderateUp += 10;
            scenarios.strongUp += 5;
            scenarios.strongDown -= 10;
            scenarios.lateral -= 5;
          }
        }
        
        // Normalizar para 100%
        const total = Object.values(scenarios).reduce((sum, val) => sum + val, 0);
        Object.keys(scenarios).forEach(key => {
          scenarios[key] = Math.max(5, Math.round((scenarios[key] / total) * 100));
        });
        
        return scenarios;
      }
      
      // Narrativa melhorada com todos os cÃ¡lculos do sistema
      generateEnhancedNarrative(currentPrice, garchAnalysis, intradayAnalysis, fairPriceAnalysis, volatilityAnalysis) {
        if (!fairPriceAnalysis.valid) {
          return `
            <h4>ANÃLISE DIÃRIA - USD/BRL (${new Date().toLocaleDateString('pt-BR')})</h4>
            <p>Configure os parÃ¢metros de preÃ§o justo (PPP, UIP, juros) para anÃ¡lise narrativa completa.</p>
          `;
        }
        
        const deviation = fairPriceAnalysis.deviationPercent;
        const vol18 = volatilityAnalysis.p18?.volatilityPercent || 2.0;
        const garch18 = garchAnalysis.p18;
        const intraday18 = intradayAnalysis.p18;
        
        let narrative = `
          <h4>ANÃLISE GARCH COM IA - USD/BRL (${new Date().toLocaleDateString('pt-BR')})</h4>
          
          <p><strong>SITUAÃÃO ATUAL:</strong><br>
          O dÃ³lar fechou em ${this.fmt(currentPrice)}, operando ${Math.abs(deviation).toFixed(1)}% ${deviation > 0 ? 'ACIMA' : 'ABAIXO'} do preÃ§o justÃ­ssimo de ${this.fmt(fairPriceAnalysis.fairPriceCombined)}. 
          Volatilidade 18P em ${vol18.toFixed(2)}% (${volatilityAnalysis.p18?.regime || 'MODERADA'}).</p>
          
          <p><strong>ANÃLISE GARCH MULTI-PERÃODO:</strong><br>`;
        
        if (garch18) {
          narrative += `Bandas GARCH 18P: ${this.fmt(garch18.down1sigma)} (-1Ï) | ${this.fmt(garch18.up1sigma)} (+1Ï)<br>`;
          
          if (currentPrice > garch18.up1sigma) {
            narrative += `â ï¸ PreÃ§o ACIMA da banda superior (+1Ï) - pressÃ£o de venda estatÃ­stica<br>`;
          } else if (currentPrice < garch18.down1sigma) {
            narrative += `â ï¸ PreÃ§o ABAIXO da banda inferior (-1Ï) - pressÃ£o de compra estatÃ­stica<br>`;
          } else {
            narrative += `â PreÃ§o DENTRO das bandas Â±1Ï - comportamento normal<br>`;
          }
        }
        
        narrative += `</p><p><strong>PROJEÃÃES INTRADAY (FATORES EXP):</strong><br>`;
        
        if (intraday18) {
          narrative += `Range esperado: ${this.fmt(intraday18.minIntraday)} - ${this.fmt(intraday18.maxIntraday)} (${intraday18.rangePercent.toFixed(2)}%)<br>`;
          narrative += `Potencial alta: +${intraday18.potentialGain.toFixed(2)}% | Potencial baixa: -${intraday18.potentialLoss.toFixed(2)}%`;
        }
        
        narrative += `</p><p><strong>PREÃO JUSTO INTEGRADO (PPP+UIP):</strong><br>`;
        narrative += `PPP: ${this.fmt(fairPriceAnalysis.fairPricePPP)} | UIP: ${this.fmt(fairPriceAnalysis.fairPriceUIP)}<br>`;
        narrative += `JustÃ­ssimo (40% PPP + 60% UIP): ${this.fmt(fairPriceAnalysis.fairPriceCombined)}<br>`;
        narrative += `Diferencial juros BR-US: ${(fairPriceAnalysis.interestDifferential * 100).toFixed(2)}p.p.`;
        
        narrative += `</p><p><strong>CENÃRIOS PROBABILÃSTICOS:</strong><br>`;
        
        if (Math.abs(deviation) > 8) {
          const direction = deviation > 0 ? 'CORREÃÃO BAIXISTA' : 'RECUPERAÃÃO ALTISTA';
          const probability = Math.min(80, Math.round(Math.abs(deviation) * 8));
          
          narrative += `ð¯ <strong>${direction} (${probability}%):</strong> Desvio extremo tende Ã  reversÃ£o<br>`;
          
          if (vol18 < 2.5) {
            narrative += `â <strong>ALTA CONFIANÃA:</strong> Baixa volatilidade favorece movimentos direcionais<br>`;
          } else {
            narrative += `â ï¸ <strong>ATENÃÃO:</strong> Alta volatilidade pode gerar ruÃ­do no movimento`;
          }
        } else if (Math.abs(deviation) > 5) {
          narrative += `ð <strong>MOVIMENTO MODERADO:</strong> Desvio ${Math.abs(deviation).toFixed(1)}% sugere correÃ§Ã£o gradual<br>`;
        } else {
          narrative += `ð <strong>EQUILÃBRIO:</strong> PreÃ§o prÃ³ximo ao justo, aguardar catalisador<br>`;
        }
        
        narrative += `</p><p><strong>RECOMENDAÃÃO FINAL:</strong><br>`;
        
        if (Math.abs(deviation) > 8 && vol18 < 2.5) {
          if (deviation > 8) {
            narrative += `ð´ <strong>VENDA RECOMENDADA:</strong> ConfluÃªncia preÃ§o justo + GARCH indica sobrevalorizaÃ§Ã£o. Stop acima de ${garch18 ? this.fmt(garch18.up2sigma) : 'N/D'}.`;
          } else {
            narrative += `ð¢ <strong>COMPRA RECOMENDADA:</strong> ConfluÃªncia preÃ§o justo + GARCH indica subvalorizaÃ§Ã£o. Stop abaixo de ${garch18 ? this.fmt(garch18.down2sigma) : 'N/D'}.`;
          }
        } else if (vol18 > 4.0) {
          narrative += `ð¡ <strong>AGUARDAR:</strong> Volatilidade extrema (${vol18.toFixed(2)}%) requer paciÃªncia. Aguardar normalizaÃ§Ã£o abaixo de 3%.`;
        } else {
          narrative += `ð <strong>MONITORAR:</strong> CondiÃ§Ãµes mistas. Aguardar confirmaÃ§Ã£o de direÃ§Ã£o com aumento de volume.`;
        }
        
        narrative += `</p>`;
        
        return narrative;
      }
      
      // Sistema FRP - Forward Rate Premium (mantido do original)
      convertSpotToFuture(spotPrice) {
        const frp = parseFloat(document.getElementById('frp')?.value || 0) / 100;
        const maturityDays = parseInt(document.getElementById('maturityDays')?.value || 30);
        const dataType = document.getElementById('dataType')?.value || 'spot';
        
        if (dataType === 'spot' && frp !== 0) {
          const timeFactor = maturityDays / 365;
          return spotPrice * (1 + frp * timeFactor);
        }
        
        return spotPrice;
      }
      
      convertFutureToSpot(futurePrice) {
        const frp = parseFloat(document.getElementById('frp')?.value || 0) / 100;
        const maturityDays = parseInt(document.getElementById('maturityDays')?.value || 30);
        const dataType = document.getElementById('dataType')?.value || 'spot';
        
        if (dataType === 'future' && frp !== 0) {
          const timeFactor = maturityDays / 365;
          return futurePrice / (1 + frp * timeFactor);
        }
        
        return futurePrice;
      }
      
      updateDataTypeUI() {
        const dataType = document.getElementById('dataType')?.value;
        const frpInput = document.getElementById('frp');
        const maturityInput = document.getElementById('maturityDays');
        
        if (dataType === 'spot') {
          frpInput.classList.add('frp-highlight');
          frpInput.classList.remove('frp-disabled');
          frpInput.placeholder = 'Ex: 13.75 (Selic atual)';
          this.log('Modo SPOT: FRP serÃ¡ aplicado para converter para preÃ§os futuros');
        } else {
          frpInput.classList.remove('frp-highlight');
          frpInput.classList.add('frp-disabled');
          frpInput.placeholder = 'NÃ£o necessÃ¡rio para dados futuros';
          this.log('Modo FUTURO: Dados jÃ¡ incorporam juros implÃ­citos');
        }
      }
      
      processRawData(rawPrices, sourceType = 'api') {
        const dataType = document.getElementById('dataType')?.value || 'spot';
        const frp = parseFloat(document.getElementById('frp')?.value || 0);
        
        let processedPrices = [...rawPrices];
        
        if (sourceType === 'api' && dataType === 'spot' && frp > 0) {
          processedPrices = processedPrices.map(price => this.convertSpotToFuture(price));
          this.log(`ConversÃ£o aplicada: Spot â Futuro (FRP: ${frp.toFixed(2)}%)`);
        } else if (sourceType === 'excel' && dataType === 'future') {
          this.log('Dados futuros do Excel utilizados diretamente');
        } else if (sourceType === 'excel' && dataType === 'spot' && frp > 0) {
          processedPrices = processedPrices.map(price => this.convertSpotToFuture(price));
          this.log(`ConversÃ£o aplicada: Spot (Excel) â Futuro (FRP: ${frp.toFixed(2)}%)`);
        }
        
        return processedPrices;
      }
      
      // API Configuration Methods (mantidos do original)
      selectProvider(provider) {
        document.querySelectorAll('.provider-card').forEach(card => {
          card.classList.remove('active');
        });
        document.querySelector(`[data-provider="${provider}"]`).classList.add('active');
        
        this.apiConfig.provider = provider;
        this.updateAPIInfo();
        this.updateProviderSpecificUI(provider);
      }
      
      updateProviderSpecificUI(provider) {
        const symbolInput = document.getElementById('symbol');
        
        switch(provider) {
          case 'alpha_vantage':
            symbolInput.value = 'USDBRL';
            break;
          case 'yahoo_finance':
            symbolInput.value = 'USDBRL=X';
            break;
          case 'polygon':
            symbolInput.value = 'C:USDBRL';
            break;
          case 'tradier':
            symbolInput.value = 'USD/BRL';
            break;
        }
        
        this.apiConfig.symbol = symbolInput.value;
      }
      
      updateAPIConfigFromInputs() {
        this.apiConfig.apiKey = document.getElementById('apiKey').value;
        this.apiConfig.symbol = document.getElementById('symbol').value;
        this.apiConfig.interval = document.getElementById('interval').value;
      }
      
      saveAPIConfig() {
        this.updateAPIConfigFromInputs();
        this.log(`ConfiguraÃ§Ã£o salva para ${this.apiConfig.provider}`);
        this.updateAPIInfo();
      }
      
      loadAPIConfig() {
        document.getElementById('apiKey').value = this.apiConfig.apiKey;
        document.getElementById('symbol').value = this.apiConfig.symbol;
        document.getElementById('interval').value = this.apiConfig.interval;
      }
      
      updateAPIInfo() {
        document.getElementById('activeProvider').textContent = this.getProviderDisplayName(this.apiConfig.provider);
        document.getElementById('connectionStatus').textContent = this.apiConnected ? 'Conectado' : 'Desconectado';
        document.getElementById('dataCount').textContent = this.priceData.length;
        
        const statusEl = document.getElementById('apiStatus');
        statusEl.textContent = `API: ${this.apiConnected ? 'Conectado' : 'Desconectado'}`;
        statusEl.className = `api-status ${this.apiConnected ? 'connected' : 'disconnected'}`;
      }
      
      getProviderDisplayName(provider) {
        const names = {
          'alpha_vantage': 'Alpha Vantage',
          'yahoo_finance': 'Yahoo Finance',
          'polygon': 'Polygon.io',
          'tradier': 'Tradier'
        };
        return names[provider] || provider;
      }
      
      async testAPIConnection() {
        this.showLoading();
        document.getElementById('apiStatus').className = 'api-status testing';
        document.getElementById('apiStatus').textContent = 'API: Testando...';
        
        try {
          if (this.apiConfig.provider === 'alpha_vantage') {
            const testKey = this.apiConfig.apiKey || 'demo';
            
            if (testKey === 'demo' || testKey === '') {
              this.apiConnected = true;
              this.updateAPIInfo();
              this.log('â Modo demo ativo. Clique "ð¡ Dados via API" para ver dados realÃ­sticos.');
              document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
              return;
            }
            
            const testUrl = `https://www.alphavantage.co/query?function=FX_DAILY&from_symbol=USD&to_symbol=BRL&apikey=${testKey}&outputsize=compact`;
            
            try {
              const response = await fetch(testUrl, {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
              });
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: Verifique sua conexÃ£o`);
              }
              
              const data = await response.json();
              
              if (data['Error Message']) {
                throw new Error(`API Key invÃ¡lida: ${data['Error Message']}`);
              }
              
              if (data['Note'] || data['Information']) {
                this.log('â ï¸ Limite de calls atingido, mas API key Ã© vÃ¡lida. Usando dados demo.');
                this.apiConnected = true;
              } else if (data['Meta Data'] || data['Time Series (Daily)']) {
                this.apiConnected = true;
                this.log('â API Key vÃ¡lida! Conectado ao Alpha Vantage.');
              } else {
                this.log('â ï¸ Resposta inesperada da API. Usando dados demo para demonstraÃ§Ã£o.');
                this.apiConnected = true;
              }
              
            } catch (fetchError) {
              console.error('Fetch error:', fetchError);
              
              if (fetchError.message.includes('CORS') || 
                  fetchError.message.includes('Failed to fetch') ||
                  fetchError.message.includes('NetworkError')) {
                this.log('â ï¸ Problema de CORS/rede detectado. Sistema funcionarÃ¡ com dados demo.');
                this.apiConnected = true;
              } else {
                throw fetchError;
              }
            }
            
            this.updateAPIInfo();
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
          }
          
        } catch (error) {
          console.error('Test connection error:', error);
          this.apiConnected = false;
          this.updateAPIInfo();
          
          if (error.message.includes('API Key invÃ¡lida')) {
            this.log(`â ${error.message}. Verifique sua chave ou use 'demo'.`);
          } else if (error.message.includes('HTTP')) {
            this.log(`â ${error.message}. Tente novamente em alguns segundos.`);
          } else {
            this.log(`â Erro no teste: ${error.message}. Use 'demo' para testar.`);
          }
        } finally {
          this.hideLoading();
        }
      }
      
      async fetchAPIData() {
        const canProceed = this.apiConnected || 
                          this.apiConfig.provider === 'yahoo_finance' || 
                          this.apiConfig.apiKey === 'demo' || 
                          !this.apiConfig.apiKey;
        
        if (!canProceed) {
          this.log("Teste a conexÃ£o da API primeiro");
          return;
        }
        
        this.showLoading();
        this.setStatus("buscando dados da API...");
        
        try {
          let data;
          
          switch(this.apiConfig.provider) {
            case 'alpha_vantage':
              data = await this.fetchAlphaVantageData();
              break;
            case 'yahoo_finance':
              data = await this.fetchYahooFinanceData();
              break;
            case 'polygon':
              data = await this.fetchPolygonData();
              break;
            case 'tradier':
              data = await this.fetchTradierData();
              break;
            default:
              throw new Error('Provedor nÃ£o suportado');
          }
          
          const processedData = this.processRawData(data, 'api');
          this.priceData = processedData;
          this.refreshAll();
          this.setStatus(`${processedData.length} pontos da API`);
          this.log(`â Dados processados via ${this.getProviderDisplayName(this.apiConfig.provider)}: ${processedData.length} registros`);
          document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
          
          // Auto-run AI analysis if data is available
          if (processedData.length > 20) {
            setTimeout(() => this.performAIAnalysis(), 1000);
          }
          
          const welcomeBanner = document.querySelector('.welcome-banner');
          if (welcomeBanner) {
            welcomeBanner.style.display = 'none';
          }
          
        } catch (error) {
          this.setStatus("erro na API");
          this.log(`â Erro API: ${error.message}`);
          
          if (error.message.includes('API Key')) {
            this.log("ð¡ Dica: Use 'demo' como API key para testar, ou carregue dados manualmente");
          }
        } finally {
          this.hideLoading();
        }
      }
      
      async fetchAlphaVantageData() {
        const apiKey = this.apiConfig.apiKey || 'demo';
        
        if (apiKey === 'demo' || apiKey === '') {
          this.log('ð¯ Usando dados demo para demonstraÃ§Ã£o');
          return this.generateFallbackData();
        }

        let url = `https://www.alphavantage.co/query?function=FX_DAILY&from_symbol=USD&to_symbol=BRL&apikey=${apiKey}&outputsize=compact`;
        
        this.log('Conectando com Alpha Vantage...');
        
        try {
          const response = await fetch(url, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
            }
          });
          
          if (!response.ok) {
            this.log(`â ï¸ Erro HTTP ${response.status}. Usando dados demo.`);
            return this.generateFallbackData();
          }
          
          const data = await response.json();
          
          if (data['Error Message'] || data['Note'] || data['Information']) {
            this.log('â ï¸ Limite de API atingido. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          const timeSeries = data['Time Series (Daily)'] || data['Time Series FX (Daily)'];
          
          if (!timeSeries || typeof timeSeries !== 'object') {
            this.log('â ï¸ Estrutura de dados inesperada da API. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          const dates = Object.keys(timeSeries).sort();
          
          if (dates.length === 0) {
            this.log('â ï¸ Nenhum dado temporal encontrado. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          const prices = [];
          const recentDates = dates.slice(-180);
          
          for (const date of recentDates) {
            const dayData = timeSeries[date];
            if (!dayData || typeof dayData !== 'object') continue;
            
            const closePrice = parseFloat(
              dayData['4. close'] || 
              dayData['close'] || 
              dayData['Close'] || 
              dayData['4'] ||
              0
            );
            
            if (!isNaN(closePrice) && closePrice > 0) {
              let adjustedPrice = closePrice;
              
              if (closePrice < 10) {
                adjustedPrice = closePrice * 1000;
              }
              
              prices.push(Number(adjustedPrice.toFixed(2)));
            }
          }
          
          if (prices.length === 0) {
            this.log('â ï¸ Nenhum preÃ§o vÃ¡lido processado. Usando dados demo.');
            return this.generateFallbackData();
          }
          
          this.log(`â Alpha Vantage: ${prices.length} preÃ§os USD/BRL processados com sucesso`);
          return prices;
          
        } catch (error) {
          console.error('Alpha Vantage Error:', error);
          this.log(`â ï¸ Erro de conexÃ£o: ${error.message}. Usando dados demo.`);
          return this.generateFallbackData();
        }
      }
      
      generateFallbackData() {
        const baseRate = 5.20;
        const data = [];
        let currentRate = baseRate;
        
        for (let i = 0; i < 180; i++) {
          const dailyChange = (Math.random() - 0.5) * 0.06;
          const trend = Math.sin(i * 0.1) * 0.01;
          
          currentRate *= (1 + dailyChange + trend);
          currentRate = Math.max(4.80, Math.min(5.80, currentRate));
          
          data.push(Number(currentRate.toFixed(4)));
        }
        
        return data;
      }
      
      async fetchYahooFinanceData() {
        await new Promise(resolve => setTimeout(resolve, 1200));
        return this.generateRealisticData(180);
      }
      
      async fetchPolygonData() {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return this.generateRealisticData(180);
      }
      
      async fetchTradierData() {
        await new Promise(resolve => setTimeout(resolve, 1300));
        return this.generateRealisticData(180);
      }
      
      generateRealisticData(count) {
        const currentClose = 5.437;
        const out = [];
        let x = currentClose;
        
        for (let i = count - 1; i >= 0; i--) {
          const daysBack = i;
          const trend = Math.sin(daysBack * 0.06) * 0.003;
          const dailyVolatility = (Math.random() - 0.5) * 0.018;
          const momentum = Math.sin(daysBack * 0.25) * 0.002;
          const meanReversion = (5.42 - x) * 0.0005;
          
          x *= (1 + trend + dailyVolatility + momentum + meanReversion);
          x = Math.max(5.20, Math.min(5.65, x));
          out.push(Number(x.toFixed(4)));
        }
        
        out.reverse();
        out[out.length - 1] = currentClose;
        
        return out;
      }
      
      async fetchSimulatedData() {
        this.showLoading();
        this.setStatus("buscando dados simulados...");
        
        try {
          await new Promise(resolve => setTimeout(resolve, 1000));
          const data = this.generateRealisticData(180);
          const processedData = this.processRawData(data, 'simulated');
          this.priceData = processedData;
          this.refreshAll();
          this.setStatus(`${processedData.length} pontos simulados`);
          this.log(`Dados simulados carregados: ${processedData.length} preÃ§os`);
          
          // Auto-run AI analysis
          if (processedData.length > 20) {
            setTimeout(() => this.performAIAnalysis(), 500);
          }
          
          const welcomeBanner = document.querySelector('.welcome-banner');
          if (welcomeBanner) {
            welcomeBanner.style.display = 'none';
          }
        } catch (e) {
          this.setStatus("erro ao buscar dados");
          this.log("Erro: " + e.message);
        } finally {
          this.hideLoading();
        }
      }
      
      logout() {
        if (confirm('Deseja realmente sair do sistema?')) {
          sessionStorage.removeItem('currentUser');
          window.location.href = 'index.html';
        }
      }
      
      showLoading() {
        document.getElementById('loadingOverlay').style.display = 'flex';
      }
      
      hideLoading() {
        document.getElementById('loadingOverlay').style.display = 'none';
      }
      
      analyze() {
        if (!this.priceData.length) {
          this.log("Carregue dados primeiro");
          return;
        }
        
        this.showLoading();
        
        setTimeout(() => {
          this.refreshAll();
          this.log("AnÃ¡lise executada com sucesso");
          
          // Auto-run AI analysis after regular analysis
          setTimeout(() => this.performAIAnalysis(), 500);
          
          this.hideLoading();
        }, 800);
      }
      
      loadManualData() {
        const text = document.getElementById('manualData').value.trim();
        if (!text) {
          this.log("Digite alguns preÃ§os primeiro");
          return;
        }
        
        const lines = text.split('\n').filter(l => l.trim());
        const rawPrices = lines.map(l => parseFloat(l.trim())).filter(p => !isNaN(p));
        
        if (rawPrices.length === 0) {
          this.log("Nenhum preÃ§o vÃ¡lido encontrado");
          return;
        }
        
        const processedPrices = this.processRawData(rawPrices, 'manual');
        this.priceData = processedPrices;
        this.refreshAll();
        this.setStatus(`${processedPrices.length} preÃ§os manuais`);
        this.log(`${processedPrices.length} preÃ§os processados manualmente`);
        this.updateAPIInfo();
        
        // Auto-run AI analysis
        if (processedPrices.length > 10) {
          setTimeout(() => this.performAIAnalysis(), 500);
        }
      }
      
      clearData() {
        if (!confirm('Deseja realmente limpar todos os dados?')) {
          return;
        }
        
        this.priceData = [];
        this.linearReturns = [];
        this.aiAnalysis = null;
        document.getElementById('manualData').value = "";
        
        const valueElements = document.querySelectorAll('.value');
        valueElements.forEach(el => el.innerText = '--');
        
        document.getElementById('debugInfo').innerText = "Debug: aguardando cÃ¡lculos...";
        
        this.setStatus("dados limpos");
        this.log("Dados limpos");
        this.updateAPIInfo();
        this.updateAIDisplay(); // Reset AI display
      }
      
      handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        this.showLoading();
        this.log("Processando arquivo Excel...");
        
        const reader = new FileReader();
        reader.onload = (evt) => {
          try {
            const data = evt.target.result;
            const workbook = XLSX.read(data, {type: 'binary'});
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
            
            if (jsonData.length === 0) {
              this.log("Planilha vazia");
              this.hideLoading();
              return;
            }
            
            const firstRow = jsonData[0] || [];
            
            
            // Detectar colunas VWAP e utilitÃ¡rios
            let vwapDCol = -1, vwapSCol = -1, vwapMCol = -1, dateCol = -1;
            function _toNumBR(v){ if(v==null||v==='') return NaN; if(typeof v==='number') return v; const s=String(v).trim().replace(/\./g,'').replace(',', '.'); const n=parseFloat(s); return isFinite(n)?n:NaN; }
            function _fmtBR(x){ if(!(x>0)) return ''; const s=Number(x).toFixed(2); const p=s.split('.'); p[0]=p[0].replace(/\B(?=(\d{3})+(?!\d))/g,'.'); return p[0]+','+p[1]; }
            function _parseDate(v){
              if (v==null || v==='') return null;
              if (typeof v==='number'){ const base = new Date(Date.UTC(1899,11,30)); base.setUTCDate(base.getUTCDate()+Math.floor(v)); return new Date(base.getFullYear(), base.getMonth(), base.getDate()); }
              const s = String(v).trim();
              const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/);
              if (m){ const yy = (m[3].length===2? Number('20'+m[3]): Number(m[3])); return new Date(yy, Number(m[2])-1, Number(m[1])); }
              const d = new Date(s); if (!isNaN(d)) return new Date(d.getFullYear(), d.getMonth(), d.getDate());
              return null;
            }
            for (let j=0;j<firstRow.length;j++){ const h=String(firstRow[j]||'').toLowerCase();
              if (h.includes('data') || h.includes('date')) dateCol = j;
              if(h.includes('vwap')){
                if (h.includes('vwap d') || h.includes('vwap_d') || /\bd\b|dia|daily/.test(h)) vwapDCol=j;
                if (h.includes('vwap s') || h.includes('vwap_s') || /\bs\b|sem|week/.test(h)) vwapSCol=j;
                if (h.includes('vwap m') || h.includes('vwap_m') || /\bm\b|m[eÃª]s|month/.test(h)) vwapMCol=j;
              }
            }
            let _lastDate = null;
            for (let i=1;i<jsonData.length;i++){ const row=jsonData[i]; const dv = (dateCol>=0? row[dateCol] : null); const dt=_parseDate(dv); if(dt){ if(!_lastDate || dt>_lastDate) _lastDate = dt; } }
            let _firstD = NaN, _firstS = NaN, _firstM = NaN;
            if (_lastDate){
              for (let i=1;i<jsonData.length;i++){
                const row=jsonData[i]; const dv=(dateCol>=0? row[dateCol] : null); const dt=_parseDate(dv);
                if (dt && dt.getFullYear()===_lastDate.getFullYear() && dt.getMonth()===_lastDate.getMonth() && dt.getDate()===_lastDate.getDate()){
                  if (isNaN(_firstD) && vwapDCol>=0){ const vv=_toNumBR(row[vwapDCol]); if (isFinite(vv)) _firstD = vv; }
                  if (isNaN(_firstS) && vwapSCol>=0){ const vv=_toNumBR(row[vwapSCol]); if (isFinite(vv)) _firstS = vv; }
                  if (isNaN(_firstM) && vwapMCol>=0){ const vv=_toNumBR(row[vwapMCol]); if (isFinite(vv)) _firstM = vv; }
                  if (!isNaN(_firstD) && !isNaN(_firstS) && !isNaN(_firstM)) break;
                }
              }
            }
            let _lastD=NaN,_lastS=NaN,_lastM=NaN; // mantido por compatibilidade, mas nÃ£o usado

    
            
            let closeColumn = 4;
            for (let i = 0; i < firstRow.length; i++) {
              const header = String(firstRow[i]).toLowerCase();
              if (header.includes('fechamento') || header.includes('close')) {
                closeColumn = i;
                break;
              }
            }
            
            const prices = [];
            
            for (let i = 1; i < jsonData.length; i++) {
              const row = jsonData[i];
                            if (vwapSCol>=0){ const vv=_toNumBR(row[vwapSCol]); if (isFinite(vv)) _lastS=vv; }
              if (vwapMCol>=0){ const vv=_toNumBR(row[vwapMCol]); if (isFinite(vv)) _lastM=vv; }
    
              if (!row || row.length <= closeColumn) continue;
              
              let rawPrice = row[closeColumn];
              if (rawPrice === undefined || rawPrice === null || rawPrice === '') continue;
              
              let numPrice;
              if (typeof rawPrice === 'number') {
                numPrice = rawPrice;
              } else if (typeof rawPrice === 'string') {
                const cleaned = rawPrice.trim().replace(',', '.');
                numPrice = parseFloat(cleaned);
              } else {
                continue;
              }
              
              if (!isNaN(numPrice) && numPrice >= 4000 && numPrice <= 7000) {
                prices.push(numPrice);
              }
            }
            
            prices.reverse();
            
            if (prices.length > 0) {
              document.getElementById('dataType').value = 'future';
              this.updateDataTypeUI();
              
              const processedPrices = this.processRawData(prices, 'excel');
              this.priceData = processedPrices;
              this.refreshAll();
              this.setStatus(`${processedPrices.length} preÃ§os importados`);
              this.log(`${processedPrices.length} preÃ§os do Excel processados (DOL Futuro)`);
              // Preencher VWAP filtrando por ordem de grandeza do Ãºltimo fechamento
              try{
                const lc = this.lastClose?.() || (this.priceData?.slice(-1)[0]) || NaN;
                function within(x){ if(!isFinite(lc)) return (x>800 && x<20000); return (x>=lc*0.3 && x<=lc*3); }
                function backfill(series){ for (let k=series.length-1;k>=0;k--){ const v=series[k]; if(isFinite(v) && within(v)) return v; } return NaN; }
                // ReconstrÃ³i sÃ©ries rÃ¡pidas a partir do loop feito acima
                const d=_firstD, s=_firstS, m=_firstM;
                const D = d, S = s, M = m;
                const Df=document.getElementById('vwapD'), Sf=document.getElementById('vwapS'), Mf=document.getElementById('vwapM');
                if (Df && isFinite(D)) Df.value = _fmtBR(D);
                if (Sf && isFinite(S)) Sf.value = _fmtBR(S);
                if (Mf && isFinite(M)) Mf.value = _fmtBR(M);
              }catch(_){}
    
              this.updateAPIInfo();
              
              // Auto-run AI analysis
              if (processedPrices.length > 20) {
                setTimeout(() => this.performAIAnalysis(), 1000);
              }
            } else {
              this.log(`Nenhum preÃ§o vÃ¡lido encontrado na coluna ${String.fromCharCode(65+closeColumn)}`);
            }
          } catch (err) {
            this.log("Erro ao ler Excel: " + err.message);
          } finally {
            this.hideLoading();
          }
        };
        reader.readAsBinaryString(file);
      }
      
      // Mathematical calculations (maintained from original)
      calculateLinearReturns() {
        this.linearReturns = [];
        if (this.priceData.length < 2) return;
        
        for (let i = 1; i < this.priceData.length; i++) {
          const current = this.priceData[i];
          const previous = this.priceData[i - 1];
          const linearReturn = current / previous;
          this.linearReturns.push(linearReturn);
        }
      }
      
      calculateStdDevReturns(periods) {
        if (this.linearReturns.length < periods) return NaN;
        
        const slice = this.linearReturns.slice(-periods);
        const mean = slice.reduce((sum, ret) => sum + ret, 0) / slice.length;
        const variance = slice.reduce((sum, ret) => sum + Math.pow(ret - mean, 2), 0) / slice.length;
        const stdDev = Math.sqrt(variance);
        
        return stdDev;
      }
      
      lastClose() {
        return this.priceData.length ? this.priceData[this.priceData.length - 1] : NaN;
      }
      
      currentReturn() {
        return this.linearReturns.length ? this.linearReturns[this.linearReturns.length - 1] : NaN;
      }
      
      getExpFor(period) {
        if (period === 9) return parseFloat(document.getElementById('exp9').value) || 2.718;
        if (period === 18) return parseFloat(document.getElementById('exp18').value) || 2.718;
        if (period === 27) return parseFloat(document.getElementById('exp27').value) || 2.718;
        return 2.718;
      }
      
      calculateMultiPeriodForecasts(period) {
        if (!this.priceData.length || this.linearReturns.length < period) return;
        
        const lc = this.lastClose();
        const stdDev = this.calculateStdDevReturns(period);
        
        if (!isFinite(stdDev)) return;
        
        const up1 = lc * (1 + stdDev);
        const dn1 = lc * (1 - stdDev);
        const up2 = lc * (1 + 2 * stdDev);
        const dn2 = lc * (1 - 2 * stdDev);
        
        document.getElementById('f_up1').innerText = this.fmt(up1);
        document.getElementById('f_dn1').innerText = this.fmt(dn1);
        document.getElementById('f_up2').innerText = this.fmt(up2);
        document.getElementById('f_dn2').innerText = this.fmt(dn2);
      }
      
      calculateIntradayExtremes(period) {
        if (!this.priceData.length || this.linearReturns.length < period) return;
        
        const lc = this.lastClose();
        const stdDev = this.calculateStdDevReturns(period);
        const expFactor = this.getExpFor(period);
        
        if (!isFinite(stdDev) || !isFinite(lc)) return;
        
        const expStdDev = Math.pow(expFactor, stdDev);
        const iMax = lc * expStdDev;
        const iMin = lc / expStdDev;
        
        document.getElementById('i_max').innerText = this.fmt(iMax);
        document.getElementById('i_min').innerText = this.fmt(iMin);
        document.getElementById('i_close').innerText = this.fmt(lc);
        document.getElementById('i_sigma').innerText = (stdDev * 100).toFixed(4) + "%";
        
        const debugText = `PerÃ­odo: ${period}P | StdDev: ${(stdDev*100).toFixed(4)}% | ExpFactor: ${expFactor} | Exp^Ï: ${expStdDev.toFixed(6)} | Max: ${this.fmt(iMax)} | Min: ${this.fmt(iMin)}`;
        document.getElementById('debugInfo').innerText = debugText;
      }
      
      switchForecastPeriod(period) {
        this.currentForecastP = period;
        document.querySelectorAll('#forecastTabs .tab').forEach(el => el.classList.remove('active'));
        const target = document.querySelector(`#forecastTabs .tab[data-period="${period}"]`);
        if (target) target.classList.add('active');
        this.calculateMultiPeriodForecasts(period);
      }
      
      switchIntradayPeriod(period) {
        this.currentIntradayP = period;
        document.querySelectorAll('#intradayTabs .tab').forEach(tab => tab.classList.remove('active'));
        const target = document.querySelector(`#intradayTabs .tab[data-iperiod="${period}"]`);
        if (target) target.classList.add('active');
        this.calculateIntradayExtremes(period);
      }
      
      // Fair Price Calculations (maintained from original with fixes)
      calculateFairPrices() {
        const currentPrice = this.lastClose();
        if (!isFinite(currentPrice) || currentPrice <= 0) {
          this.resetFairPriceDisplay();
          return;
        }
        
        let pppRate = parseFloat(document.getElementById('ppp_rate')?.value || 5.30);
        const inflationBr = parseFloat(document.getElementById('inflation_br')?.value || 4.5) / 100;
        const inflationUs = parseFloat(document.getElementById('inflation_us')?.value || 3.2) / 100;
        const selicRate = parseFloat(document.getElementById('selic_rate')?.value || 15.50) / 100;
        const fedRate = parseFloat(document.getElementById('fed_rate')?.value || 5.50) / 100;
        const riskPremium = parseFloat(document.getElementById('risk_premium')?.value || 2.5) / 100;

        if (currentPrice > 100) {
          pppRate = pppRate * 1000;
        }

        const inflationDifferential = inflationBr - inflationUs;
        const fairPricePPP = pppRate * ((1 + inflationBr) / (1 + inflationUs));

        const interestDifferential = selicRate - fedRate;
        const netInterestDifferential = interestDifferential - riskPremium;
        const uipAdjustmentFactor = 1 + (netInterestDifferential * 0.15);
        const fairPriceUIP = currentPrice * uipAdjustmentFactor;

        const maxUIPDeviation = 0.20;
        const upperBoundUIP = currentPrice * (1 + maxUIPDeviation);
        const lowerBoundUIP = currentPrice * (1 - maxUIPDeviation);
        const boundedFairPriceUIP = Math.max(lowerBoundUIP, Math.min(upperBoundUIP, fairPriceUIP));

        const weightPPP = 0.4;
        const weightUIP = 0.6;
        const fairPriceCombined = (fairPricePPP * weightPPP) + (boundedFairPriceUIP * weightUIP);

        const maxTotalDeviation = 0.25;
        const upperBound = currentPrice * (1 + maxTotalDeviation);
        const lowerBound = currentPrice * (1 - maxTotalDeviation);
        const finalFairPrice = Math.max(lowerBound, Math.min(upperBound, fairPriceCombined));

        const deviationFair = ((currentPrice - finalFairPrice) / finalFairPrice) * 100;

        const riskFactor = 1 + riskPremium;
        const trend30d = this.calculateTrend30Days();

        document.getElementById('fair_ppp').innerText = this.fmt(fairPricePPP);
        document.getElementById('fair_uip').innerText = this.fmt(boundedFairPriceUIP);
        document.getElementById('fair_combined').innerText = this.fmt(finalFairPrice);
        document.getElementById('deviation_fair').innerText = deviationFair.toFixed(2) + '%';
        document.getElementById('interest_diff').innerText = (interestDifferential * 100).toFixed(2) + 'p.p.';
        document.getElementById('inflation_diff').innerText = (inflationDifferential * 100).toFixed(2) + 'p.p.';
        document.getElementById('risk_factor').innerText = riskFactor.toFixed(4);
        document.getElementById('trend_30d').innerText = trend30d;

        this.updateFairPriceCardColors(deviationFair);
      }
      
      calculateTrend30Days() {
        if (this.priceData.length < 30) {
          return 'Dados insuficientes';
        }
        
        const recent30 = this.priceData.slice(-30);
        const first = recent30[0];
        const last = recent30[recent30.length - 1];
        const trend = ((last - first) / first) * 100;
        
        if (trend > 2) return `Forte Alta ${trend.toFixed(1)}%`;
        if (trend > 0.5) return `Alta ${trend.toFixed(1)}%`;
        if (trend < -2) return `Forte Baixa ${trend.toFixed(1)}%`;
        if (trend < -0.5) return `Baixa ${trend.toFixed(1)}%`;
        return `Lateral ${trend.toFixed(1)}%`;
      }
      
      updateFairPriceCardColors(deviation) {
        const fairCombinedCard = document.getElementById('fair_combined').closest('.card');
        const deviationCard = document.getElementById('deviation_fair').closest('.card');
        
        [fairCombinedCard, deviationCard].forEach(card => {
          if (card) {
            card.classList.remove('up-card', 'down-card', 'neutral-card');
          }
        });
        
        if (Math.abs(deviation) < 5) {
          if (fairCombinedCard) fairCombinedCard.classList.add('neutral-card');
          if (deviationCard) deviationCard.classList.add('neutral-card');
        } else if (deviation > 0) {
          if (fairCombinedCard) fairCombinedCard.classList.add('down-card');
          if (deviationCard) deviationCard.classList.add('down-card');
        } else {
          if (fairCombinedCard) fairCombinedCard.classList.add('up-card');
          if (deviationCard) deviationCard.classList.add('up-card');
        }
      }
      
      resetFairPriceDisplay() {
        ['fair_ppp', 'fair_uip', 'fair_combined', 'deviation_fair', 
         'interest_diff', 'inflation_diff', 'risk_factor', 'trend_30d'].forEach(id => {
          const element = document.getElementById(id);
          if (element) element.innerText = '--';
        });
      }
      
      updateExtras() {
        const lc = this.lastClose();
        const currentRet = this.currentReturn();
        
        if (isFinite(currentRet)) {
          const retPercent = (currentRet - 1) * 100;
          document.getElementById('ret_current').innerText = currentRet.toFixed(6) + ` (${retPercent.toFixed(2)}%)`;
        }
        
        [9, 18, 27].forEach(p => {
          const stdDev = this.calculateStdDevReturns(p);
          if (isFinite(stdDev)) {
            document.getElementById(`std${p}`).innerText = (stdDev * 100).toFixed(4) + "%";
            
            const expFactor = this.getExpFor(p);
            const expStdDev = Math.pow(expFactor, stdDev);
            document.getElementById(`exp_std${p}`).innerText = expStdDev.toFixed(6);
            
            if (isFinite(lc)) {
              const maxValue = lc * expStdDev;
              const minValue = lc / expStdDev;
              document.getElementById(`max_${p}p`).innerText = this.fmt(maxValue);
              document.getElementById(`min_${p}p`).innerText = this.fmt(minValue);
            }
          }
        });
      }
      
      refreshAll() {
        this.calculateLinearReturns();
        this.calculateMultiPeriodForecasts(this.currentForecastP);
        this.calculateIntradayExtremes(this.currentIntradayP);
        this.updateExtras();
        this.calculateFairPrices();
        this.updateAPIInfo();
      }
      
      fmt(v) {
        return (isFinite(v) ? Number(v).toFixed(2) : '--');
      }
      
      log(msg) {
        document.getElementById("log").innerText = msg;
        console.log(`[Trading System AI] ${msg}`);
      }
      
      setStatus(msg) {
        document.getElementById("dataStatus").innerText = msg;
      }
    }
    
    // Initialize trading system when page loads
    document.addEventListener('DOMContentLoaded', () => {
      window.tradingSystem = new TradingSystemWithAI();
    });
  </script>
  
  
<script>
/* =======================
   PATCH CONSOLIDADO â 2 cards (Compra & Venda)
   Toque + 10â15 pts + JustÃ­ssimo + cluster de 3 nÃ­veis
   Compat com IA + distÃ¢ncias (pts) arredondadas
   ======================= */
(function(){
  function onReady(fn){
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", fn);
    else fn();
  }

  onReady(function(){
    var tries = 0, t = setInterval(function(){
      var ts = window.tradingSystem;
      if (ts && typeof ts.generateTradingStrategy==="function"
            && typeof ts.analyzeSystemIntraday==="function"
            && typeof ts.analyzeSystemFairPrice==="function"
            && typeof ts.analyzeSystemVolatility==="function"
            && typeof ts.analyzeSystemGARCH==="function"
            && typeof ts.lastClose==="function") {
        clearInterval(t);
        apply(ts);
      }
      if (++tries>200) clearInterval(t);
    }, 100);
  });

  // helpers globais
  const F = (x)=> Number.isFinite(x) ? Number(x).toFixed(2) : "--";
  const STORAGE_KEY = "touchMode"; // "prearm" | "strict"
  function getTouchMode(){ return localStorage.getItem(STORAGE_KEY) || "prearm"; }
  function setTouchMode(v){ localStorage.setItem(STORAGE_KEY, v==="strict"?"strict":"prearm"); }

  function apply(ts){
    function getLevels(){
      const ia = ts.analyzeSystemIntraday();
      const p9  = ia.p9  || {}, p18 = ia.p18 || {}, p27 = ia.p27 || {};
      return {
        buys:  [p9.minIntraday,  p18.minIntraday,  p27.minIntraday].filter(Number.isFinite),
        sells: [p9.maxIntraday,  p18.maxIntraday,  p27.maxIntraday].filter(Number.isFinite)
      };
    }
    function getFair(){
      const f = ts.analyzeSystemFairPrice() || {};
      return { valid: !!f.valid, justoPPP: f.fairPricePPP, justissimo: f.fairPriceCombined };
    }
    function choosePts(vol18){
      if (vol18 >= 3.0) return 15;
      if (vol18 <= 1.5) return 10;
      return 12;
    }
    function sizeByVol(vol18, conf){
      if (vol18 > 3.5) return "REDUZIDA (50%)";
      if (vol18 > 3.0) return "REDUZIDA (70%)";
      if (vol18 < 1.5 && conf > 80) return "AUMENTADA (120-150%)";
      if (conf > 85) return "NORMAL+ (110%)";
      return "NORMAL";
    }
    function RR(entry, tgt, stop){
      const g = Math.abs(tgt-entry), l = Math.abs(entry-stop);
      return (l>0) ? (g/l) : 0;
    }
    function clusterOK(levels, maxSpreadPts){
      if (levels.length < 2) return false;
      const min = Math.min(...levels), max = Math.max(...levels);
      return (max - min) <= maxSpreadPts;
    }

    function buildSide(side, px, levels, fair, vol18, conf, g18){
      const mode = getTouchMode();
      const pts  = choosePts(vol18);
      const tol  = pts;                       // tolerÃ¢ncia de toque
      const spreadOK = clusterOK(levels, 10); // 3 nÃ­veis dentro de 10 pts

      const levs = levels.slice().sort((a,b)=>a-b);
      const minL = levs[0], maxL = levs[levs.length-1];
      const nearest = levs.reduce((best,lv)=> (Math.abs(px-lv) < Math.abs(px-best)? lv:best), levs[0]);

      const s = {
        side, // "BUY" | "SELL"
        recommendation: "AGUARDAR",
        entryRange: {min: NaN, max: NaN},
        entryRef: NaN,
        stopLoss: NaN,
        target: NaN,
        targetFinal: NaN,
        confidence: conf,
        positionSize: sizeByVol(vol18, conf),
        timeframe: "intraday",
        riskReward: 0,
        preArmNote: "",
        bandsNote: ""
      };

      if (!spreadOK){
        s.entryRange = { min: nearest, max: nearest };
        s.entryRef   = nearest;
      } else {
        s.entryRange = { min: minL, max: maxL };
        s.entryRef   = (minL + maxL)/2;
      }

      // stop 10 pts alÃ©m do Ãºltimo nÃ­vel
      const stop = (side==="BUY") ? (minL - 10) : (maxL + 10);

      // alvo curto 10â15 pts a partir do ref
      const tgt  = (side==="BUY") ? (s.entryRef + pts) : (s.entryRef - pts);

      // alvo final = JustÃ­ssimo quando a direÃ§Ã£o favorece
      const just = fair.justissimo;
      const aFavorDoJust = (side==="BUY"  && just > s.entryRef) ||
                           (side==="SELL" && just < s.entryRef);
      const tgtFinal = aFavorDoJust ? just : tgt;

      s.stopLoss = stop;
      s.target   = tgt;
      s.targetFinal = tgtFinal;

      // condiÃ§Ã£o de âtoque/armadoâ
      const insideRange = (px >= s.entryRange.min - tol) && (px <= s.entryRange.max + tol);

      if (!insideRange){
        const dist = Math.min(Math.abs(px - s.entryRange.min), Math.abs(px - s.entryRange.max));
        const distPts = Math.round(dist); // <<< arredondado
        if (mode === "prearm"){
          s.recommendation = "AGUARDAR";
          s.preArmNote = `A ${distPts} pts da regiÃ£o (${F(s.entryRange.min)}â${F(s.entryRange.max)})`;
        } else {
          s.recommendation = "AGUARDAR";
          s.entryRange = {min: NaN, max: NaN};
          s.entryRef = NaN; s.stopLoss = NaN; s.target = NaN; s.targetFinal = NaN;
          s.preArmNote = `A ${distPts} pts da regiÃ£o`;
        }
      } else {
        s.recommendation = (side==="BUY") ? "COMPRA NA REGIÃO" : "VENDA NA REGIÃO";
      }

      // RR
      if (Number.isFinite(s.entryRef) && Number.isFinite(s.target) && Number.isFinite(s.stopLoss)){
        s.riskReward = RR(s.entryRef, s.target, s.stopLoss);
      }

      // nota de bandas (Â±1Ï) como referÃªncia
      if (g18) {
        if (side==="BUY") s.bandsNote = `ReferÃªncia bandas: -1Ï ${F(g18.down1sigma)} | +1Ï ${F(g18.up1sigma)}`;
        else              s.bandsNote = `ReferÃªncia bandas: +1Ï ${F(g18.up1sigma)} | -1Ï ${F(g18.down1sigma)}`;
      }

      return s;
    }

    // ============ ESTRATÃGIA (2 cards) + OBJETO COMPAT ============
    ts.generateTradingStrategy = function(){
      const fair = getFair();
      const {buys, sells} = getLevels();
      const px   = Number(ts.lastClose()||0) || 0;
      const vol18 = (ts.analyzeSystemVolatility().p18||{}).volatilityPercent || 2.0;
      const conf  = Number(ts.calculateAdvancedConfidenceScore ? ts.calculateAdvancedConfidenceScore() : 60);
      const g18   = (ts.analyzeSystemGARCH()||{}).p18;

      // helpers locais para seleÃ§Ã£o do compat
      function regionDistance(px, s){
        if (!s || !Number.isFinite(s.entryRange?.min) || !Number.isFinite(s.entryRange?.max)) return Infinity;
        const d1 = Math.abs(px - s.entryRange.min);
        const d2 = Math.abs(px - s.entryRange.max);
        return Math.min(d1, d2);
      }
      function centerDist(px, s){
        if (!s || !Number.isFinite(s.entryRange?.min) || !Number.isFinite(s.entryRange?.max)) return Infinity;
        const c = (s.entryRange.min + s.entryRange.max)/2;
        return Math.abs(px - c);
      }
      const isArmed = s => s && typeof s.recommendation==="string" && s.recommendation.includes("REGIÃO");

      // sem dados suficientes
      if (!fair.valid || (!buys.length && !sells.length)) {
        return {
          long: null,
          short: null,
          recommendation: "AGUARDAR",
          direction: null,
          entryZone: {min: NaN, max: NaN},
          target: NaN,
          stopLoss: NaN,
          riskReward: 0
        };
      }

      // monta os dois lados
      const long  = buys.length  ? buildSide("BUY",  px, buys,  fair, vol18, conf, g18)  : null;
      const short = sells.length ? buildSide("SELL", px, sells, fair, vol18, conf, g18) : null;

      // ===== escolhe um lado para o compat =====
      let chosen = null;
      if (isArmed(long) || isArmed(short)){
        const cand = [long, short].filter(isArmed);
        chosen = cand.sort((a,b)=>centerDist(px,a)-centerDist(px,b))[0] || null;
      } else {
        const dL = regionDistance(px,long), dS = regionDistance(px,short);
        chosen = (dL < dS) ? long : short;
      }

      // monta campos compat
      let compat = {
        recommendation: "AGUARDAR",
        direction: null,
        entryZone: {min: NaN, max: NaN},
        target: NaN,
        stopLoss: NaN,
        riskReward: 0
      };
      if (chosen){
        compat.recommendation = isArmed(chosen)
          ? (chosen.side==="BUY" ? "COMPRA NA REGIÃO" : "VENDA NA REGIÃO")
          : "AGUARDAR";
        compat.direction = chosen.side==="BUY" ? "BUY" : "SELL";
        compat.entryZone = { min: chosen.entryRange?.min, max: chosen.entryRange?.max };
        compat.target    = chosen.target;
        compat.stopLoss  = chosen.stopLoss;
        compat.riskReward= chosen.riskReward || 0;
      }

      // devolve os dois cards + o compat na mesma resposta
      return Object.assign(compat, { long, short });
    };

    // ============ PAINEL (dois cards) + Toggle ============
    ts.renderStrategyPanel = function(){
      const out = ts.generateTradingStrategy();
      const op = document.getElementById("aiOperation");
      const rk = document.getElementById("aiRisk");
      const lv = document.getElementById("aiLevels");
      if (!op || !rk || !lv) return;

      const mode = getTouchMode();
      const toggle = `
        <div style="margin:-6px 0 8px 0; display:flex; gap:12px; align-items:center;">
          <label style="font-size:12px; font-weight:700;">Modo:</label>
          <label style="font-size:12px; display:flex; gap:6px; align-items:center; cursor:pointer;">
            <input id="prearmToggle" type="checkbox" ${mode==="prearm"?"checked":""} />
            <span>PrÃ©-armar</span>
          </label>
          <span style="font-size:11px; color:#475569;">(desmarque para exigir toque)</span>
        </div>`;

      function cta(s){
        if (!s) return {title:"Aguardando dados", detail:""};
        const dirTxt = s.side==="BUY" ? "COMPRA" : "VENDA";
        const armed  = s.recommendation.includes("REGIÃO");
        const title  = armed
          ? `â <b>${dirTxt} NA REGIÃO</b> ${F(s.entryRange.min)}â${F(s.entryRange.max)}`
          : `â³ <b>PREPARAR ${dirTxt}</b> ${s.preArmNote ? "â "+s.preArmNote : ""}`;

        const pts = (Number.isFinite(s.entryRef) && Number.isFinite(s.stopLoss))
                      ? Math.abs(s.entryRef - s.stopLoss).toFixed(0) : "--";

        const detail = `
          <span style="display:block;margin-top:4px;">
            ð <b>Gatilho:</b> tocar regiÃ£o ${F(s.entryRange.min)}â${F(s.entryRange.max)} Â·
            ð <b>Stop:</b> ${F(s.stopLoss)} (${pts} pts apÃ³s Ãºltima ${s.side==="BUY"?"mÃ­nima":"mÃ¡xima"}) Â·
            ð¯ <b>Alvo:</b> ${F(s.target)}${(s.targetFinal && s.targetFinal!==s.target) ? ` â ${F(s.targetFinal)}` : ""} Â·
            ð <b>R/R:</b> ${(s.riskReward>0 && Number.isFinite(s.riskReward)) ? ("1:"+s.riskReward.toFixed(2)):"--"}
          </span>
          ${s.bandsNote ? `<span style="display:block;margin-top:4px; font-size:12px; color:#475569;">${s.bandsNote}</span>`:""}
        `;
        return {title, detail};
      }

      const L = cta(out.long), S = cta(out.short);

      // dois cards (verde compra, vermelho venda)
      op.innerHTML = `
        <div class="card-grid">
          <div class="card card-success">
            ${toggle}
            <h4>ð¢ COMPRA â 3 MÃNIMAS</h4>
            <p>${L.title}</p>
            ${L.detail}
            <p style="margin-top:6px;">â³ <b>Prazo:</b> intraday &nbsp; ð <b>ConfianÃ§a:</b> ${out.long? out.long.confidence:"--"}% &nbsp; ð¦ <b>Tamanho:</b> ${out.long? out.long.positionSize:"--"}</p>
          </div>

          <div class="card card-danger">
            <h4>ð´ VENDA â 3 MÃXIMAS</h4>
            <p>${S.title}</p>
            ${S.detail}
            <p style="margin-top:6px;">â³ <b>Prazo:</b> intraday &nbsp; ð <b>ConfianÃ§a:</b> ${out.short? out.short.confidence:"--"}% &nbsp; ð¦ <b>Tamanho:</b> ${out.short? out.short.positionSize:"--"}</p>
          </div>
        </div>
      `;

      // liga o toggle
      const cb = op.querySelector("#prearmToggle");
      if (cb){
        cb.addEventListener("change", ()=>{
          setTouchMode(cb.checked ? "prearm" : "strict");
          try{ ts.renderStrategyPanel(); }catch(_){}
        }, { once:true });
      }

      // GestÃ£o de risco (texto)
      rk.innerHTML = `
        <div class="card-grid">
          <div class="card card-info" style="border-color:#fca5a5; background:linear-gradient(180deg,#fef2f2,#ffffff);">
            <h4>â ï¸ GESTÃO DE RISCO</h4>
            <p>â¢ Trabalhar a <b>regiÃ£o</b> quando as 3 mÃ­nimas/mÃ¡ximas estiverem a â¤10 pts entre si;</p>
            <p>â¢ <b>Stop:</b> 10 pts alÃ©m da Ãºltima mÃ¡xima/mÃ­nima (lado da operaÃ§Ã£o);</p>
            <p>â¢ <b>Alvo curto:</b> 10â15 pts (dinÃ¢mico pela vol 18P); <b>Alvo final:</b> JustÃ­ssimo quando a direÃ§Ã£o favorecer;</p>
            <p>â¢ <b>Break-even:</b> ao atingir +8 pts a favor, mover stop para o preÃ§o de entrada;</p>
            <p>â¢ <b>RuÃ­do:</b> reduzir lote se vol 18P > 3.0%.</p>
          </div>
        </div>
      `;

      // NÃ­veis de decisÃ£o (GARCH 18P) â tipografia do print
const g = (ts.analyzeSystemGARCH()||{}).p18;
const up1 = g?.up1sigma, dn1 = g?.down1sigma;

// helper local para 2 casas (sem mexer em escala)
const F2 = v => (Number.isFinite(v) ? Number(v).toFixed(2) : "--");

lv.innerHTML = `
  <div class="nd-wrap">
    <h4 class="nd-title">ð§· NÃ­veis de DecisÃ£o</h4>
    <div class="nd-row">
      <div class="nd-pill">
        <div class="nd-label red">RESISTÃNCIA FORTE</div>
        <div class="nd-value">${F2(up1)}</div>
      </div>
      <div class="nd-pill">
        <div class="nd-label green">SUPORTE FORTE</div>
        <div class="nd-value">${F2(dn1)}</div>
      </div>
    </div>
  </div>
`;


    };

    // re-render automÃ¡tico
    hookAfter(ts, "performAIAnalysis", ()=>{ try{ ts.renderStrategyPanel(); }catch(_){} });
    hookAfter(ts, "updateAIDisplay",   ()=>{ try{ ts.renderStrategyPanel(); }catch(_){} });
    setTimeout(()=>{ try{ ts.renderStrategyPanel(); }catch(_){} }, 200);
  } // apply(ts)

  function hookAfter(obj, method, after){
    try{
      if (typeof obj[method] !== "function") return;
      const orig = obj[method].bind(obj);
      obj[method] = function(){ const r = orig.apply(obj, arguments); try{ after(); }catch(_){ } return r; };
    }catch(_){}
  }
})();
</script>

	
<style>


  
  /* ââ NÃ­veis de DecisÃ£o (tipografia do print) ââ */
.nd-wrap { background:#eef6ff; border-radius:12px; padding:14px; }
.nd-title { font-weight:800; color:#2563eb; margin:0 0 10px; font-size:14px; display:flex; align-items:center; gap:8px; }
.nd-row { display:grid; grid-template-columns:1fr 1fr; gap:12px; }

.nd-pill {
  background:#fff; border:1px solid #e5e7eb; border-radius:12px;
  padding:12px 10px; text-align:center;
  box-shadow:0 1px 0 rgba(0,0,0,.02);
}
.nd-label { font-weight:900; font-size:12px; letter-spacing:.3px; margin-bottom:6px; }
.nd-label.red { color:#ef4444; }      /* RESISTÃNCIA */
.nd-label.green { color:#059669; }    /* SUPORTE    */
.nd-value { font-size:18px; font-weight:900; color:#0f172a; }
@media(max-width:480px){ .nd-row{ grid-template-columns:1fr; } }

</style>


<!-- ===== BACKTEST GARCH â CONSOLIDADO (V2) ===== -->
<style id="gbStyles-v2">
/* Painel */
#garchBacktestPanel{border:1px solid var(--border,#e5e7eb);border-radius:16px;background:linear-gradient(180deg,#f8fafc,#ffffff);box-shadow:0 1px 3px rgba(0,0,0,.06);margin-top:14px;padding:16px}
#garchBacktestPanel .section-title{display:flex;align-items:center;gap:8px;font-weight:800;font-size:16px;color:#0f172a;margin:10px 0 12px}
#garchBacktestPanel .section-title::before{content:"ð";font-size:18px}
/* Grid: controles (esq) + botÃ£o (dir) */
#garchBacktestPanel .gb-row{display:grid;grid-template-columns:minmax(0,1fr) 230px;gap:14px;align-items:start}
#garchBacktestPanel .gb-col-controls{display:grid;grid-template-columns:1fr;gap:10px}
/* PÃ­lulas */
#garchBacktestPanel .gb-control{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px 10px 12px;box-shadow:0 1px 0 rgba(0,0,0,.03)}
#garchBacktestPanel .gb-control label{display:block;margin:0 0 6px;font-size:11px;letter-spacing:.3px;text-transform:uppercase;color:#475569;font-weight:900}
#garchBacktestPanel .gb-control input,#garchBacktestPanel .gb-control select{width:100%;height:40px;line-height:40px;border:1px solid #e2e8f0;border-radius:10px;padding:0 12px;font-weight:800;color:#0f172a;background:#fff;outline:none;appearance:auto}
#garchBacktestPanel .gb-control input::placeholder{color:#94a3b8;font-weight:600}
#garchBacktestPanel .gb-control input:focus,#garchBacktestPanel .gb-control select:focus{border-color:#93c5fd;box-shadow:0 0 0 3px rgba(59,130,246,.18)}
/* BotÃµes (direita) */
#garchBacktestPanel .gb-buttons{display:flex;flex-direction:column;gap:10px;align-items:stretch}
#garchBacktestPanel #gbRun{height:100%;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#3b82f6,#6366f1);color:#fff;border:none;border-radius:12px;padding:12px 14px;font-weight:900;letter-spacing:.2px;box-shadow:0 6px 16px rgba(59,130,246,.25)}
#garchBacktestPanel #gbRun:hover{transform:translateY(-1px);box-shadow:0 8px 20px rgba(59,130,246,.30)}
#garchBacktestPanel #gbExport{background:#fff;border:1px solid #e5e7eb;color:#0f172a;border-radius:12px;padding:12px 14px;font-weight:800;white-space:nowrap}
#garchBacktestPanel #gbExport:disabled{opacity:.5;cursor:not-allowed}
/* Resumo e tabela */
#garchBacktestPanel .gb-summary{background:#f1f5f9;border:1px dashed #cbd5e1;border-radius:12px;padding:10px 12px;font-size:13px;color:#334155}
#garchBacktestPanel .gb-table-wrap{max-height:340px;overflow:auto;border:1px solid #e5e7eb;border-radius:12px;background:#fff}
#garchBacktestPanel .gb-table{width:100%;border-collapse:separate;border-spacing:0}
#garchBacktestPanel .gb-table thead th{position:sticky;top:0;z-index:1;background:#fff;border-bottom:1px solid #e5e7eb;font-weight:900;font-size:12px;color:#334155;padding:10px 12px}
#garchBacktestPanel .gb-table td{padding:10px 12px;font-size:12px;color:#0f172a}
#garchBacktestPanel .gb-table tbody tr:nth-child(odd){background:#f9fafb}
#garchBacktestPanel .gb-table tbody tr:hover{background:#eef2ff}
/* Badges */
.gb-badge{display:inline-block;padding:3px 8px;border-radius:999px;font-weight:900;font-size:11px}
.gb-badge.buy{background:#dcfce7;color:#065f46}.gb-badge.sell{background:#fee2e2;color:#991b1b}.gb-badge.win{background:#e0f2fe;color:#075985}.gb-badge.loss{background:#fee2e2;color:#991b1b}
/* Responsivo */
@media (max-width:760px){#garchBacktestPanel .gb-row{grid-template-columns:1fr}#garchBacktestPanel .gb-buttons{flex-direction:row}#garchBacktestPanel #gbRun{height:auto}}
</style>

<script>
(() => {
  // evita duplicar
  if (window.__GB_BACKTEST_V2__) return; window.__GB_BACKTEST_V2__ = true;

  // instala quando o app existir
  const boot = setInterval(() => { const ts = window.tradingSystem; if (!ts) return; clearInterval(boot); install(ts); }, 100);

  function install(ts){
    const anchor = document.getElementById("aiStrategyPanel") || document.getElementById("ai-analysis-panel") || document.getElementById("proj-panel") || document.body;

    // limpa versÃµes antigas do painel
    document.querySelectorAll("#garchBacktestPanel").forEach(n => n.remove());

    const wrap = document.createElement("div");
    wrap.id = "garchBacktestPanel";
    wrap.className = "panel";
    wrap.innerHTML = `
      <h2 class="section-title">Backtest (GARCH)</h2>
      <div class="gb-row">
        <div class="gb-col-controls">
          <div class="gb-control"><label>Janela (barras)</label><input id="gbWindow" type="number" min="20" step="10" placeholder="ex.: 60 (vazio = tudo)" /></div>
          <div class="gb-control"><label>Look-ahead (barras)</label><input id="gbLook" type="number" min="1" step="1" value="5" /></div>
          <div class="gb-control"><label>Usar alvo final (JustÃ­ssimo)</label>
            <select id="gbUseFair"><option value="no" selected>NÃ£o (sÃ³ alvo curto)</option><option value="yes">Sim (se favorecer)</option></select>
          </div>
        </div>
        <div class="gb-buttons">
          <button class="btn ai" id="gbRun">â¶ï¸ Rodar Backtest</button>
          <button class="btn" id="gbExport" disabled>â¬ï¸ Exportar CSV</button>
        </div>
      </div>
      <div class="gb-summary" id="gbSummary">Aguardando execuÃ§Ã£oâ¦</div>
      <div class="gb-table-wrap">
        <table class="gb-table">
          <thead><tr><th>#</th><th>Data/Idx</th><th>Lado</th><th>Entrada</th><th>Alvo</th><th>Stop</th><th>Resultado</th><th>P/L (pts)</th></tr></thead>
          <tbody id="gbTbody"></tbody>
        </table>
      </div>`;
    anchor.insertAdjacentElement("afterend", wrap);

    // defaults UX
    const w = document.getElementById("gbWindow"), l = document.getElementById("gbLook"), s = document.getElementById("gbUseFair");
    if (w && (!w.value || Number(w.value)<=0)) w.value = "60";
    if (l && (!l.value || Number(l.value)<=0)) l.value = "5";
    if (s && !s.value) s.value = "no";

    document.getElementById("gbRun").addEventListener("click", () => runGarchBacktest(ts));
    document.getElementById("gbExport").addEventListener("click", exportCSV);
  }

  /* ===== CÃ¡lculo ===== */
  const F2 = x => Number.isFinite(x) ? Number(x).toFixed(2) : "--";
  const PTSI = x => Number.isFinite(x) ? Math.round(x) : 0;
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }
  function vol18At(ts,start,idx){ const run = ts.linearReturns.slice(start, idx); if (run.length<18) return 2.0;
    const s = run.slice(-18), m = s.reduce((a,b)=>a+b,0)/s.length, v = s.reduce((q,r)=>q+Math.pow(r-m,2),0)/s.length; return Math.sqrt(v)*100; }
  function expLevels(ts,i){ const out={min:[],max:[]}, lc = ts.priceData[i];
    for (const p of [9,18,27]){ if (ts.linearReturns.length < p || i < p) continue;
      const sl = ts.linearReturns.slice(i-p,i), m=sl.reduce((a,b)=>a+b,0)/sl.length, v=sl.reduce((q,r)=>q+Math.pow(r-m,2),0)/sl.length, sd=Math.sqrt(v);
      const ef = ts.getExpFor ? ts.getExpFor(p) : 2.718, ex = Math.pow(ef, sd); out.max.push(lc*ex); out.min.push(lc/ex); } return out; }
  function distToRange(px,a,b){ const lo=Math.min(a,b), hi=Math.max(a,b); if(px<lo) return lo-px; if(px>hi) return px-hi; return 0; }
  function clusterRegion(levels,spread,px){ const lv=(levels||[]).filter(Number.isFinite).slice().sort((a,b)=>a-b); if(!lv.length) return null;
    const min=lv[0], max=lv[lv.length-1]; if(lv.length>=2 && (max-min)<=spread) return {min,max,ref:(min+max)/2,isCluster:true};
    const nearest=lv.reduce((best,cur)=>Math.abs(px-cur)<Math.abs(px-best)?cur:best,lv[0]); return {min:nearest,max:nearest,ref:nearest,isCluster:false}; }
  function fairCombined(ts,price){ const g=id=>document.getElementById(id);
    const pppRate=parseFloat(g('ppp_rate')?.value||5.30), infBR=parseFloat(g('inflation_br')?.value||4.5)/100, infUS=parseFloat(g('inflation_us')?.value||3.2)/100,
          selic=parseFloat(g('selic_rate')?.value||13.75)/100, fed=parseFloat(g('fed_rate')?.value||5.50)/100, risk=parseFloat(g('risk_premium')?.value||2.5)/100;
    let ppp=pppRate; if(price>100) ppp=pppRate*1000; const fairPPP=ppp*((1+infBR)/(1+infUS)), net=(selic-fed)-risk, uip=1+(net*0.15), fairUIP=price*uip;
    const bounded=Math.max(price*0.8,Math.min(price*1.2,fairUIP)), comb=0.4*fairPPP+0.6*bounded; return Math.max(price*0.75,Math.min(price*1.25,comb)); }

  function runGarchBacktest(ts){
    const sum = document.getElementById("gbSummary"), tb = document.getElementById("gbTbody"), btn = document.getElementById("gbExport");
    if (!ts.priceData || ts.priceData.length<30){ sum.textContent="Carregue â¥ 30 preÃ§os (Excel/Simulado) e rode AnÃ¡lise."; return; }
    ts.calculateLinearReturns();

    const N = parseInt(document.getElementById("gbWindow")?.value||0,10);
    const LH = Math.max(1, parseInt(document.getElementById("gbLook")?.value||5,10));
    const USE_FAIR = (document.getElementById("gbUseFair")?.value==="yes");
    const start = (N>0 && N<ts.priceData.length) ? (ts.priceData.length - N) : 0;

    const spread=10, log=[], res={BUY:{win:0,loss:0,pl:0,trades:0}, SELL:{win:0,loss:0,pl:0,trades:0}};
    let cNoLv=0, cNoIn=0;

    for (let i=start+27; i<ts.priceData.length-1; i++){
      const px=ts.priceData[i], vol=vol18At(ts,start,i), pts=choosePts(vol), lv=expLevels(ts,i);
      if (!lv.min.length && !lv.max.length){ cNoLv++; continue; }

      const rB=clusterRegion(lv.min,spread,px), rS=clusterRegion(lv.max,spread,px);
      const cand=[];
      if (rB){ const d=distToRange(px, rB.min-pts, rB.max+pts); if (d<=pts){ let tgt=rB.ref+pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j>rB.ref) tgt=j; }
        cand.push({dir:"BUY",idx:i,entry:rB.ref,stop:rB.min-10,tgt,pts}); } }
      if (rS){ const d=distToRange(px, rS.min-pts, rS.max+pts); if (d<=pts){ let tgt=rS.ref-pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j<rS.ref) tgt=j; }
        cand.push({dir:"SELL",idx:i,entry:rS.ref,stop:rS.max+10,tgt,pts}); } }
      if (!cand.length){ cNoIn++; continue; }

      for (const tr of cand){
        let outcome="NEUTRO", pl=0;
        for (let k=1; k<=LH && (i+k)<ts.priceData.length; k++){
          const pN=ts.priceData[i+k];
          if (tr.dir==="BUY"){ if (pN>=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.tgt-tr.entry); break; }
                               if (pN<=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.entry-tr.stop); break; } }
          else               { if (pN<=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.entry-tr.tgt); break; }
                               if (pN>=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.stop-tr.entry); break; } }
        }
        if (outcome==="NEUTRO"){ const last=ts.priceData[i+LH] ?? ts.priceData[ts.priceData.length-1]; pl=(tr.dir==="BUY")?(last-tr.entry):(tr.entry-last); }
        if (outcome==="WIN") res[tr.dir].win++; if (outcome==="LOSS") res[tr.dir].loss++; res[tr.dir].trades++; res[tr.dir].pl+=pl;
        log.push({n:log.length+1,idx:tr.idx,side:tr.dir,entry:tr.entry,tgt:tr.tgt,stop:tr.stop,outcome,pl});
      }
    }
    renderResult(res, log, cNoLv, cNoIn);
  }

  function renderResult(res,log,cNoLv,cNoIn){
    const sum=document.getElementById("gbSummary"), tb=document.getElementById("gbTbody"), btn=document.getElementById("gbExport"); tb.innerHTML="";
    const met = d => { const hit=d.trades? (d.win/d.trades)*100 : 0; const avg=d.trades? (d.pl/d.trades) : 0; const rr=Math.abs(avg)/12 || 0;
      return {trades:d.trades, win:d.win, loss:d.loss, hit:hit.toFixed(1)+"%", pl:PTSI(d.pl), rr:rr.toFixed(2)+"x"}; };
    const B=met(res.BUY), S=met(res.SELL);
    sum.innerHTML = `<b>Resultado:</b>
      <br>ð¢ BUY â trades: <b>${B.trades}</b> | win: <b>${B.win}</b> | loss: <b>${B.loss}</b> | hit: <b>${B.hit}</b> | P/L: <b>${B.pl} pts</b> | R/R efetivo: <b>${B.rr}</b>
      <br>ð´ SELL â trades: <b>${S.trades}</b> | win: <b>${S.win}</b> | loss: <b>${S.loss}</b> | hit: <b>${S.hit}</b> | P/L: <b>${S.pl} pts</b> | R/R efetivo: <b>${S.rr}</b>
      ${(B.trades+S.trades===0)?`<div style="margin-top:8px;font-size:12px;color:#334155"><b>DiagnÃ³stico</b>: sem nÃ­veis em ${cNoLv} barras; fora da regiÃ£o em ${cNoIn} barras. Tente Janela=60, Look-ahead=5.</div>`:""}`;
    for (const r of log){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${r.n}</td><td>${r.idx}</td>
        <td><span class="gb-badge ${r.side==='BUY'?'buy':'sell'}">${r.side}</span></td>
        <td>${F2(r.entry)}</td><td>${F2(r.tgt)}</td><td>${F2(r.stop)}</td>
        <td><span class="gb-badge ${r.outcome==='WIN'?'win':(r.outcome==='LOSS'?'loss':'')}">${r.outcome}</span></td>
        <td>${PTSI(r.pl)}</td>`;
      tb.appendChild(tr);
    }
    btn.disabled = (log.length===0); btn.dataset.csv = JSON.stringify(log);
  }

  function exportCSV(e){
    const data = JSON.parse(e.currentTarget.dataset.csv || "[]"); if (!data.length) return;
    const header=["n","idx","side","entry","tgt","stop","outcome","pl"];
    const lines=[header.join(",")].concat(data.map(r=>[r.n,r.idx,r.side,F2(r.entry),F2(r.tgt),F2(r.stop),r.outcome,PTSI(r.pl)].join(",")));
    const blob=new Blob([lines.join("\n")],{type:"text/csv;charset=utf-8;"}), url=URL.createObjectURL(blob), a=document.createElement("a");
    a.href=url; a.download="backtest_garch.csv"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }
})();
</script>
<script>
(() => {
  // SÃ³ roda se o V2 estiver instalado
  if (!window.__GB_BACKTEST_V2__) return;

  // Sobrescreve apenas o executor para usar tol/spread âamigÃ¡veisâ
  const ts = window.tradingSystem;
  if (!ts) return;

  // === Helpers (mesmos do V2) ===
  const F2 = x => Number.isFinite(x) ? Number(x).toFixed(2) : "--";
  const PTSI = x => Number.isFinite(x) ? Math.round(x) : 0;
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }
  function vol18At(ts,start,idx){ const run=ts.linearReturns.slice(start,idx); if(run.length<18) return 2.0;
    const s=run.slice(-18), m=s.reduce((a,b)=>a+b,0)/s.length, v=s.reduce((q,r)=>q+Math.pow(r-m,2),0)/s.length; return Math.sqrt(v)*100; }
  function expLevels(ts,i){ const out={min:[],max:[]}, lc=ts.priceData[i];
    for(const p of [9,18,27]){ if(ts.linearReturns.length<p||i<p) continue;
      const sl=ts.linearReturns.slice(i-p,i), m=sl.reduce((a,b)=>a+b,0)/sl.length, v=sl.reduce((q,r)=>q+Math.pow(r-m,2),0)/sl.length, sd=Math.sqrt(v);
      const ef=ts.getExpFor?ts.getExpFor(p):2.718, ex=Math.pow(ef,sd); out.max.push(lc*ex); out.min.push(lc/ex); } return out; }
  function distToRange(px,a,b){ const lo=Math.min(a,b), hi=Math.max(a,b); if(px<lo) return lo-px; if(px>hi) return px-hi; return 0; }
  function clusterRegion(levels,spread,px){ const lv=(levels||[]).filter(Number.isFinite).slice().sort((a,b)=>a-b); if(!lv.length) return null;
    const min=lv[0], max=lv[lv.length-1]; if(lv.length>=2&&(max-min)<=spread) return {min,max,ref:(min+max)/2,isCluster:true};
    const nearest=lv.reduce((best,cur)=> Math.abs(px-cur)<Math.abs(px-best)?cur:best, lv[0]); return {min:nearest,max:nearest,ref:nearest,isCluster:false}; }
  function fairCombined(ts,price){ const g=id=>document.getElementById(id);
    const pppRate=parseFloat(g('ppp_rate')?.value||5.30), infBR=parseFloat(g('inflation_br')?.value||4.5)/100, infUS=parseFloat(g('inflation_us')?.value||3.2)/100,
          selic=parseFloat(g('selic_rate')?.value||13.75)/100, fed=parseFloat(g('fed_rate')?.value||5.50)/100, risk=parseFloat(g('risk_premium')?.value||2.5)/100;
    let ppp=pppRate; if(price>100) ppp=pppRate*1000; const fairPPP=ppp*((1+infBR)/(1+infUS)), net=(selic-fed)-risk, uip=1+(net*0.15), fairUIP=price*uip;
    const bounded=Math.max(price*0.8,Math.min(price*1.2,fairUIP)), comb=0.4*fairPPP+0.6*bounded; return Math.max(price*0.75,Math.min(price*1.25,comb)); }

  // Novo runner âamigÃ¡velâ
  function runGarchBacktestSoft(ts){
    const sum=document.getElementById("gbSummary"), tb=document.getElementById("gbTbody"), btn=document.getElementById("gbExport");
    if(!ts.priceData || ts.priceData.length<30){ sum.textContent="Carregue â¥ 30 preÃ§os (Excel/Simulado) e rode AnÃ¡lise."; return; }
    ts.calculateLinearReturns();

    const N=parseInt(document.getElementById("gbWindow")?.value||0,10);
    const LH=Math.max(1,parseInt(document.getElementById("gbLook")?.value||5,10));
    const USE_FAIR=(document.getElementById("gbUseFair")?.value==="yes");

    const start=(N>0 && N<ts.priceData.length)? (ts.priceData.length-N) : 0;
    const usedBars = ts.priceData.length - start;

    const spread=12; // (antes 10)
    const log=[], res={BUY:{win:0,loss:0,pl:0,trades:0}, SELL:{win:0,loss:0,pl:0,trades:0}};
    let cNoLv=0, cNoIn=0;

    for(let i=start+27;i<ts.priceData.length-1;i++){
      const px=ts.priceData[i], vol=vol18At(ts,start,i), pts=choosePts(vol), tol=15; // (antes tol=pts)
      const lv=expLevels(ts,i); if(!lv.min.length && !lv.max.length){ cNoLv++; continue; }

      const rB=clusterRegion(lv.min,spread,px), rS=clusterRegion(lv.max,spread,px);
      const cand=[];

      if(rB){
        const d=distToRange(px, rB.min - tol, rB.max + tol);
        if(d<=tol){
          const stop=rB.min-10; let tgt=rB.ref+pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j>rB.ref) tgt=j; }
          cand.push({dir:"BUY",idx:i,entry:rB.ref,stop,tgt});
        }
      }
      if(rS){
        const d=distToRange(px, rS.min - tol, rS.max + tol);
        if(d<=tol){
          const stop=rS.max+10; let tgt=rS.ref-pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j<rS.ref) tgt=j; }
          cand.push({dir:"SELL",idx:i,entry:rS.ref,stop,tgt});
        }
      }
      if(!cand.length){ cNoIn++; continue; }

      for(const tr of cand){
        let outcome="NEUTRO", pl=0;
        for(let k=1;k<=LH && (i+k)<ts.priceData.length;k++){
          const p=ts.priceData[i+k];
          if(tr.dir==="BUY"){ if(p>=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.tgt-tr.entry); break; }
                              if(p<=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.entry-tr.stop); break; } }
          else              { if(p<=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.entry-tr.tgt); break; }
                              if(p>=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.stop-tr.entry); break; } }
        }
        if(outcome==="NEUTRO"){ const last=ts.priceData[i+LH] ?? ts.priceData[ts.priceData.length-1]; pl=(tr.dir==="BUY")?(last-tr.entry):(tr.entry-last); }
        if(outcome==="WIN") res[tr.dir].win++; if(outcome==="LOSS") res[tr.dir].loss++; res[tr.dir].trades++; res[tr.dir].pl+=pl;
        log.push({n:log.length+1,idx:tr.idx,side:tr.dir,entry:tr.entry,tgt:tr.tgt,stop:tr.stop,outcome,pl});
      }
    }

    // resumo + barras usadas
    const met=d=>{const hit=d.trades?(d.win/d.trades)*100:0, avg=d.trades?(d.pl/d.trades):0, rr=Math.abs(avg)/12||0;
      return {trades:d.trades, win:d.win, loss:d.loss, hit:hit.toFixed(1)+"%", pl:PTSI(d.pl), rr:rr.toFixed(2)+"x"};};
    const B=met(res.BUY), S=met(res.SELL);
    sum.innerHTML = `<b>Resultado (barras usadas: ${usedBars})</b>
      <br>ð¢ BUY â trades: <b>${B.trades}</b> | win: <b>${B.win}</b> | loss: <b>${B.loss}</b> | hit: <b>${B.hit}</b> | P/L: <b>${B.pl} pts</b> | R/R efetivo: <b>${B.rr}</b>
      <br>ð´ SELL â trades: <b>${S.trades}</b> | win: <b>${S.win}</b> | loss: <b>${S.loss}</b> | hit: <b>${S.hit}</b> | P/L: <b>${S.pl} pts</b> | R/R efetivo: <b>${S.rr}</b>
      ${(B.trades+S.trades===0)?`<div style="margin-top:8px;font-size:12px;color:#334155"><b>DiagnÃ³stico</b>: sem nÃ­veis em ${cNoLv} barras; fora da regiÃ£o em ${cNoIn} barras.</div>`:""}`;

    const tb=document.getElementById("gbTbody"); tb.innerHTML="";
    for(const r of log){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${r.n}</td><td>${r.idx}</td>
        <td><span class="gb-badge ${r.side==='BUY'?'buy':'sell'}">${r.side}</span></td>
        <td>${F2(r.entry)}</td><td>${F2(r.tgt)}</td><td>${F2(r.stop)}</td>
        <td><span class="gb-badge ${r.outcome==='WIN'?'win':(r.outcome==='LOSS'?'loss':'')}">${r.outcome}</span></td>
        <td>${PTSI(r.pl)}</td>`;
      tb.appendChild(tr);
    }
    const btn=document.getElementById("gbExport"); btn.disabled=(log.length===0); btn.dataset.csv=JSON.stringify(log);
  }

  // pluga o botÃ£o no runner âsoftâ
  const runBtn=document.getElementById("gbRun"); if(runBtn){ runBtn.onclick=()=>runGarchBacktestSoft(ts); }
})();
</script>


<!-- ===== FIM BACKTEST GARCH â CONSOLIDADO (V2) ===== -->

<!-- ===== NORMALIZADOR DE LAYOUT â BACKTEST (apenas 1x) ===== -->
<script>
(() => {
  // 1) Desativa estilos antigos que conflitam
  const badIds = [
    "gbStyles","gbStyles-polish","gbStyles-unified","gbStyles-unified-v2",
    "gbStyles-compact","gbStyles-stack","gbStyles-clean",
    "gbStyles-hotfix","gbStyles-hotfix-final","final-ui-fix","gbStyles-v2-tune"
  ];
  badIds.forEach(id => document.getElementById(id)?.remove());

  // Remove qualquer <style> inline que contenha regras antigas de '.level-col'
  Array.from(document.querySelectorAll("style")).forEach(st => {
    const txt = (st.textContent || "").toLowerCase();
    if (txt.includes(".level-col ")) st.remove();
  });

  // 2) Normaliza a estrutura do painel (coluna de controles + coluna do botÃ£o)
  const panel = document.getElementById("garchBacktestPanel");
  if (panel){
    const row = panel.querySelector(".gb-row") || panel.querySelector(".gbRow");
    if (row){
      // cria/garante a coluna de controles
      let col = row.querySelector(".gb-col-controls");
      if (!col){
        col = document.createElement("div");
        col.className = "gb-col-controls";
        row.insertBefore(col, row.firstChild);
      }
      // move todos os .gb-control para a coluna (deixa .gb-buttons de fora)
      Array.from(row.querySelectorAll(".gb-control")).forEach(ctrl => {
        if (ctrl.parentElement !== col) col.appendChild(ctrl);
      });

      // afrouxa qualquer sticky/altura da coluna de botÃµes
      const buttons = row.querySelector(".gb-buttons");
      if (buttons){
        buttons.style.position = "static";
        buttons.style.height   = "auto";
        buttons.style.display  = "flex";
        buttons.style.flexDirection = "column";
        buttons.style.gap = "10px";
        // botÃ£o em altura natural
        const run = buttons.querySelector("#gbRun");
        if (run){ run.style.height = "auto"; run.textContent = "â¶ï¸ Rodar Backtest"; }
      }
    }
  }
})();
</script>

<style id="gbStyles-final">
/* === Grid estÃ¡vel: controles (esq) + botÃ£o (dir) === */
#garchBacktestPanel .gb-row{
  display:grid !important;
  grid-template-columns: minmax(0,1fr) 230px !important;
  gap:16px !important;
  align-items:start !important;
}
#garchBacktestPanel .gb-col-controls{
  display:grid !important;
  grid-template-columns: 1fr !important; /* um embaixo do outro */
  gap:10px !important;
}

/* === PÃ­lulas de controle (compactas) === */
#garchBacktestPanel .gb-control{
  background:#fff !important;
  border:1px solid #e5e7eb !important;
  border-radius:12px !important;
  padding:10px 12px !important;
  box-shadow:0 1px 0 rgba(0,0,0,.03) !important;
}
#garchBacktestPanel .gb-control label{
  display:block !important;
  margin:0 0 6px !important;
  font-size:11px !important;
  letter-spacing:.3px !important;
  text-transform:uppercase !important;
  font-weight:900 !important;
  color:#475569 !important;
}
#garchBacktestPanel .gb-control input,
#garchBacktestPanel .gb-control select{
  width:100% !important;
  height:40px !important; line-height:40px !important;
  border:1px solid #e2e8f0 !important;
  border-radius:10px !important;
  padding:0 12px !important;
  background:#fff !important; color:#0f172a !important;
  font-weight:800 !important; outline:none !important; appearance:auto !important;
}
#garchBacktestPanel .gb-control input::placeholder{ color:#94a3b8; font-weight:600; }

/* === Coluna de botÃµes (direita) â sem sticky nem 100% de altura === */
#garchBacktestPanel .gb-buttons{
  position: static !important;
  display:flex !important; flex-direction:column !important;
  gap:10px !important; align-items:stretch !important;
  height:auto !important;
}
#garchBacktestPanel #gbRun{
  height:auto !important;
  background:linear-gradient(135deg,#3b82f6,#6366f1) !important;
  color:#fff !important; border:none !important; border-radius:12px !important;
  padding:12px 14px !important; font-weight:900 !important;
  box-shadow:0 6px 16px rgba(59,130,246,.25) !important;
}

/* === Tipos dentro dos painÃ©is (fontes contidas) === */
#aiStrategyPanel .card, #aiStrategyPanel .insight-card { font-size:13px !important; }
#aiStrategyPanel h4 { font-size:14px !important; margin:0 0 6px !important; }
#aiStrategyPanel .value { font-size:16px !important; }

/* NÃ­veis de DecisÃ£o (nd-*) */
.nd-label { font-size:12px !important; }
.nd-value { font-size:16px !important; }

/* Tabela do backtest */
#garchBacktestPanel .gb-table td,
#garchBacktestPanel .gb-table thead th { font-size:12px !important; }

/* Responsivo */
@media (max-width:760px){
  #garchBacktestPanel .gb-row{ grid-template-columns:1fr !important; }
  #garchBacktestPanel .gb-buttons{ flex-direction:row !important; }
  #garchBacktestPanel #gbRun{ height:auto !important; }
}
</style>
<script>
/* Force o botÃ£o a usar o runner soft assim que o painel existir */
(() => {
  function attachSoftRunner(){
    const ts  = window.tradingSystem;
    const btn = document.getElementById("gbRun");
    if (!ts || !btn){ setTimeout(attachSoftRunner, 150); return; }

    // === helpers iguais aos do bloco soft jÃ¡ existente ===
    const F2 = x => Number.isFinite(x) ? Number(x).toFixed(2) : "--";
    const PTSI = x => Number.isFinite(x) ? Math.round(x) : 0;
    function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }
    function vol18At(ts,start,idx){ const run=ts.linearReturns.slice(start,idx); if(run.length<18) return 2.0;
      const s=run.slice(-18), m=s.reduce((a,b)=>a+b,0)/s.length, v=s.reduce((q,r)=>q+Math.pow(r-m,2),0)/s.length; return Math.sqrt(v)*100; }
    function expLevels(ts,i){ const out={min:[],max:[]}, lc=ts.priceData[i];
      for(const p of [9,18,27]){ if(ts.linearReturns.length<p||i<p) continue;
        const sl=ts.linearReturns.slice(i-p,i), m=sl.reduce((a,b)=>a+b,0)/sl.length, v=sl.reduce((q,r)=>q+Math.pow(r-m,2),0)/sl.length, sd=Math.sqrt(v);
        const ef=ts.getExpFor?ts.getExpFor(p):2.718, ex=Math.pow(ef,sd); out.max.push(lc*ex); out.min.push(lc/ex); } return out; }
    function distToRange(px,a,b){ const lo=Math.min(a,b), hi=Math.max(a,b); if(px<lo) return lo-px; if(px>hi) return px-hi; return 0; }
    function clusterRegion(levels,spread,px){ const lv=(levels||[]).filter(Number.isFinite).slice().sort((a,b)=>a-b); if(!lv.length) return null;
      const min=lv[0], max=lv[lv.length-1]; if(lv.length>=2&&(max-min)<=spread) return {min,max,ref:(min+max)/2,isCluster:true};
      const nearest=lv.reduce((best,cur)=> Math.abs(px-cur)<Math.abs(px-best)?cur:best, lv[0]); return {min:nearest,max:nearest,ref:nearest,isCluster:false}; }
    function fairCombined(ts,price){ const g=id=>document.getElementById(id);
      const pppRate=parseFloat(g('ppp_rate')?.value||5.30), infBR=parseFloat(g('inflation_br')?.value||4.5)/100, infUS=parseFloat(g('inflation_us')?.value||3.2)/100,
            selic=parseFloat(g('selic_rate')?.value||13.75)/100, fed=parseFloat(g('fed_rate')?.value||5.50)/100, risk=parseFloat(g('risk_premium')?.value||2.5)/100;
      let ppp=pppRate; if(price>100) ppp=pppRate*1000; const fairPPP=ppp*((1+infBR)/(1+infUS)), net=(selic-fed)-risk, uip=1+(net*0.15), fairUIP=price*uip;
      const bounded=Math.max(price*0.8,Math.min(price*1.2,fairUIP)), comb=0.4*fairPPP+0.6*bounded; return Math.max(price*0.75,Math.min(price*1.25,comb)); }

    function runSoft(){
      const sum=document.getElementById("gbSummary"), tb=document.getElementById("gbTbody"), csv=document.getElementById("gbExport");
      if(!ts.priceData || ts.priceData.length<30){ sum.textContent="Carregue â¥ 30 preÃ§os (Excel/Simulado) e rode AnÃ¡lise."; return; }
      ts.calculateLinearReturns();

      const N = parseInt(document.getElementById("gbWindow")?.value||0,10);
      const LH = Math.max(1, parseInt(document.getElementById("gbLook")?.value||5,10));
      const USE_FAIR = (document.getElementById("gbUseFair")?.value==="yes");
      const start = (N>0 && N<ts.priceData.length)? (ts.priceData.length-N) : 0;
      const usedBars = ts.priceData.length - start;

      const spread=12, tol=15; // mais âamigÃ¡veisâ p/ janelas grandes
      const log=[], res={BUY:{win:0,loss:0,pl:0,trades:0}, SELL:{win:0,loss:0,pl:0,trades:0}};
      let cNoLv=0, cNoIn=0;

      for(let i=start+27;i<ts.priceData.length-1;i++){
        const px=ts.priceData[i], vol=vol18At(ts,start,i), pts=choosePts(vol), lv=expLevels(ts,i);
        if(!lv.min.length && !lv.max.length){ cNoLv++; continue; }
        const rB=clusterRegion(lv.min,spread,px), rS=clusterRegion(lv.max,spread,px);
        const cand=[];
        if(rB){ const d=distToRange(px, rB.min-tol, rB.max+tol); if(d<=tol){ let tgt=rB.ref+pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j>rB.ref) tgt=j; }
          cand.push({dir:"BUY",idx:i,entry:rB.ref,stop:rB.min-10,tgt}); } }
        if(rS){ const d=distToRange(px, rS.min-tol, rS.max+tol); if(d<=tol){ let tgt=rS.ref-pts; if(USE_FAIR){ const j=fairCombined(ts,px); if(j<rS.ref) tgt=j; }
          cand.push({dir:"SELL",idx:i,entry:rS.ref,stop:rS.max+10,tgt}); } }
        if(!cand.length){ cNoIn++; continue; }

        for(const tr of cand){
          let outcome="NEUTRO", pl=0;
          for(let k=1;k<=LH && (i+k)<ts.priceData.length;k++){
            const p=ts.priceData[i+k];
            if(tr.dir==="BUY"){ if(p>=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.tgt-tr.entry); break; }
                                if(p<=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.entry-tr.stop); break; } }
            else              { if(p<=tr.tgt){ outcome="WIN";  pl=Math.abs(tr.entry-tr.tgt); break; }
                                if(p>=tr.stop){ outcome="LOSS"; pl=-Math.abs(tr.stop-tr.entry); break; } }
          }
          if(outcome==="NEUTRO"){ const last=ts.priceData[i+LH] ?? ts.priceData[ts.priceData.length-1]; pl=(tr.dir==="BUY")?(last-tr.entry):(tr.entry-last); }
          if(outcome==="WIN") res[tr.dir].win++; if(outcome==="LOSS") res[tr.dir].loss++; res[tr.dir].trades++; res[tr.dir].pl+=pl;
          log.push({n:log.length+1,idx:tr.idx,side:tr.dir,entry:tr.entry,tgt:tr.tgt,stop:tr.stop,outcome,pl});
        }
      }

      const met=d=>{const hit=d.trades?(d.win/d.trades)*100:0, avg=d.trades?(d.pl/d.trades):0, rr=Math.abs(avg)/12||0;
        return {trades:d.trades, win:d.win, loss:d.loss, hit:hit.toFixed(1)+"%", pl:PTSI(d.pl), rr:rr.toFixed(2)+"x"};};
      const B=met(res.BUY), S=met(res.SELL);
      sum.innerHTML = `<b>Resultado (barras usadas: ${usedBars})</b>
        <br>ð¢ BUY â trades: <b>${B.trades}</b> | win: <b>${B.win}</b> | loss: <b>${B.loss}</b> | hit: <b>${B.hit}</b> | P/L: <b>${B.pl} pts</b> | R/R efetivo: <b>${B.rr}</b>
        <br>ð´ SELL â trades: <b>${S.trades}</b> | win: <b>${S.win}</b> | loss: <b>${S.loss}</b> | hit: <b>${S.hit}</b> | P/L: <b>${S.pl} pts</b> | R/R efetivo: <b>${S.rr}</b>`;
      tb.innerHTML="";
      for(const r of log){
        const tr=document.createElement("tr");
        tr.innerHTML = `<td>${r.n}</td><td>${r.idx}</td>
          <td><span class="gb-badge ${r.side==='BUY'?'buy':'sell'}">${r.side}</span></td>
          <td>${F2(r.entry)}</td><td>${F2(r.tgt)}</td><td>${F2(r.stop)}</td>
          <td><span class="gb-badge ${r.outcome==='WIN'?'win':(r.outcome==='LOSS'?'loss':'')}">${r.outcome}</span></td>
          <td>${PTSI(r.pl)}</td>`;
        tb.appendChild(tr);
      }
      csv.disabled = (log.length===0);
      csv.dataset.csv = JSON.stringify(log);
    }

    btn.onclick = runSoft; // agora substitui com certeza
  }
  attachSoftRunner();
})();
</script>

<style id="gbLayout-final">
#garchBacktestPanel .gb-row{display:grid !important;grid-template-columns:minmax(0,1fr) 230px !important;gap:16px !important;align-items:start !important;}
#garchBacktestPanel .gb-col-controls{display:grid !important;grid-template-columns:1fr !important;gap:10px !important;}
#garchBacktestPanel .gb-buttons{position:static !important;display:flex !important;flex-direction:column !important;gap:10px !important;align-items:stretch !important;height:auto !important;}
#garchBacktestPanel #gbRun{height:auto !important;}
/* Tipografia contida dentro dos painÃ©is */
#aiStrategyPanel .card, #aiStrategyPanel .insight-card{font-size:13px !important;}
#aiStrategyPanel h4{font-size:14px !important;margin:0 0 6px !important;}
#aiStrategyPanel .value{font-size:16px !important;}
.nd-label{font-size:12px !important;}
.nd-value{font-size:16px !important;}
#garchBacktestPanel .gb-table td, #garchBacktestPanel .gb-table thead th{font-size:12px !important;}
@media (max-width:760px){#garchBacktestPanel .gb-row{grid-template-columns:1fr !important}#garchBacktestPanel .gb-buttons{flex-direction:row !important}}
</style>
<script>
/* Backtest Layout â normaliza DOM e coloca botÃµes onde vocÃª preferir */
(() => {
  const panel = document.getElementById("garchBacktestPanel");
  if (!panel) return;
  const row = panel.querySelector(".gb-row");
  if (!row) return;

  // 1) Garante a coluna de controles
  let col = row.querySelector(".gb-col-controls");
  if (!col) {
    col = document.createElement("div");
    col.className = "gb-col-controls";
    row.insertBefore(col, row.firstChild);
  }
  // move todos os .gb-control para a coluna (independente da posiÃ§Ã£o atual)
  Array.from(row.querySelectorAll(".gb-control")).forEach(ctrl => {
    if (ctrl.parentElement !== col) col.appendChild(ctrl);
  });

  // 2) Garante o bloco de botÃµes e move para a posiÃ§Ã£o desejada
  const buttons = row.querySelector(".gb-buttons");
  if (buttons) {
    // ð OpÃ§Ã£o A: botÃµes ABAIXO dos controles (recomendado pela estabilidade visual)
    if (buttons.parentElement !== col) col.appendChild(buttons);

    // ð OpÃ§Ã£o B: se quiser manter os botÃµes Ã  DIREITA,
    // comente a linha acima e descomente a linha abaixo:
    // if (buttons.parentElement !== row) row.appendChild(buttons);
  }
})();
</script>

<style id="backtest-layout-final">
/* ====== Grade principal ====== */
/* OpÃ§Ã£o A (padrÃ£o): 1 coluna (controles + botÃµes embaixo) */
#garchBacktestPanel .gb-row{
  display:grid !important;
  grid-template-columns: 1fr !important;
  gap:14px !important;
  align-items:start !important;
}

/* Coluna de controles empilhados */
#garchBacktestPanel .gb-col-controls{
  display:grid !important;
  grid-template-columns: 1fr !important;
  gap:10px !important;
}

/* BotÃµes logo abaixo dos controles, largura total */
#garchBacktestPanel .gb-buttons{
  display:flex !important;
  flex-direction:row !important;
  gap:10px !important;
  align-items:stretch !important;
}

/* BotÃ£o com altura do conteÃºdo (sem tentar ocupar âtoda a colunaâ) */
#garchBacktestPanel #gbRun{
  height:auto !important;
  background:linear-gradient(135deg,#3b82f6,#6366f1) !important;
  color:#fff !important; border:none !important;
  border-radius:12px !important; padding:12px 14px !important;
  font-weight:900 !important; box-shadow:0 6px 16px rgba(59,130,246,.25) !important;
}

/* PÃ­lulas de controle (compactas) */
#garchBacktestPanel .gb-control{
  background:#fff !important;
  border:1px solid #e5e7eb !important;
  border-radius:12px !important;
  padding:10px 12px !important;
  box-shadow:0 1px 0 rgba(0,0,0,.03) !important;
}
#garchBacktestPanel .gb-control label{
  display:block !important; margin:0 0 6px !important;
  font-size:11px !important; letter-spacing:.3px !important;
  text-transform:uppercase !important; font-weight:900 !important; color:#475569 !important;
}
#garchBacktestPanel .gb-control input,
#garchBacktestPanel .gb-control select{
  width:100% !important; height:40px !important; line-height:40px !important;
  border:1px solid #e2e8f0 !important; border-radius:10px !important;
  padding:0 12px !important; background:#fff !important; color:#0f172a !important;
  font-weight:800 !important; outline:none !important; appearance:auto !important;
}
#garchBacktestPanel .gb-control input::placeholder{ color:#94a3b8; font-weight:600; }

/* Tipografia mais contida dentro dos painÃ©is */
#aiStrategyPanel .card, #aiStrategyPanel .insight-card { font-size:13px !important; }
#aiStrategyPanel h4 { font-size:14px !important; margin:0 0 6px !important; }
#aiStrategyPanel .value { font-size:16px !important; }

/* NÃ­veis (nd-*) */
.nd-label { font-size:12px !important; }
.nd-value { font-size:16px !important; }

/* Tabela do backtest */
#garchBacktestPanel .gb-table td,
#garchBacktestPanel .gb-table thead th { font-size:12px !important; }

/* ===== Se preferir os botÃµes Ã  DIREITA (modo 2 colunas), troque as 3 regras abaixo =====
#garchBacktestPanel .gb-row{ grid-template-columns:minmax(0,1fr) 230px !important; }
#garchBacktestPanel .gb-buttons{ flex-direction:column !important; }
@media (max-width:760px){ #garchBacktestPanel .gb-row{ grid-template-columns:1fr !important; } .gb-buttons{ flex-direction:row !important; } }
==================================================================== */
</style>
<script>
/* ===== Tiers de Entrada (NÃ­vel 1 - Zona Principal: cluster; NÃ­vel 2 - ExtensÃ£o 18P/3: Â±2Ï 18P/27P) ===== */
(() => {
  const ts = window.tradingSystem;
  if (!ts) return;

  // â helpers: usa os cÃ¡lculos reais do seu sistema
  function garch(){ return ts.analyzeSystemGARCH() || {}; }
  function vol18(){ const v = ts.analyzeSystemVolatility(); return v?.p18?.volatilityPercent || 2.0; }
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }
  const F2 = v => Number.isFinite(v) ? Number(v).toFixed(2) : "--";

  // Constroi nÃ­veis de 3 tiers por LADO
  function buildTiers(side){
    const ga = garch(); const p9 = ga.p9||{}, p18=ga.p18||{}, p27=ga.p27||{};

    // NÃ­vel 1 - Zona Principal: regiÃ£o (vocÃª jÃ¡ cria no generateTradingStrategy de 2 cards)
    // Vamos reaproveitar os valores calculados lÃ¡:
    const last = ts.generateTradingStrategy();  // retorna { long, short, ... }
    const seed = (side==="BUY") ? last.long : last.short;

    // Se ainda nÃ£o houver regiÃ£o, nÃ£o montamos tiers
    if (!seed || !Number.isFinite(seed.entryRange?.min) || !Number.isFinite(seed.entryRange?.max)) return null;

    // NÃ­vel 2 - ExtensÃ£o 18P/NÃ­vel 3 - Extremo 27P: Â±2Ï da 2a/3a projeÃ§Ã£o
    const twoSigma18 = (side==="BUY") ? p18.down2sigma : p18.up2sigma;
    const twoSigma27 = (side==="BUY") ? p27.down2sigma : p27.up2sigma;

    const v18 = vol18(); const pts = choosePts(v18);

    // ConstruÃ§Ã£o dos degraus (com stops e alvos por tier)
    const tiers = [];

    // NÃ­vel 1 - Zona Principal (regiÃ£o cluster)
    const ref1 = (seed.entryRange.min + seed.entryRange.max)/2;
    tiers.push({
      label: "NÃ­vel 1 - Zona Principal (RegiÃ£o)",
      entry: ref1,
      stop:  (side==="BUY") ? (seed.entryRange.min - 10) : (seed.entryRange.max + 10),
      tgt:   (side==="BUY") ? (ref1 + pts) : (ref1 - pts),
      note:  `RegiÃ£o: ${F2(seed.entryRange.min)}â${F2(seed.entryRange.max)}`
    });

    // NÃ­vel 2 - ExtensÃ£o 18P (Â±2Ï 18P)
    if (Number.isFinite(twoSigma18)){
      const e2 = twoSigma18;
      tiers.push({
        label: "NÃ­vel 2 - ExtensÃ£o MÃ©dia (Â±2Ï 18P)",
        entry: e2,
        stop:  (side==="BUY") ? (e2 - 10) : (e2 + 10),
        tgt:   (side==="BUY") ? (e2 + pts) : (e2 - pts),
        note:  `18P ${side==="BUY"?"â2Ï":"+2Ï"}`
      });
    }

    // NÃ­vel 3 - Extremo 27P (Â±2Ï 27P)
    if (Number.isFinite(twoSigma27)){
      const e3 = twoSigma27;
      tiers.push({
        label: "NÃ­vel 3 - Extremidade (Â±2Ï 27P)",
        entry: e3,
        stop:  (side==="BUY") ? (e3 - 10) : (e3 + 10),
        tgt:   (side==="BUY") ? (e3 + pts) : (e3 - pts),
        note:  `27P ${side==="BUY"?"â2Ï":"+2Ï"}`
      });
    }

    // Ordena (BUY: de cima p/ baixo / SELL: de baixo p/ cima) sÃ³ pra visual
    tiers.sort((a,b)=> (side==="BUY") ? b.entry - a.entry : a.entry - b.entry);

    return { tiers, pts };
  }

  // Renderiza uma caixinha de tiers dentro do card jÃ¡ existente
  function injectTiers(side, container){
    const pack = buildTiers(side);
    if (!pack) return;
    const { tiers, pts } = pack;

    const list = tiers.map(t => `
      <div style="margin:6px 0; padding:8px 10px; border:1px solid #e5e7eb; border-radius:10px; background:#fff;">
        <div style="font-weight:900; font-size:12px;">${t.label}</div>
        <div style="font-size:12px; margin-top:4px;">
          ð¯ Entrada: <b>${F2(t.entry)}</b> &nbsp;|&nbsp;
          ð Stop: <b>${F2(t.stop)}</b> &nbsp;|&nbsp;
          â Alvo curto: <b>${F2(t.tgt)}</b> <span style="opacity:.7">(+/â ${pts} pts)</span><br>
          <span style="opacity:.7">${t.note}</span>
        </div>
      </div>
    `).join("");

    const box = document.createElement("div");
    box.innerHTML = `
      <div style="margin-top:8px; border:1px dashed #cbd5e1; border-radius:12px; padding:8px 10px; background:#f8fafc;">
        <div style="font-weight:800; font-size:12px; color:#334155; margin-bottom:4px;">
          Plano em 3 Tiers (${side==="BUY"?"compra":"venda"})
        </div>
        ${list}
        <div style="font-size:11px; color:#64748b; margin-top:6px;">
          Alvo final: manter parcial atÃ© o <b>JustÃ­ssimo</b> se a direÃ§Ã£o favorecer.
        </div>
      </div>
    `;
    container.appendChild(box);
  }

  // Pluga no painel assim que ele renderizar
  const hook = setInterval(() => {
    const op = document.getElementById("aiOperation");
    if (!op) return;
    clearInterval(hook);

    // localiza os dois cards (Compra e Venda) dentro do aiOperation
    const cards = op.querySelectorAll(".card.card-success, .card.card-danger");
    if (!cards.length){
      // fallback: injeta abaixo de todo o bloco
      injectTiers("BUY", op);
      injectTiers("SELL", op);
      return;
    }

    // 1Âº card: compra | 2Âº card: venda (como no seu layout atual)
    const buyCard  = cards[0];
    const sellCard = cards[1] || cards[0].nextElementSibling || op;

    injectTiers("BUY",  buyCard);
    injectTiers("SELL", sellCard);
  }, 150);
})();
</script>


<script>
/* ====== Seletor de Tiers nos cards (BUY/SELL) ====== */
(() => {
  const ts = window.tradingSystem;
  if (!ts) return;

  // helpers
  const F2 = v => Number.isFinite(v) ? Number(v).toFixed(2) : "--";
  function vol18(){ const v = ts.analyzeSystemVolatility(); return v?.p18?.volatilityPercent || 2.0; }
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }

  function buildTiers(side){
    const ga = ts.analyzeSystemGARCH() || {};
    const p18= ga.p18 || {}, p27 = ga.p27 || {};
    const last = ts.generateTradingStrategy?.() || {};
    const seed = side==="BUY" ? last.long : last.short;

    if (!seed || !Number.isFinite(seed?.entryRange?.min) || !Number.isFinite(seed?.entryRange?.max)) return null;

    const v18 = vol18(); const pts = choosePts(v18);
    const ref1 = (seed.entryRange.min + seed.entryRange.max)/2;

    const t1 = {
      key:"t1",
      label:"NÃ­vel 1 - Zona Principal (RegiÃ£o)",
      entry:ref1,
      stop: (side==="BUY") ? (seed.entryRange.min - 10) : (seed.entryRange.max + 10),
      tgt:  (side==="BUY") ? (ref1 + pts) : (ref1 - pts),
      note:`RegiÃ£o: ${F2(seed.entryRange.min)}â${F2(seed.entryRange.max)}`
    };

    const sigma18 = (side==="BUY") ? p18.down2sigma : p18.up2sigma;
    const sigma27 = (side==="BUY") ? p27.down2sigma : p27.up2sigma;

    const tiers = [t1];
    if (Number.isFinite(sigma18)){
      tiers.push({
        key:"t2",
        label:"NÃ­vel 2 - ExtensÃ£o MÃ©dia (Â±2Ï 18P)",
        entry:sigma18,
        stop:(side==="BUY") ? (sigma18 - 10) : (sigma18 + 10),
        tgt: (side==="BUY") ? (sigma18 + pts) : (sigma18 - pts),
        note:`18P ${side==="BUY"?"â2Ï":"+2Ï"}`
      });
    }
    if (Number.isFinite(sigma27)){
      tiers.push({
        key:"t3",
        label:"NÃ­vel 3 - Extremidade (Â±2Ï 27P)",
        entry:sigma27,
        stop:(side==="BUY") ? (sigma27 - 10) : (sigma27 + 10),
        tgt: (side==="BUY") ? (sigma27 + pts) : (sigma27 - pts),
        note:`27P ${side==="BUY"?"â2Ï":"+2Ï"}`
      });
    }

    // ordena visualmente (BUY: altoâbaixo; SELL: baixoâalto)
    tiers.sort((a,b)=> side==="BUY" ? b.entry - a.entry : a.entry - b.entry);
    return { tiers, pts };
  }

  // monta UI de tabs + conteÃºdo
  function mountTierUI(side, host){
    const pack = buildTiers(side);
    if (!pack || !pack.tiers.length) return;
    const { tiers, pts } = pack;

    const wrap = document.createElement("div");
    // tabs
    const tabs = document.createElement("div");
    tabs.className = "tier-tabs";
    // content
    const box  = document.createElement("div");
    box.className = "tier-box";

    function renderTier(t){
      box.innerHTML = `
        <div class="tier-line">ð¯ <b>${t.label}</b></div>
        <div class="tier-line">Entrada: <b class="tier-mono">${F2(t.entry)}</b>
          &nbsp;|&nbsp; ð Stop: <b class="tier-mono">${F2(t.stop)}</b>
          &nbsp;|&nbsp; â Alvo curto: <b class="tier-mono">${F2(t.tgt)}</b>
          &nbsp;<span class="tier-note">(Â± ${pts} pts)</span>
        </div>
        <div class="tier-note">${t.note}</div>
        <div class="tier-note">Alvo final: manter parcial atÃ© o <b>JustÃ­ssimo</b> se a direÃ§Ã£o favorecer.</div>
      `;
    }

    // cria botÃµes de tab
    tiers.forEach((t,idx) => {
      const b = document.createElement("button");
      b.type="button";
      b.className = "tier-tab" + (idx===0 ? " active" : "");
      b.textContent = t.label.replace("Tier-","T");
      b.onclick = () => {
        // ativa tab
        tabs.querySelectorAll(".tier-tab").forEach(x=>x.classList.remove("active"));
        b.classList.add("active");
        // troca conteÃºdo
        renderTier(t);
      };
      tabs.appendChild(b);
    });

    // render inicial = primeiro tier
    renderTier(tiers[0]);

    // injeta no card
    wrap.appendChild(tabs);
    wrap.appendChild(box);
    host.appendChild(wrap);
  }

  // posiciona dentro dos cards quando o painel de estratÃ©gia estiver pronto
  function attach(){
    const op = document.getElementById("aiOperation");
    if (!op){ setTimeout(attach, 150); return; }

    // evita duplicar
    if (op.dataset.tiersMounted === "1") return;
    op.dataset.tiersMounted = "1";

    // tenta pegar os dois cards (verde e vermelho) como jÃ¡ estÃ£o
    const cards = op.querySelectorAll(".card.card-success, .card.card-danger, .insight-card");
    // fallback seguro: monta em sequÃªncia
    let buyHost  = cards[0] || op;
    let sellHost = cards[1] || cards[0] || op;

    mountTierUI("BUY",  buyHost);
    mountTierUI("SELL", sellHost);
  }

  // roda ao abrir e apÃ³s re-renderizaÃ§Ãµes comuns do painel
  attach();
  const obs = new MutationObserver(()=>attach());
  obs.observe(document.getElementById("aiStrategyPanel") || document.body, {childList:true, subtree:true});
})();
</script>

<script>
/* ====== Seletor de Tiers nos cards (BUY/SELL) â robusto ====== */
(() => {
  const ts = window.tradingSystem;
  if (!ts) return;

  // helpers
  const F2 = v => Number.isFinite(v) ? Number(v).toFixed(2) : "--";
  function vol18(){ const v = ts.analyzeSystemVolatility?.(); return v?.p18?.volatilityPercent || 2.0; }
  function choosePts(v){ if (v>=3.0) return 15; if (v<=1.5) return 10; return 12; }

  function buildTiers(side){
    const ga = ts.analyzeSystemGARCH?.() || {};
    const p18 = ga.p18 || {}, p27 = ga.p27 || {};
    const strat = ts.generateTradingStrategy?.() || {};
    const seed  = side==="BUY" ? strat.long : strat.short;

    if (!seed || !Number.isFinite(seed?.entryRange?.min) || !Number.isFinite(seed?.entryRange?.max)) return null;

    const pts  = choosePts(vol18());
    const ref1 = (seed.entryRange.min + seed.entryRange.max)/2;

    const tiers = [{
      key:"t1",
      label:"NÃ­vel 1 - Zona Principal (RegiÃ£o)",
      entry: ref1,
      stop:  (side==="BUY") ? (seed.entryRange.min - 10) : (seed.entryRange.max + 10),
      tgt:   (side==="BUY") ? (ref1 + pts) : (ref1 - pts),
      note:  `RegiÃ£o: ${F2(seed.entryRange.min)}â${F2(seed.entryRange.max)}`
    }];

    const sigma18 = (side==="BUY") ? p18.down2sigma : p18.up2sigma;
    const sigma27 = (side==="BUY") ? p27.down2sigma : p27.up2sigma;

    if (Number.isFinite(sigma18)){
      tiers.push({
        key:"t2",
        label:"NÃ­vel 2 - ExtensÃ£o MÃ©dia (Â±2Ï 18P)",
        entry:sigma18,
        stop:(side==="BUY") ? (sigma18 - 10) : (sigma18 + 10),
        tgt:(side==="BUY") ? (sigma18 + pts) : (sigma18 - pts),
        note:`18P ${side==="BUY"?"â2Ï":"+2Ï"}`
      });
    }
    if (Number.isFinite(sigma27)){
      tiers.push({
        key:"t3",
        label:"NÃ­vel 3 - Extremidade (Â±2Ï 27P)",
        entry:sigma27,
        stop:(side==="BUY") ? (sigma27 - 10) : (sigma27 + 10),
        tgt:(side==="BUY") ? (sigma27 + pts) : (sigma27 - pts),
        note:`27P ${side==="BUY"?"â2Ï":"+2Ï"}`
      });
    }

    // ordenaÃ§Ã£o visual (BUY: altoâbaixo; SELL: baixoâalto)
    tiers.sort((a,b)=> side==="BUY" ? b.entry - a.entry : a.entry - b.entry);
    return { tiers, pts };
  }

  // monta UI de tabs + conteÃºdo (BUY/SELL)
  function mountTierUI(side, host){
    // evita duplicar
    const markerId = side==="BUY" ? "tiersBuy" : "tiersSell";
    if (host.querySelector(`#${markerId}`)) return;

    const pack = buildTiers(side);
    if (!pack || !pack.tiers.length) return;
    const { tiers, pts } = pack;

    const wrap = document.createElement("div");
    wrap.className = "tier-wrap";
    wrap.id = markerId;

    const tabs = document.createElement("div");
    tabs.className = "tier-tabs " + (side==="BUY" ? "buy" : "sell");

    const box  = document.createElement("div");
    box.className  = "tier-box";

    function renderTier(t){
      box.innerHTML = `
        <div class="tier-line"><b>${t.label}</b></div>
        <div class="tier-line">
          ð¯ Entrada: <b class="tier-mono">${F2(t.entry)}</b>
          &nbsp;|&nbsp; ð Stop: <b class="tier-mono">${F2(t.stop)}</b>
          &nbsp;|&nbsp; â Alvo curto: <b class="tier-mono">${F2(t.tgt)}</b>
          &nbsp;<span class="tier-note">(Â± ${pts} pts)</span>
        </div>
        <div class="tier-note">${t.note}</div>
        <div class="tier-note">Alvo final: manter parcial atÃ© o <b>JustÃ­ssimo</b> se a direÃ§Ã£o favorecer.</div>
      `;
    }

    tiers.forEach((t, i) => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "tier-tab" + (i===0 ? " active" : "");
      b.textContent = t.label.replace("Tier-","T");
      b.addEventListener("click", () => {
        tabs.querySelectorAll(".tier-tab").forEach(x=>x.classList.remove("active"));
        b.classList.add("active");
        renderTier(t);
      });
      tabs.appendChild(b);
    });

    renderTier(tiers[0]);
    wrap.appendChild(tabs);
    wrap.appendChild(box);
    host.appendChild(wrap);
  }

  function attach(){
    const op = document.getElementById("aiOperation");
    if (!op){ setTimeout(attach, 200); return; }

    // Tenta achar 2 cards (compra / venda). No seu layout sÃ£o .insight-card.
    const cards = op.querySelectorAll(".insight-card, .card");
    if (!cards.length){
      // sem cards: injeta tudo no prÃ³prio container
      mountTierUI("BUY",  op);
      mountTierUI("SELL", op);
      return;
    }

    // 1Âº card = compra, 2Âº = venda (como nas suas capturas)
    const buyHost  = cards[0] || op;
    const sellHost = cards[1] || op;

    mountTierUI("BUY",  buyHost);
    mountTierUI("SELL", sellHost);
  }

  // roda ao carregar e quando o painel re-renderizar
  attach();
  const obs = new MutationObserver(()=>attach());
  obs.observe(document.getElementById("aiStrategyPanel") || document.body, {childList:true, subtree:true});
})();
</script>


<script>
/* ===== Tabs T1/T2/T3 â patch mÃ­nimo, sem observer ===== */
(function(){
  function F2(v){ return (Number.isFinite(v) ? Number(v).toFixed(2) : "--"); }
  function ptsByVol(v){ return v>=3.0 ? 15 : (v<=1.5 ? 10 : 12); }

  function buildTiers(side, ts){
    const ga = ts.analyzeSystemGARCH?.() || {};
    const p18= ga.p18 || {}, p27= ga.p27 || {};
    const strat = ts.generateTradingStrategy?.() || {};
    const seed  = side==='BUY' ? strat.long : strat.short;

    const tiers = [];
    const v18 = ts.analyzeSystemVolatility?.().p18?.volatilityPercent || 2.0;
    const pts = ptsByVol(v18);

    if (seed && Number.isFinite(seed?.entryRange?.min) && Number.isFinite(seed?.entryRange?.max)){
      const ref1 = (seed.entryRange.min + seed.entryRange.max)/2;
      tiers.push({ key:'t1', label:'NÃ­vel 1 - Zona Principal (RegiÃ£o)',
        entry:ref1, stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
        tgt:(side==='BUY')?(ref1+pts):(ref1-pts),
        note:`RegiÃ£o: ${F2(seed.entryRange.min)}â${F2(seed.entryRange.max)}` });
    }
    const s18 = (side==='BUY') ? p18.down2sigma : p18.up2sigma;
    const s27 = (side==='BUY') ? p27.down2sigma : p27.up2sigma;
    if (Number.isFinite(s18)) tiers.push({ key:'t2', label:'NÃ­vel 2 - ExtensÃ£o 18P (Â±2Ï 18P)', entry:s18,
      stop:(side==='BUY')?s18-10:s18+10, tgt:(side==='BUY')?s18+pts:s18-pts, note:`18P ${side==='BUY'?'â2Ï':'+2Ï'}` });
    if (Number.isFinite(s27)) tiers.push({ key:'t3', label:'NÃ­vel 3 - Extremo 27P (Â±2Ï 27P)', entry:s27,
      stop:(side==='BUY')?s27-10:s27+10, tgt:(side==='BUY')?s27+pts:s27-pts, note:`27P ${side==='BUY'?'â2Ï':'+2Ï'}` });

    if (!tiers.length) return null;
    tiers.sort((a,b)=> side==='BUY' ? b.entry-a.entry : a.entry-b.entry);
    return { tiers, pts };
  }

  function mountTierTabs(side, host, ts){
    if (!host) return;
    const id = side==='BUY' ? 'tiersBuy' : 'tiersSell';
    if (host.querySelector('#'+id)) return; // jÃ¡ existe

    const pack = buildTiers(side, ts);
    if (!pack) return;
    const { tiers, pts } = pack;

    const wrap = document.createElement('div'); wrap.className='tier-wrap'; wrap.id=id;
    const tabs = document.createElement('div'); tabs.className='tier-tabs ' + (side==='BUY'?'buy':'sell');
    const box  = document.createElement('div'); box.className='tier-box';

    function render(t){
      box.innerHTML = `
        <div class="tier-line"><b>${t.label}</b></div>
        <div class="tier-line">
          ð¯ Entrada: <b class="tier-mono">${F2(t.entry)}</b>
          &nbsp;|&nbsp; ð Stop: <b class="tier-mono">${F2(t.stop)}</b>
          &nbsp;|&nbsp; â Alvo curto: <b class="tier-mono">${F2(t.tgt)}</b>
          &nbsp;<span class="tier-note">(Â± ${pts} pts)</span>
        </div>
        <div class="tier-note">${t.note}</div>
        <div class="tier-note">Alvo final: manter parcial atÃ© o <b>JustÃ­ssimo</b> se a direÃ§Ã£o favorecer.</div>`;
    }

    tiers.forEach((t,i)=>{
      const b = document.createElement('button');
      b.type='button';
      b.className='tier-tab' + (i===0 ? ' active' : '');
      b.textContent = t.label.replace('Tier-','T');
      b.addEventListener('click', ()=>{
        tabs.querySelectorAll('.tier-tab').forEach(x=>x.classList.remove('active'));
        b.classList.add('active'); render(t);
      });
      tabs.appendChild(b);
    });
    render(tiers[0]);
    wrap.appendChild(tabs);
    wrap.appendChild(box);
    host.appendChild(wrap);
  }

  // --- ENVOLVE a SUA funÃ§Ã£o renderStrategyPanel (sem mudar sua lÃ³gica) ---
  function install(){
    const ts = window.tradingSystem;
    if (!ts || typeof ts.renderStrategyPanel !== 'function') { setTimeout(install, 150); return; }

    const original = ts.renderStrategyPanel.bind(ts);
    ts.renderStrategyPanel = function(){
      const r = original();  // chama sua renderizaÃ§Ã£o original
      try{
        const op = document.getElementById('aiOperation');
        if (!op) return r;

        // tenta achar exatamente os dois cards gerados por vocÃª
        const cards = op.querySelectorAll('.card-grid > .card');
        const buyHost  = cards[0] || op;
        const sellHost = cards[1] || op;

        mountTierTabs('BUY',  buyHost,  ts);
        mountTierTabs('SELL', sellHost, ts);
      }catch(e){ /* silencia para nÃ£o travar */ }
      return r;
    };
  }
  install();
})();
</script>
<style id="tier-card-colors">
/* fundo suave dos cards de compra/venda */
#aiOperation .card.card-success{
  background: linear-gradient(180deg,#ecfdf5,#ffffff);
  border-color:#86efac;
}
#aiOperation .card.card-danger{
  background: linear-gradient(180deg,#fef2f2,#ffffff);
  border-color:#fca5a5;
}

/* Tabs T1/T2/T3 â mantÃ©m as cores nas abas ativas */
#aiStrategyPanel .tier-wrap{margin-top:8px}
#aiStrategyPanel .tier-tabs{display:flex;gap:6px;margin:8px 0}
#aiStrategyPanel .tier-tab{
  cursor:pointer; user-select:none; padding:6px 10px;
  border:1px solid #e5e7eb; background:#fff; border-radius:999px;
  font-size:12px; font-weight:800; color:#334155
}
#aiStrategyPanel .tier-tab.active{color:#fff; border-color:transparent}
#aiStrategyPanel .tier-tabs.buy  .tier-tab.active{background:#10b981}  /* verde */
#aiStrategyPanel .tier-tabs.sell .tier-tab.active{background:#ef4444}  /* vermelho */
#aiStrategyPanel .tier-box{border:1px dashed #cbd5e1;border-radius:12px;padding:8px 10px;background:#f8fafc}
#aiStrategyPanel .tier-line{font-size:12px;margin:4px 0;color:#0f172a}
#aiStrategyPanel .tier-note{font-size:11px;color:#64748b}
#aiStrategyPanel .tier-mono{font-variant-numeric:tabular-nums}

/* headline dinÃ¢mica: ocupa o lugar do âpreparar compra/vendaâ */
#aiStrategyPanel .tier-headline{
  margin:6px 0 8px; padding:8px 10px; border:1px solid #e5e7eb;
  border-radius:10px; background:#f9fafb; font-size:12px;
}
#aiStrategyPanel .tier-headline .k{color:#64748b}
#aiStrategyPanel .tier-headline .v{font-weight:900}
</style>

<script id="tier-headline-sync">
(function(){
  // UtilitÃ¡rios (leem os cÃ¡lculos do seu prÃ³prio sistema)
  const ts = window.tradingSystem;
  if (!ts) return;

  const F2 = v => (Number.isFinite(v)? Number(v).toFixed(2) : "--");
  const vol18 = () => (ts.analyzeSystemVolatility?.().p18?.volatilityPercent || 2.0);
  const ptsByVol = v => (v>=3 ? 15 : (v<=1.5 ? 10 : 12));

  function computeTiers(side){
    const ga = ts.analyzeSystemGARCH?.() || {}; const p18=ga.p18||{}, p27=ga.p27||{};
    const s  = ts.generateTradingStrategy?.() || {}; const seed = side==='BUY'? s.long : s.short;
    const pts = ptsByVol(vol18());
    const tiers = [];
    if (seed && Number.isFinite(seed?.entryRange?.min) && Number.isFinite(seed?.entryRange?.max)){
      const ref1=(seed.entryRange.min+seed.entryRange.max)/2;
      tiers.push({key:'t1', label:'NÃ­vel 1 - Zona Principal (RegiÃ£o)', entry:ref1,
                  stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
                  tgt:(side==='BUY')?(ref1+pts):(ref1-pts)});
    }
    const s18=(side==='BUY')?p18.down2sigma:p18.up2sigma;
    const s27=(side==='BUY')?p27.down2sigma:p27.up2sigma;
    if (Number.isFinite(s18)) tiers.push({key:'t2', label:'NÃ­vel 2 - ExtensÃ£o MÃ©dia (Â±2Ï 18P)', entry:s18, stop:(side==='BUY')?s18-10:s18+10, tgt:(side==='BUY')?s18+pts:s18-pts});
    if (Number.isFinite(s27)) tiers.push({key:'t3', label:'NÃ­vel 3 - Extremidade (Â±2Ï 27P)', entry:s27, stop:(side==='BUY')?s27-10:s27+10, tgt:(side==='BUY')?s27+pts:s27-pts});
    if (!tiers.length) return null;
    tiers.sort((a,b)=> side==='BUY' ? b.entry-a.entry : a.entry-b.entry);
    return {tiers, pts};
  }

  // Gera (se faltar) um bloco de headline logo abaixo do <h4> do card
  function ensureHeadlineHost(card, side){
    let head = card.querySelector('.tier-headline');
    if (!head){
      head = document.createElement('div');
      head.className = 'tier-headline';
      // insere depois do h4
      const h = card.querySelector('h4') || card.firstChild;
      h && h.parentNode.insertBefore(head, h.nextSibling);
    }
    // pinta o fundo do headline conforme o lado
    head.style.background = (side==='BUY') ? '#ecfdf5' : '#fef2f2';
    head.style.borderColor = (side==='BUY') ? '#86efac' : '#fca5a5';
    return head;
  }

  // Atualiza a linha âsinalâ (texto acima) e mantÃ©m o resumo do tier
  function renderTierIntoCard(card, side, tier){
    // Headline dinÃ¢mico (sinal visÃ­vel)
    const head = ensureHeadlineHost(card, side);
    head.innerHTML = `
      <span class="k">AnÃ¡lise (</span><b>${tier.label}</b><span class="k">):</span>
      <span class="k"> Gatilho</span> <span class="v">${F2(tier.entry)}</span> Â·
      <span class="k">Stop</span> <span class="v">${F2(tier.stop)}</span> Â·
      <span class="k">Alvo</span> <span class="v">${F2(tier.tgt)}</span>
    `;

    // Bloco explicativo (se existe tier-box sob as abas, atualizamos tambÃ©m)
    const box = card.querySelector('.tier-box');
    if (box){
      const pts = ptsByVol(vol18());
      box.innerHTML = `
        <div class="tier-line"><b>${tier.label}</b></div>
        <div class="tier-line">
          ð¯ Entrada: <b class="tier-mono">${F2(tier.entry)}</b> Â·
          ð Stop: <b class="tier-mono">${F2(tier.stop)}</b> Â·
          â Alvo curto: <b class="tier-mono">${F2(tier.tgt)}</b>
          <span class="tier-note">(Â± ${pts} pts)</span>
        </div>
        <div class="tier-note">Alvo final: manter parcial atÃ© o <b>JustÃ­ssimo</b> se a direÃ§Ã£o favorecer.</div>
      `;
    }
  }

  // Liga as abas existentes (T1/T2/T3) para mudar a headline e a box
  function wireTabs(card, side){
    const tabs = card.querySelectorAll('.tier-tabs .tier-tab');
    if (!tabs.length) return;

    // PrÃ©-calcula tiers
    const pack = computeTiers(side); if (!pack) return;
    const {tiers} = pack;
    // Map simples por texto (T1/T2/T3)
    const map = { 'T1': tiers.find(t=>t.key==='t1'),
                  'T2': tiers.find(t=>t.key==='t2'),
                  'T3': tiers.find(t=>t.key==='t3') };

    // Render inicial conforme aba ativa
    const active = Array.from(tabs).find(b=>b.classList.contains('active')) || tabs[0];
    const key = active.textContent.trim(); if (map[key]) renderTierIntoCard(card, side, map[key]);

    tabs.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        tabs.forEach(x=>x.classList.remove('active'));
        btn.classList.add('active');
        const k = btn.textContent.trim();
        const t = map[k];
        if (t) renderTierIntoCard(card, side, t);
      }, {once:false});
    });
  }

  // Envolve sua renderizaÃ§Ã£o para religar as abas sempre que o painel for redesenhado
  function install(){
    const ts = window.tradingSystem;
    if (!ts || typeof ts.renderStrategyPanel !== 'function'){ setTimeout(install,150); return; }
    const orig = ts.renderStrategyPanel.bind(ts);
    ts.renderStrategyPanel = function(){
      const r = orig();
      try{
        const op = document.getElementById('aiOperation');
        if (!op) return r;
        const cards = op.querySelectorAll('.card-grid > .card');
        const buy  = cards[0] || null;
        const sell = cards[1] || null;

        // se os blocos de tabs jÃ¡ existem (montados por patch anterior), apenas âligaâ as mudanÃ§as
        if (buy)  wireTabs(buy,  'BUY');
        if (sell) wireTabs(sell, 'SELL');
      }catch(_){}
      return r;
    };
  }
  install();
})();
</script>
<!-- === TIER PRO: anÃ¡lise completa dentro das tabs (substitui bloco antigo) === -->
<style id="tier-pro-css">
/* Fundo suave dos cards (mantÃ©m) */
#aiOperation .card.card-success{background:linear-gradient(180deg,#ecfdf5,#ffffff);border-color:#86efac;}
#aiOperation .card.card-danger{background:linear-gradient(180deg,#fef2f2,#ffffff);border-color:#fca5a5;}

/* Tabs */
#aiStrategyPanel .tier-wrap{margin-top:8px}
#aiStrategyPanel .tier-tabs{display:flex;gap:8px;margin:10px 0}
#aiStrategyPanel .tier-tab{cursor:pointer;user-select:none;padding:8px 12px;border:1px solid #e5e7eb;background:#fff;border-radius:999px;font-size:12px;font-weight:900;color:#334155}
#aiStrategyPanel .tier-tab.active{color:#fff;border-color:transparent}
#aiStrategyPanel .tier-tabs.buy  .tier-tab.active{background:#10b981}
#aiStrategyPanel .tier-tabs.sell .tier-tab.active{background:#ef4444}

/* Painel PRO dentro do Tier (grande) */
.tier-pro{
  border:1px solid #e5e7eb;border-radius:12px;background:#fff;
  padding:12px 14px;margin-top:6px;
}
.tier-pro h5{
  margin:0 0 8px 0;font-size:14px;font-weight:900;color:#0f172a;
  display:flex;align-items:center;gap:8px;
}
.tier-grid{
  display:grid;grid-template-columns:1fr;gap:6px;
}
.tline{font-size:13px;color:#0f172a}
.tkey{color:#64748b;font-weight:800}
.tval{font-weight:900;font-variant-numeric:tabular-nums}

/* Notas menores */
.tnote{font-size:12px;color:#475569;margin-top:6px}
</style>

<script id="tier-pro-js">
(function(){
  const ts = window.tradingSystem; if(!ts) return;

  const F2 = v => (Number.isFinite(v)? Number(v).toFixed(2) : "--");
  const vol18 = () => (ts.analyzeSystemVolatility?.().p18?.volatilityPercent || 2.0);
  const ptsByVol = v => (v>=3 ? 15 : (v<=1.5 ? 10 : 12));

  function computeTiers(side){
    const ga = ts.analyzeSystemGARCH?.()||{};
    const p18=ga.p18||{}, p27=ga.p27||{};
    const s  = ts.generateTradingStrategy?.()||{};
    const seed = side==='BUY' ? s.long : s.short;
    const pts = ptsByVol(vol18());
    const tiers = [];

    // T1 (RegiÃ£o)
    if (seed && Number.isFinite(seed?.entryRange?.min) && Number.isFinite(seed?.entryRange?.max)){
      const ref=(seed.entryRange.min+seed.entryRange.max)/2;
      tiers.push({
        key:'T1', label:'NÃ­vel 1 - Zona Principal (RegiÃ£o)',
        entry:ref,
        stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
        tgt:(side==='BUY')?(ref+pts):(ref-pts),
        note:`RegiÃ£o ${F2(seed.entryRange.min)}â${F2(seed.entryRange.max)}`
      });
    }
    // T2 (Â±2Ï 18P)
    const s18=(side==='BUY')?p18.down2sigma:p18.up2sigma;
    if (Number.isFinite(s18)){
      tiers.push({
        key:'T2', label:'NÃ­vel 2 - ExtensÃ£o MÃ©dia (Â±2Ï 18P)',
        entry:s18,
        stop:(side==='BUY')?s18-10:s18+10,
        tgt:(side==='BUY')?s18+pts:s18-pts,
        note:`18P ${side==='BUY'?'â2Ï':'+2Ï'}`
      });
    }
    // T3 (Â±2Ï 27P)
    const s27=(side==='BUY')?p27.down2sigma:p27.up2sigma;
    if (Number.isFinite(s27)){
      tiers.push({
        key:'T3', label:'NÃ­vel 3 - Extremidade (Â±2Ï 27P)',
        entry:s27,
        stop:(side==='BUY')?s27-10:s27+10,
        tgt:(side==='BUY')?s27+pts:s27-pts,
        note:`27P ${side==='BUY'?'â2Ï':'+2Ï'}`
      });
    }
    if (!tiers.length) return null;

    // ordena para visual (BUY: altoâbaixo; SELL: baixoâalto)
    tiers.sort((a,b)=> side==='BUY' ? b.entry-a.entry : a.entry-b.entry);
    return {tiers, pts, p18};
  }

  // Apaga o bloco antigo âcircundadoâ: tudo entre <h4> e a Ã¡rea de tiers
  function wipeLegacyBlock(card){
    // Se ainda nÃ£o foi limpo, mova tudo para um holder e esconda
    if (!card.querySelector('.legacy-block')){
      const legacy = document.createElement('div');
      legacy.className='legacy-block'; legacy.style.display='none';
      const h = card.querySelector('h4');
      // move nodos entre o h4 e a tier-wrap (se existir)
      const until = card.querySelector('.tier-wrap');
      const toMove = [];
      let n = h ? h.nextSibling : card.firstChild;
      while(n && n!==until){ const next=n.nextSibling; toMove.push(n); n=next; }
      toMove.forEach(node=> legacy.appendChild(node));
      card.insertBefore(legacy, until || null);
    }
  }

  // ConstrÃ³i o painel PRO (dentro do Tier selecionado)
  function renderTierPro(card, side, tier, refs){
    wipeLegacyBlock(card);

    // cria/garante a caixa onde vai a anÃ¡lise PRO
    let pro = card.querySelector('.tier-pro');
    if (!pro){
      pro = document.createElement('div'); pro.className='tier-pro';
      // injeta logo apÃ³s a barra de tabs (ou no final do card)
      const afterTabs = card.querySelector('.tier-wrap') || card;
      afterTabs.appendChild(pro);
    }

    // calcula R/R do tier
    const rr = (Math.abs(tier.tgt - tier.entry) / Math.abs(tier.entry - tier.stop)) || 0;

    // referencias de bandas (usamos p18 para +1Ï / â1Ï)
    const up1 = refs?.p18?.up1sigma, dn1 = refs?.p18?.down1sigma;

    pro.innerHTML = `
      <h5>${side==='BUY'?'ð¢ Compra':'ð´ Venda'} â <span>${tier.label}</span></h5>
      <div class="tier-grid">
        <div class="tline"><span class="tkey">Gatilho:</span> <span class="tval">${F2(tier.entry)}</span></div>
        <div class="tline"><span class="tkey">Stop:</span>    <span class="tval">${F2(tier.stop)}</span></div>
        <div class="tline"><span class="tkey">Alvo curto:</span> <span class="tval">${F2(tier.tgt)}</span>  Â·  <span class="tkey">R/R:</span> <span class="tval">1:${rr.toFixed(2)}</span></div>
        ${Number.isFinite(up1)&&Number.isFinite(dn1) ? `<div class="tline"><span class="tkey">Bandas 18P:</span> +1Ï ${F2(up1)}  Â·  â1Ï ${F2(dn1)}</div>` : ``}
        <div class="tnote">${tier.note || ''}</div>
        <div class="tnote">Alvo final: manter parcial atÃ© o <b>JustÃ­ssimo</b> se a direÃ§Ã£o favorecer.</div>
      </div>
    `;
  }

  // Liga as abas jÃ¡ existentes; quando trocar, reescreve a anÃ¡lise PRO e mantÃ©m topo limpo
  function wireCard(card){
    // identifique lado pelo CSS/tÃ­tulo
    const isBuy  = card.classList.contains('card-success') || /compra/i.test(card.textContent);
    const side   = isBuy ? 'BUY' : 'SELL';

    const pack = computeTiers(side); if (!pack) return;
    const {tiers, p18} = pack;
    const tabs = card.querySelectorAll('.tier-tabs .tier-tab');

    // mapeia T1/T2/T3
    const map = { T1: tiers.find(t=>t.key==='T1'),
                  T2: tiers.find(t=>t.key==='T2'),
                  T3: tiers.find(t=>t.key==='T3') };

    // render inicial conforme aba ativa; se nÃ£o houver, T1
    const active = Array.from(tabs).find(b=>b.classList.contains('active')) || tabs[0];
    const key0   = (active?.textContent||'T1').trim();
    const first  = map[key0] || map.T1 || tiers[0];
    if (first) renderTierPro(card, side, first, {p18});

    // liga cliques
    tabs.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        tabs.forEach(x=>x.classList.remove('active'));
        btn.classList.add('active');
        const k = (btn.textContent||'').trim();
        const t = map[k] || map.T1 || tiers[0];
        if (t) renderTierPro(card, side, t, {p18});
      }, {once:false});
    });
  }

  // Hook na sua renderizaÃ§Ã£o para rodar SEM alterar sua lÃ³gica
  function install(){
    if (!ts || typeof ts.renderStrategyPanel !== 'function'){ setTimeout(install,150); return; }
    const orig = ts.renderStrategyPanel.bind(ts);
    ts.renderStrategyPanel = function(){
      const r = orig();
      try{
        const op = document.getElementById('aiOperation'); if (!op) return r;
        const cards = op.querySelectorAll('.card-grid > .card'); // [0]=compra, [1]=venda
        if (cards[0]) wireCard(cards[0]);
        if (cards[1]) wireCard(cards[1]);
      }catch(_){}
      return r;
    };
  }
  install();
})();
</script>
<!-- === /FINAL PATCH === -->









<!-- ===== FINAL TIER SYNC â SINGLE CONTROL (no duplicates) ===== -->
<style id="final-tier-sync-one-css">
  #aiOperation .card { position: relative; }
  .tier-tabs { display:flex; gap:8px; margin:10px 0; }
  .tier-tab { cursor:pointer; user-select:none; padding:8px 12px; border:1px solid #e5e7eb; background:#fff; border-radius:999px; font-size:12px; font-weight:900; color:#334155 }
  .tier-tab.active { color:#fff; border-color:transparent }
  .tier-tabs.buy  .tier-tab.active{ background:#10b981 }
  .tier-tabs.sell .tier-tab.active{ background:#ef4444 }
  .tier-box{ border:1px dashed #cbd5e1; border-radius:12px; padding:8px 10px; background:#f8fafc }
  .headline{ margin:6px 0 8px; padding:8px 10px; border:1px solid #e5e7eb; border-radius:10px; background:#f9fafb; font-size:12px; }
  .headline .k{ color:#64748b } .headline .v{ font-weight:900 }
  .mono{ font-variant-numeric: tabular-nums; }

  /* Hide any legacy tier blocks injected by older patches */
  /* (auto-removed by tier-fix) legacy hide rules deleted */
</style>
<script id="final-tier-sync-one-js">
(function(){
  function ready(fn){ if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn); else fn(); }
  ready(function waitTS(){
    var tries=0, h=setInterval(function(){
      var ts = window.tradingSystem;
      if(ts && typeof ts.analyzeSystemGARCH==='function' && typeof ts.generateTradingStrategy==='function'){
        clearInterval(h); install(ts);
      }
      if(++tries>200) clearInterval(h);
    },100);
  });

  function F2(v){ return (Number.isFinite(v)? Number(v).toFixed(2) : '--'); }
  function rr(entry, tgt, stop){ var g=Math.abs(tgt-entry), l=Math.abs(entry-stop); return l>0? g/l : 0; }
  function vol18(ts){ var v = ts.analyzeSystemVolatility(); return v && v.p18 ? (v.p18.volatilityPercent||2.0) : 2.0; }
  function ptsByVol(v){ return v>=3.0?15:(v<=1.5?10:12); }

  function buildTiers(ts, side){
    var ga = ts.analyzeSystemGARCH() || {}, p18 = ga.p18||{}, p27 = ga.p27||{};
    var strat = ts.generateTradingStrategy() || {}; 
    var seed  = side==='BUY' ? strat.long : strat.short;
    var pts = ptsByVol(vol18(ts));
    var tiers = [];

    if(seed && Number.isFinite(seed.entryRange?.min) && Number.isFinite(seed.entryRange?.max)){
      var ref = (seed.entryRange.min + seed.entryRange.max)/2;
      tiers.push({ key:'T1', label:'NÃ­vel 1 - Zona Principal (RegiÃ£o)', entry:ref,
        stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
        tgt:(side==='BUY')?(ref+pts):(ref-pts),
        note:'RegiÃ£o '+F2(seed.entryRange.min)+'â'+F2(seed.entryRange.max) });
    }
    var s18 = (side==='BUY')? p18.down2sigma : p18.up2sigma;
    var s27 = (side==='BUY')? p27.down2sigma : p27.up2sigma;
    if(Number.isFinite(s18)){
      tiers.push({ key:'T2', label:'NÃ­vel 2 - ExtensÃ£o 18P (Â±2Ï 18P)', entry:s18,
        stop:(side==='BUY')? (s18-10) : (s18+10),
        tgt:(side==='BUY')? (s18+pts) : (s18-pts),
        note:'18P '+ (side==='BUY'?'â2Ï':'+2Ï') });
    }
    if(Number.isFinite(s27)){
      tiers.push({ key:'T3', label:'NÃ­vel 3 - Extremo 27P (Â±2Ï 27P)', entry:s27,
        stop:(side==='BUY')? (s27-10) : (s27+10),
        tgt:(side==='BUY')? (s27+pts) : (s27-pts),
        note:'27P '+ (side==='BUY'?'â2Ï':'+2Ï') });
    }
    if(!tiers.length) return null;
    tiers.sort(function(a,b){ return side==='BUY' ? (b.entry-a.entry) : (a.entry-b.entry); });
    return { tiers: tiers, pts: pts, p18: p18 };
  }

  function removeLegacy(op){
    var bad = op.querySelectorAll('.tier-wrap, #tiersBuy, #tiersSell, .tier-pro, .tier-headline');
    bad.forEach(function(n){ n.remove(); });
  }

  function renderCard(ts, side, host){
    var pack = buildTiers(ts, side);
    host.innerHTML = ''; // limpa qualquer conteÃºdo antigo
    if(!pack){ host.innerHTML = '<p style="font-size:12px;color:#64748b">Sem dados suficientes para '+(side==='BUY'?'compra':'venda')+'.</p>'; return; }
    var tiers = pack.tiers, pts = pack.pts;

    var tabs = document.createElement('div'); tabs.className = 'tier-tabs ' + (side==='BUY'?'buy':'sell');
    var box  = document.createElement('div'); box.className  = 'tier-box';
    var head = document.createElement('div'); head.className = 'headline';

    var storeKey = side==='BUY' ? 'tierBuySelected' : 'tierSellSelected';
    var selectedKey = localStorage.getItem(storeKey) || (tiers[0].key);

    function apply(t){
      localStorage.setItem(storeKey, t.key);
      head.innerHTML = ''
        + '<span class="k">AnÃ¡lise (</span><b>'+t.label+'</b><span class="k">):</span> '
        + '<span class="k">Gatilho</span> <span class="v mono">'+F2(t.entry)+'</span> Â· '
        + '<span class="k">Stop</span> <span class="v mono">'+F2(t.stop)+'</span> Â· '
        + '<span class="k">Alvo</span> <span class="v mono">'+F2(t.tgt)+'</span> Â· '
        + '<span class="k">R/R</span> <span class="v">1:'+rr(t.entry,t.tgt,t.stop).toFixed(2)+'</span>';

      box.innerHTML = ''
        + '<div style="font-size:12px;margin:4px 0">ð¯ Entrada: <b class="mono">'+F2(t.entry)+'</b> '
        + ' | ð Stop: <b class="mono">'+F2(t.stop)+'</b> '
        + ' | â Alvo curto: <b class="mono">'+F2(t.tgt)+'</b> '
        + ' <span style="opacity:.7">(Â± '+pts+' pts)</span></div>'
        + (t.note ? '<div style="font-size:11px;color:#64748b">'+t.note+'</div>' : '')
        + '<div style="font-size:11px;color:#64748b">Alvo final: manter parcial atÃ© o <b>JustÃ­ssimo</b> se a direÃ§Ã£o favorecer.</div>';
    }

    tiers.forEach(function(t){
      var b = document.createElement('button');
      b.type='button'; b.className = 'tier-tab' + (t.key===selectedKey?' active':'');
      b.textContent = t.key;
      b.addEventListener('click', function(){
        tabs.querySelectorAll('.tier-tab').forEach(function(x){ x.classList.remove('active'); });
        b.classList.add('active'); apply(t);
      });
      tabs.appendChild(b);
      if (t.key===selectedKey) apply(t);
    });

    host.appendChild(head);
    host.appendChild(tabs);
    host.appendChild(box);
  }

  function install(ts){
    ts.renderStrategyPanel = function(){
      try{
        var op  = document.getElementById('aiOperation');
        var rk  = document.getElementById('aiRisk');
        var lv  = document.getElementById('aiLevels');
        if(!op) return;

        // limpa duplicatas antigas
        removeLegacy(op);

        // cards base
        op.innerHTML = ''
          + '<div class="card-grid">'
          + '  <div class="card card-success" id="cardBUY">'
          + '    <h4>ð¢ COMPRA â 3 MÃNIMAS</h4>'
          + '  </div>'
          + '  <div class="card card-danger" id="cardSELL">'
          + '    <h4>ð´ VENDA â 3 MÃXIMAS</h4>'
          + '  </div>'
          + '</div>';

        renderCard(ts, 'BUY',  document.getElementById('cardBUY'));
        renderCard(ts, 'SELL', document.getElementById('cardSELL'));

        // GestÃ£o de risco + nÃ­veis (resumo)
        if(rk){
          rk.innerHTML = '<div class="card card-info" style="border-color:#fca5a5; background:linear-gradient(180deg,#fef2f2,#ffffff);">'
            + '<h4>â ï¸ GESTÃO DE RISCO</h4>'
            + '<p>Stop: 10 pts alÃ©m da Ãºltima mÃ¡xima/mÃ­nima do lado da operaÃ§Ã£o.</p>'
            + '<p>Alvo curto: 10â15 pts (vol 18P). Alvo final: JustÃ­ssimo se favorecer.</p>'
            + '<p>Break-even a +8 pts; reduzir lote se vol 18P > 3.0%.</p>'
            + '</div>';
        }
        if(lv){
          var g = (ts.analyzeSystemGARCH()||{}).p18 || {};
          lv.innerHTML = '<div class="nd-wrap">'
            + '<h4 class="nd-title">ð§· NÃ­veis de DecisÃ£o</h4>'
            + '<div class="nd-row">'
            + '  <div class="nd-pill"><div class="nd-label red">RESISTÃNCIA FORTE</div><div class="nd-value">'+F2(g.up1sigma)+'</div></div>'
            + '  <div class="nd-pill"><div class="nd-label green">SUPORTE FORTE</div><div class="nd-value">'+F2(g.down1sigma)+'</div></div>'
            + '</div></div>';
        }
      }catch(e){ console.warn('renderStrategyPanel override error', e); }
    };

    // remove qualquer injeÃ§Ã£o de tiers que aparecer depois
    var scrubber = new MutationObserver(function(muts){
      var op = document.getElementById('aiOperation'); if(!op) return;
      removeLegacy(op);
    });
    scrubber.observe(document.getElementById('aiStrategyPanel')||document.body, {childList:true, subtree:true});

    function hookAfter(name){
      if(typeof ts[name] !== 'function') return;
      var orig = ts[name].bind(ts);
      ts[name] = function(){ var r=orig.apply(ts, arguments); try{ ts.renderStrategyPanel(); }catch(_){ } return r; };
    }
    hookAfter('performAIAnalysis');
    hookAfter('updateAIDisplay');

    setTimeout(function(){ try{ ts.renderStrategyPanel(); }catch(_){ } }, 300);
  }
})();
</script>
<!-- ===== /FINAL TIER SYNC â SINGLE CONTROL ===== -->


<style id="tier-fix-force-display">
  /* === tier-fix: garante que os blocos de tier ficam visÃ­veis === */
  #aiOperation .tier-wrap,
  #aiOperation #tiersBuy,
  #aiOperation #tiersSell,
  #aiOperation .tier-pro,
  #aiOperation .tier-headline { display: block !important; }
</style>

<script id="tier-fix-sync-2025-09">
(function(){
  function ready(fn){ if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn); else fn(); }
  function F2(v){ return (Number.isFinite(v)? Number(v).toFixed(2) : '--'); }
  function RR(entry, tgt, stop){ var g=Math.abs(tgt-entry), l=Math.abs(entry-stop); return l>0? (g/l) : 0; }
  function vol18(ts){ var v = ts.analyzeSystemVolatility?.(); return v && v.p18 ? (v.p18.volatilityPercent||2.0) : 2.0; }
  function ptsByVol(v){ return v>=3.0 ? 15 : (v<=1.5 ? 10 : 12); }

  function computeTiers(ts, side){
    var ga = ts.analyzeSystemGARCH?.() || {}; var p18 = ga.p18||{}, p27=ga.p27||{};
    var s  = ts.generateTradingStrategy?.() || {}; var seed = side==='BUY' ? s.long : s.short;
    var tiers = []; var pts = ptsByVol(vol18(ts));

    if (seed && Number.isFinite(seed.entryRange?.min) && Number.isFinite(seed.entryRange?.max)){
      var ref = (seed.entryRange.min + seed.entryRange.max)/2;
      tiers.push({ key:'T1', label:'NÃ­vel 1 - Zona Principal (RegiÃ£o)', entry:ref,
        stop:(side==='BUY')?(seed.entryRange.min-10):(seed.entryRange.max+10),
        tgt:(side==='BUY')?(ref+pts):(ref-pts),
        note:'RegiÃ£o '+F2(seed.entryRange.min)+'â'+F2(seed.entryRange.max) });
    }
    var s18 = (side==='BUY')? p18.down2sigma : p18.up2sigma;
    var s27 = (side==='BUY')? p27.down2sigma : p27.up2sigma;
    if (Number.isFinite(s18)) tiers.push({ key:'T2', label:'NÃ­vel 2 - ExtensÃ£o 18P (Â±2Ï 18P)', entry:s18,
      stop:(side==='BUY')? (s18-10) : (s18+10), tgt:(side==='BUY')? (s18+pts) : (s18-pts),
      note:'18P '+(side==='BUY'?'â2Ï':'+2Ï') });
    if (Number.isFinite(s27)) tiers.push({ key:'T3', label:'NÃ­vel 3 - Extremo 27P (Â±2Ï 27P)', entry:s27,
      stop:(side==='BUY')? (s27-10) : (s27+10), tgt:(side==='BUY')? (s27+pts) : (s27-pts),
      note:'27P '+(side==='BUY'?'â2Ï':'+2Ï') });

    if (!tiers.length) return null;
    tiers.sort(function(a,b){ return side==='BUY' ? b.entry-a.entry : a.entry-b.entry; });
    return {tiers:tiers};
  }

  function ensureHeadlineHost(card, side){
    var head = card.querySelector('.tier-headline');
    if(!head){
      head = document.createElement('div');
      head.className = 'tier-headline';
      var h = card.querySelector('h4') || card.firstChild;
      if (h && h.parentNode) h.parentNode.insertBefore(head, h.nextSibling);
      else card.insertBefore(head, card.firstChild);
    }
    head.style.background   = (side==='BUY') ? '#ecfdf5' : '#fef2f2';
    head.style.borderColor  = (side==='BUY') ? '#86efac' : '#fca5a5';
    return head;
  }

  function renderInto(card, side, tier){
    var head = ensureHeadlineHost(card, side);
    var rr   = RR(tier.entry, tier.tgt, tier.stop);
    head.innerHTML =
      '<span class=\"k\">AnÃ¡lise (</span><b>'+ tier.label +'</b><span class=\"k\">):</span> ' +
      '<span class=\"k\">Gatilho</span> <span class=\"v\">'+ F2(tier.entry) +'</span> Â· ' +
      '<span class=\"k\">Stop</span> <span class=\"v\">'+ F2(tier.stop) +'</span> Â· ' +
      '<span class=\"k\">Alvo</span> <span class=\"v\">'+ F2(tier.tgt) +'</span> Â· ' +
      '<span class=\"k\">R/R</span> <span class=\"v\">1:'+ rr.toFixed(2) +'</span>';

    var box = card.querySelector('.tier-box');
    if (box){
      var pts = ptsByVol(vol18(window.tradingSystem||{}));
      box.innerHTML =
        '<div class=\"tier-line\"><b>'+ tier.label +'</b></div>' +
        '<div class=\"tier-line\">ð¯ Entrada: <b class=\"tier-mono\">'+ F2(tier.entry) +'</b> ' +
        '&nbsp;|&nbsp; ð Stop: <b class=\"tier-mono\">'+ F2(tier.stop) +'</b> ' +
        '&nbsp;|&nbsp; â Alvo curto: <b class=\"tier-mono\">'+ F2(tier.tgt) +'</b> ' +
        '&nbsp;<span class=\"tier-note\">(Â± '+ pts +' pts)</span></div>' +
        (tier.note ? '<div class=\"tier-note\">'+ tier.note +'</div>' : '') +
        '<div class=\"tier-note\">Alvo final: manter parcial atÃ© o <b>JustÃ­ssimo</b> se a direÃ§Ã£o favorecer.</div>';
    }
  }

  function wireCard(card){
    var isBuy = card.classList.contains('card-success') || /compra/i.test(card.textContent);
    var side  = isBuy ? 'BUY' : 'SELL';
    var pack  = computeTiers(window.tradingSystem||{}, side);
    if(!pack) return;
    var tabs = card.querySelectorAll('.tier-tabs .tier-tab');
    if(!tabs.length) return;
    var map = {};
    pack.tiers.forEach(function(t){ map[t.key] = t; });

    function activeKey(btn){
      var txt = (btn.textContent||'').trim().toUpperCase();
      return txt==='T1' ? 'T1' : (txt==='T2' ? 'T2' : 'T3');
    }

    // initial render
    var active = Array.prototype.find.call(tabs, function(b){return b.classList.contains('active');}) || tabs[0];
    var key0   = activeKey(active);
    renderInto(card, side, map[key0] || pack.tiers[0]);

    // clicks
    tabs.forEach(function(btn){
      btn.addEventListener('click', function(){
        tabs.forEach(function(x){ x.classList.remove('active'); });
        btn.classList.add('active');
        var k = activeKey(btn);
        renderInto(card, side, map[k] || pack.tiers[0]);
      }, {once:false});
    });
  }

  function install(){
    var ts = window.tradingSystem;
    if (!ts || typeof ts.renderStrategyPanel !== 'function'){
      setTimeout(install, 120);
      return;
    }
    var original = ts.renderStrategyPanel.bind(ts);
    ts.renderStrategyPanel = function(){
      var r = original();
      try{
        var op = document.getElementById('aiOperation');
        if(!op) return r;
        var cards = op.querySelectorAll('.card-grid > .card');
        if(cards[0]) wireCard(cards[0]);
        if(cards[1]) wireCard(cards[1]);
      }catch(e){ /* silent */ }
      return r;
    };
  }
  ready(install);
})();
</script>







<script id="fix-a2-daily-final">
(function(){
  // -------- helpers (locale-safe) --------
  function numBR(v){
    if (v==null || v==='') return NaN;
    if (typeof v === 'number') return v;
    var s = (''+v).trim();
    if (!s) return NaN;
    if (s.indexOf(',')>-1 && s.indexOf('.')>-1){ s = s.replace(/\./g,'').replace(',', '.'); return parseFloat(s); }
    if (s.indexOf(',')>-1){ return parseFloat(s.replace(',', '.')); }
    return parseFloat(s);
  }
  function fmtMoneyBR(x){
    var s = Number(x).toFixed(2);
    var p = s.split('.'); p[0] = p[0].replace(/\B(?=(\d{3})+(?!\d))/g,'.');
    return p[0] + ',' + p[1];
  }
  function fmtPts(x){ return Number(x).toFixed(2).replace('.', ','); } // sem milhar

  function readVWAPD(){ return numBR(document.getElementById('vwapD')?.value); }

  function parseTier(box){
    var txt = box.textContent || '';
    var mE = txt.match(/Entrada:\s*([\d\.,]+)/);
    var mS = txt.match(/Stop:\s*([\d\.,]+)/);
    var mT = txt.match(/Alvo curto:\s*([\d\.,]+)/);
    return { entry: numBR(mE && mE[1]), stop: numBR(mS && mS[1]), tgt: numBR(mT && mT[1]) };
  }

  function detectSide(vals){
    if (!isFinite(vals.entry) || !isFinite(vals.tgt)) return null;
    return (vals.tgt >= vals.entry) ? 'BUY' : 'SELL';
  }

  function cleanHeadline(card){
    var h = card.querySelector('.tier-headline'); if (!h) return;
    var s = h.innerHTML || '';
    s = s.replace(/Extens[aÃ£]o\s*18P/gi, 'ExtensÃ£o MÃ©dia')
         .replace(/Extremo\s*27P/gi, 'Extremidade')
         .replace(/\s*\([^)]*\)/g, '');  // remove tudo entre parÃªnteses
    h.innerHTML = s;
  }

  function colorSigmaAlert(box, side){
    var color = side==='BUY' ? '#065f46' : '#991b1b';
    box.querySelectorAll('.tier-note').forEach(function(n){
      var t=(n.textContent||'').trim();
      if (/\b(18P|27P)\b.*Ï/.test(t) || /Zona de sobre(venda|compra) estatÃ­stica/i.test(t)){
        var msg = side==='BUY' ? 'Zona de sobrevenda estatÃ­stica' : 'Zona de sobrecompra estatÃ­stica';
        n.innerHTML = '<span style="display:inline-flex;align-items:center;gap:6px;color:'+color+'"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M1 21h22L12 2 1 21zm11-3h-2v-2h2v2zm0-4h-2V8h2v6z"/></svg><span>'+msg+'</span></span>';
      }
    });
  }

  function enforceA2Daily(box, side, vals, vwapD){
    if (!isFinite(vwapD) || !isFinite(vals.entry) || !isFinite(vals.stop)) return;
    if (side==='BUY' && vwapD < vals.entry) return;
    if (side==='SELL' && vwapD > vals.entry) return;

    // remove qualquer A2 existente (Mensal/Semanal antigos)
    Array.from(box.querySelectorAll('.tier-note.a2')).forEach(n=>n.remove());

    var rr = Math.abs((vwapD - vals.entry) / (vals.entry - vals.stop)) || 0;
    var delta = vwapD - vals.entry;
    var sign = delta>=0 ? '+' : '';
    var div = document.createElement('div');
    div.className = 'tier-note a2';
    div.innerHTML = 'ð¯ Alvo VWAP (A2 â DiÃ¡ria): <b class="tier-mono">'+ fmtMoneyBR(vwapD) +'</b> Â· Î='+sign+ fmtPts(Math.abs(delta)) +' pts Â· R/R=1:'+ rr.toFixed(2);
    var after = box.querySelector('.tier-note');
    (after && after.parentNode) ? after.parentNode.insertBefore(div, after.nextSibling) : box.appendChild(div);
  }

  function apply(){
    var op = document.getElementById('aiOperation'); if(!op) return;
    var cards = op.querySelectorAll('.card, .card-grid > .card');
    var vD = readVWAPD();
    cards.forEach(function(card){
      var box = card.querySelector('.tier-box') || card; if(!box) return;
      var vals = parseTier(box);
      var side = detectSide(vals) || 'BUY';
      var fp = [vals.entry, vals.stop, vals.tgt, vD, side, (card.querySelector('.tier-tabs .active, .tier-tabs .is-active')||{}).textContent].join('|');
      if (card.dataset._a2fp === fp) return;
      cleanHeadline(card);
      colorSigmaAlert(box, side);
      enforceA2Daily(box, side, vals, vD);
      card.dataset._a2fp = fp;
    });
  }

  // run stably
  var scheduled=false;
  function schedule(){ if(scheduled) return; scheduled=true; requestAnimationFrame(function(){ scheduled=false; apply(); }); }
  document.addEventListener('click', function(e){
    if (e.target?.classList?.contains('tier-tab') || e.target?.closest('.tier-tab')) schedule();
  }, {passive:true});
  new MutationObserver(function(){ schedule(); }).observe(document.getElementById('aiStrategyPanel')||document.body, {childList:true, subtree:true});
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', schedule); else schedule();
})();
</script>


<!-- ===== Intraday Enhancements Patch v2 ===== -->
<script>
(function(){
  if (window.__intradayEnhancementsPatchedV2__) return;
  window.__intradayEnhancementsPatchedV2__ = true;
  try { console.log("[Intraday Patch] v2 loaded"); } catch(e){}

  // ---- Polyfills ----
  if (typeof Math.erf !== "function"){
    // Abramowitz & Stegun approximation
    Math.erf = function(x){
      const sign = (x>=0)?1:-1; x=Math.abs(x);
      const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
      const t=1/(1+p*x);
      const y=1-((((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t)*Math.exp(-x*x);
      return sign*y;
    };
  }

  // ---- Helpers ----
  function _phi(x){ return 0.5*(1+Math.erf(x/Math.SQRT2)); }
  function _z(level, ref, sigmaPct){ 
    if(!isFinite(level)||!isFinite(ref)||!isFinite(sigmaPct)||sigmaPct<=0) return NaN;
    return (level/ref - 1) / (sigmaPct/100);
  }
  function _pTouch(level, ref, sigmaPct, side){
    const z = _z(level, ref, sigmaPct);
    if(!isFinite(z)) return 0;
    return (side==='BUY') ? (1 - _phi(z)) : _phi(z);
  }
  function _evPoints(entry, tgt, stop, pWin){
    if(![entry,tgt,stop,pWin].every(isFinite)) return 0;
    const reward = Math.abs(tgt - entry);
    const risk   = Math.abs(entry - stop);
    const p      = Math.max(0, Math.min(1, pWin));
    return p*reward - (1-p)*risk;
  }
  function _regionQuality(levels, vwapD, vwapS, vwapM){
    const lv = (levels||[]).filter(isFinite);
    if(lv.length<2) return 40;
    const spread = Math.max(...lv) - Math.min(...lv);
    const tight   = Math.max(0, 1 - spread/20);
    const vwapRef = [vwapD, vwapS, vwapM].filter(isFinite);
    let vCons = 0;
    if (vwapRef.length){
      const ref = vwapRef.reduce((a,b)=>a+b,0)/vwapRef.length;
      const dist = Math.abs(((ref - (lv[0]+lv[lv.length-1])/2) / ref))*100;
      vCons = Math.max(0, 1 - dist/0.6);
    }
    return Math.round(100 * (0.65*tight + 0.35*vCons));
  }
  function _num(v){
    if(v==null) return NaN;
    if(typeof v === 'number') return v;
    const t = String(v).replace(/\s+/g,'').replace(/\./g,'').replace(',', '.');
    const n = parseFloat(t);
    return isFinite(n)?n:NaN;
  }
  function _getVWAP(id){
    try{
      const el = document.getElementById(id);
      if(!el) return NaN;
      return _num(el.value ?? el.textContent);
    }catch(e){ return NaN; }
  }

  function findCards(){
    const buy = document.getElementById('cardBUY')  || document.querySelector('#aiOperation .card.card-success') || document.querySelector('.card.buy') || document.querySelector('.card-success');
    const sell= document.getElementById('cardSELL') || document.querySelector('#aiOperation .card.card-danger')  || document.querySelector('.card.sell')|| document.querySelector('.card-danger');
    return {buy, sell};
  }

  function getSystem(){
    const sys = window.system || window.tradingSystem || window.aiSystem || window.TradingSystem || window.app || null;
    return sys;
  }

  function calcSigmaPct(sys){
    const p = (sys && sys.currentIntradayP) || 18;
    let s = NaN;
    if(sys && typeof sys.calculateStdDevReturns === 'function'){
      s = sys.calculateStdDevReturns(p);
    } else if (typeof window.calculateStdDevReturns === 'function'){
      s = window.calculateStdDevReturns(p);
    }
    return {period: p, sigmaPct: isFinite(s)?(s*100):NaN};
  }

  function lastClose(sys){
    if(sys && typeof sys.lastClose === 'function') return sys.lastClose();
    if(typeof window.lastClose === 'function') return window.lastClose();
    const el = document.querySelector('[data-last-close], #lastClose, .last-close');
    if(el) return _num(el.textContent||el.value);
    return NaN;
  }

  function renderCardStats(card, side, entry, target, stop, opts){
    if(!card) return;
    card.querySelectorAll('[data-block="intraday-stats"]').forEach(n=>n.remove());
    const {period, sigmaPct} = opts;
    const px = opts.priceRef;

    const pEntry = _pTouch(entry, px, sigmaPct, side);
    const pTgt   = _pTouch(target, entry, sigmaPct, side);
    const pStop  = _pTouch(stop,   entry, sigmaPct, side==='BUY'?'SELL':'BUY');
    const pWin   = Math.max(0, Math.min(1, pTgt / (pTgt + pStop + 1e-9)));
    const ev     = _evPoints(entry, target, stop, pWin);

    const box   = document.createElement('div');
    box.setAttribute('data-block','intraday-stats');
    box.style.marginTop = '8px';
    box.style.border = '1px solid #e5e7eb';
    box.style.borderRadius = '10px';
    box.style.padding = '8px 10px';
    box.style.background = '#fff';
    box.innerHTML = `
      <div style="font-size:12px; font-weight:900; margin-bottom:6px;">ð Probabilidades (intraday ${period}P)</div>
      <div style="font-size:12px; display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:6px;">
        <div>ðª <b>P(Entrada)</b>: ${(pEntry*100).toFixed(0)}%</div>
        <div>ð¯ <b>P(Alvo)</b>: ${(pTgt*100).toFixed(0)}%</div>
        <div>ð <b>P(Stop)</b>: ${(pStop*100).toFixed(0)}%</div>
        <div>â <b>P(Win)</b>: ${(pWin*100).toFixed(0)}%</div>
      </div>
      <div style="font-size:12px; margin-top:6px;">
        ð° <b>EV</b>: ${ev>=0?'+':''}${Math.round(ev)} pts
        &nbsp;|&nbsp; Ï${period} = ${isFinite(sigmaPct)?sigmaPct.toFixed(2):'â'}%
      </div>
    `;
    card.appendChild(box);
  }

  function parseCardNumbers(card){
    // tenta achar entrada/alvo/stop no texto do card
    const txt = (card && card.textContent || '').toLowerCase();
    const mEntry = /entrada[:\s]*([0-9\.,]+)/i.exec(txt);
    const mMeta  = /(meta|alvo)[:\s]*([0-9\.,]+)/i.exec(txt);
    const mStop  = /(stop|stoploss|stop loss)[:\s]*([0-9\.,]+)/i.exec(txt);
    return {
      entry: _num(mEntry && mEntry[1]),
      target: _num(mMeta && mMeta[2]),
      stop: _num(mStop && mStop[2])
    };
  }

  function attachQualityTag(card, levels, vD, vS, vM){
    const qs = _regionQuality(levels, vD, vS, vM);
    const head = card.querySelector('.headline') || card.querySelector('h4, h3, .card-title') || card;
    const tag = document.createElement('span');
    tag.style.fontSize = '11px'; tag.style.color = '#334155'; tag.setAttribute('data-block','intraday-stats');
    tag.innerHTML = ` &nbsp;Â·&nbsp; â­ <b>${qs}</b> qualidade`;
    head.appendChild(tag);
  }

  function runOnce(){
    const {buy, sell} = findCards();
    if(!buy && !sell) return false;
    const sys = getSystem();
    const sigmaInfo = calcSigmaPct(sys);
    const priceRef = lastClose(sys);
    if(!isFinite(priceRef)) return false;
    const vD = _getVWAP('vwapD'), vS=_getVWAP('vwapS'), vM=_getVWAP('vwapM');

    if (buy){
      const {entry, target, stop} = parseCardNumbers(buy);
      if([entry,target,stop].every(isFinite)){
        renderCardStats(buy, 'BUY', entry, target, stop, {period:sigmaInfo.period, sigmaPct:sigmaInfo.sigmaPct, priceRef});
        attachQualityTag(buy, [entry, entry], vD, vS, vM);
      }
    }
    if (sell){
      const {entry, target, stop} = parseCardNumbers(sell);
      if([entry,target,stop].every(isFinite)){
        renderCardStats(sell, 'SELL', entry, target, stop, {period:sigmaInfo.period, sigmaPct:sigmaInfo.sigmaPct, priceRef});
        attachQualityTag(sell, [entry, entry], vD, vS, vM);
      }
    }
    return true;
  }

  // Try immediately and re-try a few times (for SPA hydration)
  function schedule(){
    setTimeout(runOnce, 500);
    setTimeout(runOnce, 1500);
    setTimeout(runOnce, 3000);
    setTimeout(runOnce, 6000);
  }

  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    schedule();
  }else{
    document.addEventListener('DOMContentLoaded', schedule);
  }

  // Also re-run when the user clicks in the AI operation area (likely after recompute)
  document.addEventListener('click', function(ev){
    const el = ev.target;
    if(!el) return;
    if(el.closest && el.closest('#aiOperation, .ai-operation, .recompute, .apply, button')){
      setTimeout(runOnce, 300);
      setTimeout(runOnce, 1200);
    }
  });
})();
</script>
<!-- ===== /Intraday Enhancements Patch v2 ===== -->


<!-- ===== Intraday Bars Visualization Patch (v3b: inside stats box) ===== -->
<script>
(function(){
  if(window.__intradayBarsV3b__) return; window.__intradayBarsV3b__=true;

  function _num(v){ if(v==null) return NaN; if(typeof v==='number') return v; const t=String(v).replace(/\s+/g,'').replace(/\./g,'').replace(',', '.'); const n=parseFloat(t); return isFinite(n)?n:NaN; }
  if (typeof Math.erf !== "function"){
    Math.erf = function(x){
      const sign = (x>=0)?1:-1; x=Math.abs(x);
      const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
      const t=1/(1+p*x);
      const y=1-((((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t)*Math.exp(-x*x);
      return sign*y;
    };
  }
  function _phi(x){ return 0.5*(1+Math.erf(x/Math.SQRT2)); }
  function _z(level, ref, sigmaPct){ if(!isFinite(level)||!isFinite(ref)||!isFinite(sigmaPct)||sigmaPct<=0) return NaN; return (level/ref - 1) / (sigmaPct/100); }
  function _pTouch(level, ref, sigmaPct, side){ const z=_z(level,ref,sigmaPct); if(!isFinite(z)) return 0; return (side==='BUY') ? (1-_phi(z)) : _phi(z); }
  function _evPoints(entry, tgt, stop, pWin){ const reward=Math.abs(tgt-entry), risk=Math.abs(entry-stop); const p=Math.max(0,Math.min(1,pWin)); return p*reward-(1-p)*risk; }

  function findCards(){
    const buy = document.getElementById('cardBUY')  || document.querySelector('#aiOperation .card.card-success') || document.querySelector('.card.buy') || document.querySelector('.card-success');
    const sell= document.getElementById('cardSELL') || document.querySelector('#aiOperation .card.card-danger')  || document.querySelector('.card.sell')|| document.querySelector('.card-danger');
    return {buy, sell};
  }
  function parseCardNumbers(card){
    const txt = (card && card.textContent || '');
    const mEntry = /Entrada[:\s]*([0-9\.,]+)/i.exec(txt);
    const mMeta  = /(Meta|Alvo)[:\s]*([0-9\.,]+)/i.exec(txt);
    const mStop  = /(Stop(?:\s*Loss)?)[:\s]*([0-9\.,]+)/i.exec(txt);
    return { entry:_num(mEntry && mEntry[1]), target:_num(mMeta && mMeta[2]), stop:_num(mStop && mStop[2]) };
  }
  function lastClose(){
    if(typeof window.lastClose==='function') return window.lastClose();
    const el = document.querySelector('[data-last-close], #lastClose, .last-close');
    if(el) return _num(el.textContent||el.value);
    return NaN;
  }
  function calcSigmaPct(){
    const p = (window.system && window.system.currentIntradayP) || 18;
    let s = NaN;
    if(window.system && typeof window.system.calculateStdDevReturns==='function'){
      s = window.system.calculateStdDevReturns(p);
    }else if(typeof window.calculateStdDevReturns==='function'){
      s = window.calculateStdDevReturns(p);
    }
    return {period:p, sigmaPct: isFinite(s)?(s*100):NaN};
  }

  function ensureBars(container, stats){
    if(!container) return;
    // render DENTRO do bloco intraday-stats, logo abaixo do texto de EV
    // se nÃ£o existir intraday-stats, usa o card inteiro
    const host = container.querySelector('[data-block="intraday-stats"]') || container;
    // remove antigos
    host.querySelectorAll('[data-block="intraday-bars"]').forEach(n=>n.remove());

    const wrap = document.createElement('div');
    wrap.setAttribute('data-block','intraday-bars');
    wrap.style.marginTop = '6px';

    function bar(label, val, color){
      const outer = document.createElement('div');
      outer.style.fontSize = '11px';
      outer.style.margin = '2px 0 8px 0';
      const row  = document.createElement('div');
      row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center';
      const lab  = document.createElement('span'); lab.textContent = label;
      const pct  = document.createElement('span'); pct.textContent = (val*100).toFixed(0)+'%';
      row.appendChild(lab); row.appendChild(pct);
      const inner = document.createElement('div');
      inner.style.height = '10px'; inner.style.background = '#e2e8f0'; inner.style.borderRadius = '4px'; inner.style.overflow='hidden';
      const fill = document.createElement('div');
      fill.style.height='100%'; fill.style.width=(val*100).toFixed(0)+'%'; fill.style.background = color;
      inner.appendChild(fill);
      outer.appendChild(row);
      outer.appendChild(inner);
      return outer;
    }

    wrap.appendChild(bar("ð¯ P(Alvo)", stats.pTgt, stats.ev>=0?"#10b981":"#22c55e"));
    wrap.appendChild(bar("ð P(Stop)", stats.pStop, "#ef4444"));
    wrap.appendChild(bar("â P(Win)",  stats.pWin, stats.ev>=0?"#10b981":"#ef4444"));

    const evLine = document.createElement('div');
    evLine.style.fontSize = '11px'; evLine.style.marginTop = '4px';
    evLine.innerHTML = "ð° EV: "+(stats.ev>=0?'+':'')+Math.round(stats.ev)+" pts";
    wrap.appendChild(evLine);

    host.appendChild(wrap);
  }

  function computeAndRender(){
    const {buy, sell} = findCards();
    if(!buy && !sell) return false;
    const px = lastClose();
    const {period, sigmaPct} = calcSigmaPct();
    if(!isFinite(px) || !isFinite(sigmaPct) || sigmaPct<=0) return false;

    function run(card, side){
      const {entry, target, stop} = parseCardNumbers(card);
      if([entry,target,stop].every(isFinite)){
        const pTgt=_pTouch(target, entry, sigmaPct, side);
        const pStop=_pTouch(stop,   entry, sigmaPct, side==='BUY'?'SELL':'BUY');
        const pWin=Math.max(0,Math.min(1,pTgt/(pTgt+pStop+1e-9)));
        const ev=_evPoints(entry, target, stop, pWin);
        ensureBars(card, {pTgt, pStop, pWin, ev});
      }
    }
    if(buy) run(buy, 'BUY');
    if(sell) run(sell, 'SELL');
    return true;
  }

  function schedule(){
    setTimeout(computeAndRender, 800);
    setTimeout(computeAndRender, 1800);
    setTimeout(computeAndRender, 3800);
    setTimeout(computeAndRender, 6800);
  }
  if(document.readyState==='complete' || document.readyState==='interactive'){ schedule(); }
  else { document.addEventListener('DOMContentLoaded', schedule); }

  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.closest && ev.target.closest('#aiOperation, .ai-operation, .recompute, .apply, button')){
      setTimeout(computeAndRender, 500);
      setTimeout(computeAndRender, 1500);
    }
  });
})();
</script>
<!-- ===== /Intraday Bars Visualization Patch (v3b) ===== -->


<script>
(function(){
  function autoloadNow(){
    try {
      const TENANT = (sessionStorage.getItem('tenantId') || 'genesis-trading');
      const VERS = (window.VERSION_TAG || sessionStorage.getItem('versionTag') || 'default');
      if (window.supabase && typeof window.supabase.from === 'function') {
        supabase.from('dol_fechamentos')
          .select('data, rows, imported_at')
          .eq('tenant_id', TENANT).eq('version_tag', VERS)
          .order('imported_at', { ascending:false })
          .limit(1)
          .then(({data,error})=>{
            if(!error && data && data.length){
              const rows = data[0].rows || (data[0].data ? data[0].data.length : 0);
              try { document.getElementById('dataCount').textContent = String(rows); } catch(_){}
              try { window.dispatchEvent(new CustomEvent('dataset:loaded',{ detail:{ tenant:TENANT, version:VERS, length:rows }})); } catch(_){ }
              console.log('Autoload dashboard:', TENANT, VERS, rows);
              // Se a app existir, peÃ§a para recalcular/renderizar
              const app = window.__appInstance || window._lastAppInstance;
              if (app && typeof app.loadFromDB === 'function') { app.loadFromDB(); }
            } else {
              console.log('Autoload: sem dados para tenant atual.');
            }
          });
      } else {
        console.warn('Autoload: supabase client nÃ£o encontrado.');
      }
    } catch(e){ console.warn('Autoload falhou:', e); }
  }
  if (document.readyState === 'complete' || document.readyState === 'interactive') autoloadNow();
  else document.addEventListener('DOMContentLoaded', autoloadNow);
})();
</script>

</body>
<!-- Indicadores de Proximidade (PreÃ§o Atual) -->
<script>
function getProximityStatus(currentPrice, entryPrice) {
  const distance = Math.abs(currentPrice - entryPrice);
  if (distance <= 5) return "ð¯ MUITO PRÃXIMO";
  if (distance <= 10) return "â ï¸ PRÃXIMO";
  if (distance <= 20) return "ð DISTANTE";
  return "ð MUITO DISTANTE";
}
</script>

<!-- Estilos adicionais para a visualizaÃ§Ã£o -->
<style>
  .proximity-badge {
    font-size: 12px;
    padding: 6px 10px;
    border-radius: 12px;
    background: #f3f4f6;
    color: #374151;
    font-weight: 700;
  }
  .tier-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid #e5e7eb;
  }
  .tier-levels {
    display: grid;
    gap: 8px;
    margin-bottom: 12px;
  }
  .level-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 10px;
    border-radius: 8px;
    background: #f9fafb;
  }
  .level-item.entry { border-left: 3px solid #3b82f6; }
  .level-item.stop { border-left: 3px solid #ef4444; }
  .level-item.target { border-left: 3px solid #10b981; }
  .level-label { font-size: 12px; color: #6b7280; font-weight: 600; }
  .level-value { font-weight: 900; font-variant-numeric: tabular-nums; }
  .level-detail {
    font-size: 10px;
    color: #9ca3af;
    margin-left: 8px;
  }
  .tier-explanation, .tier-action {
    font-size: 12px;
    padding: 8px;
    border-radius: 6px;
    margin-top: 8px;
  }
  .tier-explanation {
    background: #eff6ff;
    border: 1px solid #dbeafe;
    color: #1e40af;
  }
  .tier-action {
    background: #f0fdf4;
    border: 1px solid #bbf7d0;
    color: #166534;
  }
  .proximity {
    font-weight: 700;
    font-size: 14px;
  }
  .tier-pro {
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    background: #fff;
    padding: 12px 14px;
    margin-top: 6px;
  }
  .tier-pro h5 {
    margin: 0 0 8px 0;
    font-size: 14px;
    font-weight: 900;
    color: #0f172a;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .tier-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 6px;
  }
  .tline {
    font-size: 13px;
    color: #0f172a;
  }
  .tkey {
    color: #64748b;
    font-weight: 800;
  }
  .tval {
    font-weight: 900;
    font-variant-numeric: tabular-nums;
  }
  .tnote {
    font-size: 12px;
    color: #475569;
    margin-top: 6px;
  }
</style>
